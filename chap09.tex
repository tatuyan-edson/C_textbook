ここまでは変数を一つ一つ扱ってきた。だが、座標を扱う際など、別々の二つの変数を用いてひとつの実体を表すのは不自然であり、見づらい。また、座標を扱う関数などを作る場合、座標を返却値にしたい場合もあるが、関数ではひとつの値しか返すことができず、不便である。これらの問題を解決するために便利なのが、「いくつかの型を組み合わせて新たな型にする」構造体や共用体である。構造体はいくつかの型をセットにして、共用体はひとつのビット列に対していくつかの型による見方を当てはめて用いる派生型で、何れも似たような宣言の仕方を行う。本講ではこれらについて学んでいく。また、特殊な型ではあるが、構造体や共用体と似た形式で定義を行う列挙型についても本講で扱う。

\section{構造体}
まず、いくつかの変数をひとまとめにして扱う、いわば「変数のセットメニュー」である構造体について学んでいこう。
\subsection{構造体の概念}
\textbf{構造体}\index{こうぞうたい@構造体}(structure)とは、複数の変数の集合体を1つの変数として扱うことができるようにした派生型である。例えば、2次元直交座標を表すときには、$x$座標と$y$座標は常にセットで扱えたほうがわかりやすい。このようなときに構造体は威力を発揮する。

配列は同一の型の変数をメモリ上に連続的に並べ、それに通し番号をつけたものであった。構造体は任意の型のいくつかの変数をひとまとめにして名前をつけたものであり、メモリ上に連続的に配置されるなどの特徴はない。
\\ \\　
構造体はセットであることを強調してきたが、これはひとつの実体を表すのにいくつかのデータを用いるという事に対応する。例えば、書籍を考えてみよう。書籍は書名・作者名・価格・ISBNコードなどいくつもの要素を持っている。このそれぞれの要素に変数を割り当てた後、これらをひとまとめにして扱えば書籍を表す変数になるだろう。このとき、構造体の各要素のことを\textbf{メンバ}\index{めんば@メンバ}(member)と呼ぶ。例えば、先に挙げた書籍構造体には、書名を表すメンバ、作者名を表すメンバなどがあると言える。

\subsection{構造体の利用}
構造体の概念を理解した所で、今度は実際に使ってみよう。Joker抜きのトランプを使ったハイ\&ローを実装してみる。
\begin{boxnote}
\minisec{トランプ版ハイ\&ロー}
トランプを用いた1回勝負のハイ\&ローを作成する。
\begin{multicols}{2}
\begin{lstlisting}[caption=トランプ版ハイ\&ロー,label=program9_1]
#include<stdio.h>
#include<stdlib.h>
#include<time.h>

int main(void){
  struct trump{
    char suit;
    short seq;
  }cards[52];
  int r1,r2,i;
  char c;

  for(i=0;i<52;i++){
    switch(i/13){
    case 0:
      cards[i]=(struct trump){'S',i%13+1};
      break;
    case 1:
      cards[i]=(struct trump){'H',i%13+1};
      break;
    case 2:
      cards[i]=(struct trump){'D',i%13+1};
      break;
    case 3:
      cards[i]=(struct trump){'C',i%13+1};
      break;
    }
  }
  
  srand(time(NULL));
  r2=r1=rand()%52;
  while(r2==r1) r2=rand()%52;
  
  printf("now:%c-%d\n",cards[r1].suit,cards[r1].seq);
  printf("is next H/L?>>>");
  c=getchar();

  printf("next:%c-%d\n",cards[r2].suit,cards[r2].seq);
  if(c=='h' || c=='H'){
    if(cards[r1].seq<cards[r2].seq)
      puts("You win!");
    else
      puts("You lose...");
  }else{
    if(cards[r1].seq>cards[r2].seq)
      puts("You win!");
    else
      puts("You lose...");
  }

  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
\minisec{構造体の宣言}
先に述べたように、構造体は型である。従って、その宣言には
\begin{itemize}
\item 新たな構造体型の宣言
\item 作成した構造体型の変数の宣言
\end{itemize}
の2段階がある。ここで、後者の「作成した構造体型の変数の宣言」は、今までの変数と同様に、
\begin{code}
構造体型名 変数識別子名
\end{code}
で行うことができる。そのため、ここで紹介するのは主に前者の「新たな構造体型の宣言」である。
\\ \\　
構造体で新たな型を作成する場合には、次のように行う。
\begin{itembox}[l]{構造体型の宣言}
新たな構造体の型を宣言する場合には
\begin{code}
struct 構造体タグ名{
  メンバの型 メンバ識別子;
  メンバの型 メンバ識別子;
     :           :
};
\end{code}
のように行う。これにより宣言された構造体の名前は\verb|struct タグ名|となる。
\end{itembox}
構造体タグ名とは、構造体そのものの名前であり、これを決めることによって構造体の名前が定まる。注意しなければならないのは、中身が全く同じであっても構造体タグ名が違う構造体は別の型であるという事である。

リスト\ref{program9_1}の$l$.6〜$l$.9に見られるように、構造体型の宣言と構造体変数の宣言を同時に行うこともできる。このような場合、あるいはtypedefを用いる場合には、タグ名を省略して
\begin{code}
struct{
  メンバの型 メンバ識別子;
  メンバの型 メンバ識別子;
     :           :
} 変数名;
\end{code}
のように宣言することもできる\footnote{C11において無名構造体機能が追加されたと書かれているページを見ることがある。これは、ここで示したような「タグのない構造体」の機能ではない。C11においてサポートされた無名構造体とは、後に述べる構造体のネストの際などに、内側の構造体型のメンバにメンバ名をつけずに用いることができるという機能である。この、無名構造体(無名共用体)の機能はC++との互換のためにC11で追加された機能であるが、実際に利用する機会はないと思われるので、本書ではこの脚注以外には述べないものとする。}。このようにタグを省略した場合、タグ名は\textbf{コンパイラが勝手に決める}。従って、タグ名を省略した、中身が全く同じである二つの構造体を作ったとしても、これらは見た目が同じだけで別の型なのである。
\\ \\　
ここでは型が同じであるかどうかについて強調してきた。これは、このあとに学ぶ代入の時などに重要になってくるためである。\textbf{構造体は同一タグ名で宣言されたもののみが同じ型の変数になる}という事を、ここで再強調しておく。

\minisec{構造体の初期化と代入}
構造体を初期化する場合は、通常の配列と同じようにメンバ毎の初期値を順に\{\}とコンマ区切りで記す。勿論、配列と同じように、一部のメンバのみを初期化することもでき、この形での初期化を行った場合、初期化を行わなかったメンバは0で初期化される。
\begin{itembox}[l]{構造体の初期化}
構造体を初期化する場合
\begin{code}
struct tag var={初期値1,初期値2,...};
\end{code}
といった形式で、宣言時に\{\}とコンマ区切りで\footnote{構造体の型宣言時におけるメンバの宣言はセミコロン区切りであるので、混同しないように注意。}初期値を記す。
\\ \\　
C99においては配列同様に\textbf{指示付き初期化子}\index{しじつきしょきかし@指示付き初期化子}が存在し
\begin{code}
struct tag var={
  .メンバ名=初期値,
  .メンバ名=初期値,
       :
}
\end{code}
という形式で初期化を行うことができる。
\end{itembox}

このように、初期化の際には直接\{\}に中身を書くことができるが、代入の場合はまた話が少し変わってくる。一般に、構造体に代入を行う場合、\textbf{同じ型の構造体でなければ代入できない}。これは、少し考えてみれば当然であろう。例えば、人間の身長と体重は共に実数であるし、座標は共に実数である。だが、座標に人間の身長と体重を代入するのは全く意味がない。したがって、もしも似たようなメンバがあったとして、違う型から値を代入したい場合は、この後に述べるメンバ毎の操作に従って、メンバ毎に代入していかなければならない。だが、この方法ではいちいちメンバ名を書くことになり、「セットとして扱う」という利点が活かされていないことになる。そこで、C99において、\textbf{複合リテラル}\index{ふくごうりてらる@複合リテラル}(Compound Literal)という記法が導入された。これは\{\}内に記された値を構造体型にキャストすることにより、一時的にその型の構造体として用いるようにする機能である。
\begin{itembox}[l]{複合リテラルの記法}
複合リテラルは
\begin{code}
(構造体型名){メンバ1の値,メンバ2の値,...}
\end{code}
によって書くことができる。この記法にも指示付き初期化子を利用できる。
\end{itembox}

例えば、リスト\ref{program9_1}の$l$.16を見てみよう。これはメンバ\verb|suit|の値が\verb|'S'|であり、メンバ\verb|seq|の値が\verb|i%13+1|であるような値を、構造体型変数である\verb|cards[i]|に代入している。このように、構造体をまるごと代入する場合には、初期化の時と同様の記法で記し、それを構造体型にキャストすることによって簡単に処理を行うことができるのである。

\minisec{構造体メンバへの操作}
構造体は色々なメンバの集合体であるため、当然メンバ毎に参照できる。
\begin{itembox}[l]{構造体のメンバの参照}
構造体メンバを参照するには、\textbf{選択演算子}\index{せんたくえんざんし@選択演算子}(selection operator)の一つである\textbf{ドット演算子}\index{どっとえんざんし@ドット演算子}(dot operator)\verb|.|を用い
\begin{code}
構造体変数名.構造体メンバ名
\end{code}
と記述する。
\end{itembox}

これにより、構造体のメンバを直接参照できるので、複合リテラルを用いない場合はC99以前の規格の場合は、メンバ毎に代入することで構造体への代入を実現することができる。

リスト\ref{program9_1}においては、例えば$l$.34で用いられている。このように、構造体のメンバはドット演算子を用いて参照してしまえば、後は通常の変数として用いることができるのである(勿論、メンバが派生型である場合には、その派生型の変数として用いることができる)。

\minisec{構造体メンバのメモリ上での配置}
配列の場合、その各要素は連続的に配置されていた。だが、構造体には、連続的に配置されるという性質はない。これは、後で学ぶポインタの運用の際に重要になることである。構造体がメモリ上でどのように配置されるか、ここで簡単に説明しておく。
\\ \\　
構造体は、メモリの先頭から末尾に向かって、メンバの順番を崩さないように配置される。つまり、構造体の第1メンバは第2メンバよりも必ず前にある。しかし、第1メンバと第2メンバの間に「穴」があく場合(=第1メンバと第2メンバが連続でない場合)が存在する\footnote{このような穴は、データ型の大きさとメモリの区切り方(\textbf{アラインメント}\index{あらいんめんと@アラインメント}(alignment))の違いから生じるものである。したがって、アラインメントと型の配置をうまく合わせることで、穴を減らして効率的にメモリを利用できる。}。第2メンバと第3メンバの間も同様の関係であり、以下同様である。但し、メンバが配列である場合、その配列メンバは当然連続である。例えば、第1メンバと第3メンバがint型変数で、第2メンバがint型の配列であるような構造体であれば、第2メンバはその中で連続であるが第1メンバと第2メンバ、第2メンバと第3メンバの各々の間には穴があるかもしれない。以上を図示すると図\ref{chap09_fig01}のようになる。
\begin{figure}[htb]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|c|}\hline
&　&　&　&　&　&　& &\\
$\cdots$&メンバ1&穴&メンバ2&穴&$\cdots$&メンバn&穴&$\cdots$ \\
&　&　&　&　&　&　& &\\ \hline
$\cdots$&\multicolumn{7}{|c|}{構造体}&$\cdots$\\ \hline
\end{tabular}
\caption{構造体のメモリ上での配置のイメージ}\label{chap09_fig01}
\end{figure}

なお、構造体型の配列を作った場合、各要素は連続的に配置されるが、要素毎にメモリをみた場合、その要素の確保したメモリ領域には穴が存在する可能性がある。
\\ \\　
sizeof演算子を構造体に用いた場合、この「穴」の分も構造体の大きさに含まれる。従って、構造体のサイズがメンバのサイズの合計よりも大きくなることもある。

\minisec{構造体のネスト}
派生型は組み合わせることができると説明したとおり、構造体を配列にしたり、配列を構造体のメンバに入れたりすることもできる。また、構造体そのものを構造体のメンバに入れることもできる(\textbf{構造体のネスト}\index{こうぞうたいのねすと@構造体のネスト})。実例として、円と点に関する扱いを見てみよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{円と点の位置関係}
与えられる点が与えられる円の中にあるか外にあるか、あるいは境界上かを判定するプログラムを作成する。なお、位置の判定は関数として独立させる。
\minisec{解説}
点を表す構造体\verb|struct point|を先に定義し、その後でそれを用いた円を表す構造体\verb|struct circ|を定義している。ここが構造体ネストである。

なお、1行目に点の座標を半角空白区切りで、2行目に円の中心の座標と半径を半角空白区切りで入力するようにしている。
\begin{lstlisting}[caption=円と点の位置関係,label=program9_2]
#include<stdio.h>
#include<math.h>

struct point{
  double x;
  double y;
};

struct circ{
  struct point cent;
  double r;
};

int check(struct circ c,struct point p);

int main(void){
  struct circ circle;
  struct point p;
  int flag;
  scanf("%lf %lf",&p.x,&p.y);
  scanf("%lf",&circle.cent.x);
  scanf("%lf",&circle.cent.y);
  scanf("%lf",&circle.r);
  flag=check(circle,p);
  switch(flag){
  case -1:
    puts("The point is in the circle!");
    break;
  case 0:
    puts("The point is on the circle's boundary!");
    break;
  case 1:
    puts("The point is out of the circle!");
    break;
  }
  return 0; 
}

int check(struct circ c,struct point p){
  double dx,dy,dist;
  dx=p.x-c.cent.x;
  dy=p.y-c.cent.y;
  dist=hypot(dx,dy);
  if(dist<c.r) return -1;
  else if(dist>c.r) return 1;
  else return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

リスト\ref{program9_2}を見てもらえばわかるとおり、構造体をネストしたからといって何ら特別の記法が必要になるわけではない。せいぜい、$l$.21に見られるようにドット演算子を2回用いて参照を行なっている程度である。このように、構造体であるメンバを構造体に入れる場合も、他の変数のメンバを構造体に入れる場合も、その変数の記法に従ってコードを記述すれば良い。
\\ \\　
構造体のネストが効果を発揮しているのは、実体の間の関係がよくわかるという事である。再度リスト\ref{program9_2}に目を向けよう。ここでは、円の中心を点の構造体としてネストしている。勿論、円の中心は点であるのでこれは自然なネストであるが、円の中心をわざわざ2つのdouble型変数によって表すよりも見やすいのではないのだろうか。円の構造体を「中心を表す2つの実数と半径を表す実数からなる集合体」とするより、「中心の点を表す構造体と半径を表す実数からなる集合体」としたほうが、円をイメージしやすいのではないか。これが構造体のネストを利用する意義である。この考えはJavaやC++などで用いられる「継承」という機能に応用されている。C言語の学習を終えた後、継承の機能があるプログラミング言語を学んだならば、この構造体ネストの内容を基にしていると考えればより理解しやすいだろう。

\minisec{構造体を用いる関数}
リスト\ref{program9_2}では、構造体を引数に取る関数があらわれている。だが、構造体を用いたからと言って何ら特別なことは為されていない。構造体を引数にとったり、あるいは返却値にしたりする場合も、通常の変数と同様に引数/返却値に記述すれば良いのである。
\\ \\　
ところで、配列引数の場合は、関数内から仮引数へ操作を行うと実引数にも影響を及ぼした。しかし、構造体の場合はどうなのだろうか。勿論これは実験すればわかるので、自分で適当なプログラムを書いて実験してみれば良い。例えば、次のような関数を作ってみれば良い。
\begin{code}
struct tag{
  int x;
  int a[5];
};

void input(struct tag num){
  num.x=100;
  num.a[0]=12345;
}
\end{code}
後はmain関数で\verb|struct tag|型の変数を宣言し、これを\verb|input|関数の引数にして呼び出した後、そのメンバ\verb|x|および\verb|a[0]|の値を出力してみれば良い。

さて、実際に実験してみればわかったと思うが、構造体を用いた場合、構造体は値のコピーが行われる「値渡し」であるので、呼び出された側の関数で構造体を操作したからと言って実引数の構造体には影響を与えない。これは構造体内の配列メンバについても同じなのである。従って、配列を構造体に"包んで"渡せば、関数での操作が実引数に影響されることはなくなるのである\footnote{但し、値をコピーするためにもうひとつ配列を用意するため、当然ながらメモリを食う。}。

構造体を引数や返却値に用いた場合、例えば2つ以上の値を返す関数を作ることができて便利であるし、可読性も上がる。だが、構造体を引数などに使う役目はそれだけではない。構造体は先にあげた配列の例のように、引数を渡す際のオブラートの役目を果たすのである。前講では扱わなかった多次元配列を引数にする関数も、多次元配列を構造体に包んで渡してやれば比較的簡単に実現することができる。勿論、配列を渡す際には要素数情報と共に渡すのであるが、その要素数情報も構造体のメンバに入れて「配列を拡張したような構造体」を作れば\footnote{Javaでは配列そのものが「Cでの素朴な配列に色々機能をつけて拡張したもの」になっており、C++では"vector"という利便性の高い配列が存在している。ここからわかるとおり、「配列を拡張したような構造体」は一般によく用いられるものである。}配列に関して必要な情報を一手に扱うことができる。

\minisec{構造体を使うタイミング}
ここまで、構造体を学んできた上で気づいたであろうが、構造体はマシンやコンパイラに対しての機能と言うよりも、人間にわかりやすくソースを記述するための機能である。そのため、構造体を使うタイミングというものも重要になってくる。勿論、先に書いたように関数から2つ以上の値を返したい場合に一時的に用いることもあるだろうが、大抵の場合、構造体はプログラム中で一貫して用いられるものである。
\\ \\　
構造体を作る際の指針として特別に記述しなければならないことは殆どないが、強いてあげるならば「関係性のあるものを構造体としてまとめ、関係性のないものはまとめない」という事だろうか。概念の説明の際に記述した書籍の例にしてもそうであるが、「ある実体の持つ属性」のみをまとめたものがひとつの構造体になるのが望ましい。書籍のISBNコードと弁当の値段をひとまとめにしたとして、それが一般にわかりやすく使いやすい集合体と言えるだろうか。構造体を用いる場合には「その構造体が何を表すのか」を明確にして、関係性のある変数をまとめるべきなのである。

\subsection{ビットフィールド}
構造体を用いる際に、少し特殊なメンバとしてint型をより小さいビット数に分割した整数型を用いることができる。この機能を\textbf{ビットフィールド}\index{びっとふぃーるど@ビットフィールド}(bit field)という。この機能は使用メモリ量を節約する場合や、ビット毎にフラグを使いたい場合などに用いられる。
\begin{boxnote}
\minisec{誕生日のチェック}
入力される2人の誕生日が年まで同じか、月まで同じか、あるいは同じでないかどうかをチェックする。年・月・日はまとめて4バイト以内に収める。
\end{boxnote}
\begin{boxnote}
\begin{multicols}{2}
\begin{lstlisting}[caption=誕生日のチェック,label=program9_3]
#include<stdio.h>

int main(void){
  struct{
    signed int year:20;
    unsigned int mon:4;
    unsigned int day:5;
  } birth[2];
  short tmp,i;

  for(i=0;i<2;i++){
    scanf("%hd",&tmp);
    birth[i].year=tmp;
    scanf("%hd",&tmp);
    birth[i].mon=(unsigned int)tmp;
    scanf("%hd",&tmp);
    birth[i].day=(unsigned int)tmp;
  }
  if(birth[0].mon==birth[1].mon
     && birth[0].day==birth[1].day){
    puts("Same birthday!");
    if(birth[0].year==birth[1].year)
      puts("And, same birthyear!");
  }else
    puts("Not same birthday!");
  return 0;    
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

ビットフィールドを用いる場合には、次のように行う。
\begin{itembox}[l]{ビットフィールドメンバの宣言}
構造体のメンバをビットフィールドのメンバとする場合、メンバ宣言時に
\begin{code}
メンバ型名 メンバ名:ビットの大きさ;
\end{code}
と、\verb|:ビットの大きさ|を付す。
\end{itembox}

ここで、メンバ型名は通常\verb|signed int|か\verb|unsigned int|である。ビットフィールドの宣言の場合、単に\verb|int|と書いた時の符号の有無は環境に依存する。そのため、リスト\ref{program9_3}でも全てのビットフィールドの符号を明示しているのである。
\\ \\　
ビットフィールドは通常とは違う切れ目を作るため、アドレスを取得できなかったり、定まった大きさの倍数にならなければ足りない分だけ構造体に「穴」ができたりするといった欠点を持つ。だが、それらの欠点を含めても余りあるメモリ使用量削減効果を発揮する。とりわけ、メモリ量が大きく制限されている環境において配列などを用いたい場合、その値の最大値などを考慮してビットフィールドを用いればメモリの節約になることは多い\footnote{例えば、1990年代頃までのコンシューマ向けゲーム機などでは、メモリ節約のためにビットフィールドを使っているように見受けられる「パラメータの限界値」が散見される。}。しかし、使い方を上手く考えなければ、効果的な運用とはならない場合もある。

たとえば、本書で説明しているgccなどでは、構造体を$4n$バイトで表そうとする為、4バイトに満たないビットフィールドを作った場合に「穴」が生まれる\footnote{これはchar型やshort型を用いて4の倍数の大きさでない構造体を作っても同様である。}。また、この$4n$バイトになるような制限のために、却ってサイズを大きくしてしまう場合もある。例えば9ビットのビットフィールド3つの後に17ビットのビットフィールドを作り、更にその後にshort型のメンバを取ろうとすると、12バイトの構造体になってしまう場合がある。これは、合計で27+17+16=60bit\footnote{ここではshortを2バイトとした。以下同様。}で、8バイトに収まるはずと考えられる。だが、4バイトごとの境界線をまたぐことができない環境\footnote{厳密には、intの大きさ毎に境界があるという方が多い。ここではint型を4バイトとして書いた。}というものがある。ここで12バイトになってしまったのは、4バイトごとの境界線をまたぐことができない環境であったために9ビット3つの後に穴が空いて4バイトとなり、更に17ビットの後にも穴が空いて4バイト、shortの後にも穴が…となったものである。この場合、short型4つ+int型1つで12バイトであるので、制限が多いビットフィールドを用いるメリットは感じられない。

以上のように、ビットフィールドはよく考えて用いなければならないが、有効に利用すればメモリの節約効果は大きい。
\\ \\　
なお、ここではint型を基にしたビットフィールドについて紹介したが、C99においては\verb|_Bool|型のビットフィールドも許される。この為、フラグの集合体などを利用する際にもビットフィールドを有効活用することができる。

\section{共用体}
構造体と同じ形で宣言/参照するもうひとつの派生が\textbf{共用体}\index{きょうようたい@共用体}(union)である。
\subsection{共用体の概念}
共用体は構造体と同じくいくつもの型のメンバを持つ「メンバの集合体」である。しかし、当然構造体とは違う型である。

共用体はあるメモリ領域に違う見方を当てはめた集合体である。例えば、ビット列が全て1であるような32bitを考えよう。この時、このビット列をint型で見るとこれは-1であるが、unsigned int型で見るとこれは\verb|UINT_MAX|の値になる。float型の場合、これはNaNを表す値である。このように、同じビット列でも違う型であればその値はかわってくる。この、ひとつのビット列に対して「いくつもの見方」を与えたものが共用体である\footnote{キャストすれば良い、と思うかもしれないが、キャストは「値を保存する変換」であって「ビット列を保存する変換」ではない。従って、-1をfloat型にキャストしてもNaNにはならない。int型の-1をunsigned intにキャストすると最大値になるのは、unsigned intの最小値が0で、そこからオーバーフローを起こすためである。}。

\subsection{共用体の利用}
共用体を利用する例はそれほど多くは思いつかないが、例えばベクトルと複素数を対応付けるなどが考えられる。その例を見てみよう。
\begin{boxnote}
\minisec{ベクトルの回転}
ベクトルの90度回転を行うプログラムを書く。
\end{boxnote}

\begin{boxnote}
\minisec{解説}
共用体を用いてベクトルを一時的に複素数とみなすことにより、$e^{\frac{i\pi}{2}}$をかけるだけで計算することができる。
\begin{lstlisting}[caption=ベクトルの回転,label=program9_4]
#include<stdio.h>
#include<math.h>
#include<complex.h>
#include<tgmath.h>

int main(void){
  struct vec{
    double x;
    double y;
  };
  union cvec{
    struct vec v;
    double complex comp;
  }cvecs;
  const double pi=atan(1.0)*4;

  scanf("%lf %lf",&cvecs.v.x,&cvecs.v.y);

  cvecs.comp*=exp(I*pi/2);
  printf("%lf,%lf\n",cvecs.v.x,cvecs.v.y);
  printf("%lf+%lfi\n",creal(cvecs.comp),cimag(cvecs.comp));
  return 0;
}

\end{lstlisting}
\end{boxnote}

リスト\ref{program9_4}をみてもらえばわかるとおり、共用体の宣言や定義、参照方法は\textbf{構造体と同じ}である。ただ、structと書いていたところがunionに変わっただけである。
\\ \\　
注意しなければならないのは共用体の初期化である。共用体を初期化する場合、先頭で宣言したメンバの型で行う。
\begin{itembox}[l]{共用体の初期化}
共用体の初期化を行う際には
\begin{code}
共用体名 変数名={先頭メンバの型での値};
\end{code}
と記す。先頭メンバ以外で初期化したい場合は、指示付き初期化子を用いる。
\end{itembox}

なお、共用体に複合リテラルはない。また、共用体へのキャストは、キャスト元が共用体の中にある型の場合のみに許される。この時、当然キャスト元の値の型のメンバを用いて代入が行われる。例えば、リスト\ref{program9_4}の$l$.19のように直接\verb|cvecs.comp|とメンバを指定して代入することもできるが、double complex型の計算を行った後に共用体型へのキャストを行なって
\begin{code}
cvecs=(union cvec)(cvecs.comp*exp(I*pi/2));
\end{code}
のようにしても、同じ動作を示す。

以上のように、共用体はほぼ構造体と同じ方法で利用することができるが、構造体が複数実体をひとつにまとめているのに対して、共用体が一実体をまとめているという違いから、運用にも少し違いが出てくる。この点に注意すれば、例えば浮動小数点数のビットの状態を見るなどの利用方法が考えられるだろう。

\section{列挙型}
列挙型は派生型ではなく、基本型でもない「特殊な型」である。
\subsection{列挙型の概念}
\textbf{列挙型}\index{れっきょたい@列挙型}(enumeration)は、その変数の取りうる値を全て列挙することからこの名前になった型である。例えば、曜日を表す型を作ることを考えると、取るべき値はSunday,Monday,$\cdots$の全部で7つである。これらをそれぞれ0,1,$\cdots$,6に対応させておけば、コンピュータ内でも扱いやすいし、曜日のフラグとしても使いやすい。そこで、0はSunday,1はMonday,$\cdots$,6はSaturdayという事を列挙し、これを新しい型とすることができる。この機能が列挙型である。

列挙型はその性質上、フラグとして用いられる場合が多い。とりわけ、C99以前の規格において\verb|_Bool|型と同等の機能を実現するのに用いられることが多かった。

\subsection{列挙型の利用}
それでは、実際に列挙型の扱いを見ていくことにしよう。先に扱った「円と点の位置関係」のプログラム(リスト\ref{program9_2})は、列挙型を用いるとよりわかりやすく書き直せる。
\begin{boxnote}
\minisec{円と点の位置関係(列挙型版)}
リスト\ref{program9_2}のプログラムを、列挙型を用いて書きなおしてみる。
\minisec{解説}
点が円の内側・境界・外側のどれに位置するかを表す\verb|flag|を列挙型を用いて実装した。int型の時より「読んでわかる」ようになったことを実感してほしい。
\end{boxnote}
\begin{boxnote}
\begin{multicols}{2}
\begin{lstlisting}[caption=円と点の位置関係(列挙型版),label=program9_5]
#include<stdio.h>
#include<math.h>

struct point{
  double x;
  double y;
};

struct circ{
  struct point cent;
  double r;
};

enum place{
  IN=-1,
  BOUNDARY=0,
  OUT=1
};

enum place check(struct circ c,struct point p);

int main(void){
  struct circ circle;
  struct point p;
  enum place flag;
  scanf("%lf %lf",&p.x,&p.y);
  scanf("%lf",&circle.cent.x);
  scanf("%lf",&circle.cent.y);
  scanf("%lf",&circle.r);
  flag=check(circle,p);
  switch(flag){
  case IN:
    puts("The point is in the circle!");
    break;
  case BOUNDARY:
    puts("The point is on the circle's boundary!");
    break;
  case OUT:
    puts("The point is out of the circle!");
    break;
  }
  return 0; 
}

enum place check(struct circ c,struct point p){
  double dx,dy,dist;
  dx=p.x-c.cent.x;
  dy=p.y-c.cent.y;
  dist=hypot(dx,dy);
  if(dist<c.r) return IN;
  else if(dist>c.r) return OUT;
  else return BOUNDARY;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

リスト\ref{program9_2}とリスト\ref{program9_5}はほとんど同じプログラムである。違うのは、次に示すところと列挙型の定義がある所だけである(冒頭の行数はリスト\ref{program9_5}での行数を示す)。
\begin{description}
\item[$l$.20] リスト\ref{program9_2}の$l$.14に対応。関数\verb|check|の型が違う。
\item[$l$.25] リスト\ref{program9_2}の$l$.19に対応。\verb|flag|の型が違う。
\item[$l$.32] リスト\ref{program9_2}の$l$.26に対応。caseの値が違う。
\item[$l$.35] リスト\ref{program9_2}の$l$.29に対応。caseの値が違う。
\item[$l$.38] リスト\ref{program9_2}の$l$.32に対応。caseの値が違う。
\item[$l$.50] リスト\ref{program9_2}の$l$.44に対応。返却値が違う。
\item[$l$.51] リスト\ref{program9_2}の$l$.45に対応。返却値が違う。
\item[$l$.52] リスト\ref{program9_2}の$l$.46に対応。返却値が違う。
\end{description}

\minisec{列挙型の宣言と定義}
列挙型の宣言・定義方法は、ほとんど構造体・共用体と同じである。例えば、列挙型変数の宣言方法や、列挙型タグなどの扱いについては構造体・共用体と同じで、ただタグの前が\verb|enum|に変わっただけである\footnote{勿論、構造体と同じようにタグ名の省略なども可能である。}。だが、列挙型を詳述する\verb|{}|の中は話が違い、\textbf{コンマ区切りである}。
\begin{itembox}[l]{列挙型の宣言}
列挙型型を宣言する際には
\begin{code}
enum 列挙型タグ名{
  列挙名1=整数定数値1,
  列挙名2=整数定数値2,
    :
  列挙型n=整数定数値n
};
\end{code}
の形式で行う。なお、C99においては最後の整数定数値(\verb|整数定数値n|)の後にコンマを置くことが許される。
\end{itembox}

このようにして宣言された列挙型は、原則コード中で列挙名の形式で扱われる。例えば、リスト\ref{program9_5}で\verb|enum place|であるところは、全てIN,OUTなどと書かれている。従って、整数定数値に意味がない場合も少なくない。このような場合、例えば
\begin{code}
enum place{IN,BOUNDARY,OUT};
\end{code}
のように、整数定数値を省いて宣言を行なっても構わない。
\\ \\　
逆に整数定数値が必要になる場合はどのような場合かを考えてみよう。実は、列挙型は内部的に整数型として扱われる。従って、リスト\ref{program9_5}の$l$.31の\verb|switch|の後を\verb|(flag*flag)|のようにすると、このプログラムではINの場合が出なくなる。これだけでは一見何の意味もないように見えるが、列挙型が演算できると嬉しいこともある。例えば先の曜日の例を考えれば良い。現在の曜日に、何日後であるかの日数を足し、7による剰余を取れば列挙型が適切な曜日を示す変数になってくれる。また、列挙子の最後に一つ追加で列挙子を置けば、その列挙子の値が個数になる、という活用方法もある(\textbf{番兵}\index{ばんぺい@番兵}(sentinel)\footnote{番兵は、ターミネータと似たようなものであるが、ターミネータが実データに存在しない終端を示す値という定義なのに対し、番兵はターミネータを含み、終端処理を簡単化するための値またはダミーデータのことを示す。例えば、二次元配列に入れられた迷路において、その端を「壁」で囲んでしまった場合などは、壁が番兵である。}の一種)。

また、整数定数値を明示する場合には、気をつけなければならないこともある。それは、異なる列挙名に同じ整数定数値を割り当ててしまう場合である。この場合でもコンパイルは無事に通るが、違う列挙名であるのに等しかったり、switch文が正しく動作しなかったりする場合が起こる。

以上からわかるとおり、列挙型では必要のない限り、整数定数値の対応付けを明示しなくても良い(寧ろ、エラーを起こさないために、必要外にしないほうが安全かもしれない)。仮に整数定数値を全く決めなかった場合、通常は最初の列挙名を0に対応する値としてコンパイラが順に整数定数値を定めてくれる。また、値を明示的に定めた後続の列挙名には、値を明示的に定めた列挙名に+1,+2,$\cdots$した値が自動的に割り当てられる。そのため、余程のことがない限り、全ての整数定数値を記す必要はない。
\\ \\　
ここでみたように、列挙型はフラグとして利用すると便利である。また、各列挙名は定数であるため、変数ではなく定数であることを明示するために大文字ばかりで名前を付ける場合も少なくない。大文字ばかりで名前をつける、と言えばすぐに思いつくのがマクロであろう。確かに、マクロと同様にフラグなどに用いることができるが、マクロと違う点として
\begin{itemize}
\item 列挙型は整数型であり、整数以外の値を置換するわけではない。
\item 列挙型の実体はあくまで変数及び値であり、コンパイル時に処理されるわけではない。
\end{itemize}
などが挙げられる。この点に注意して活用されたい。
\\ \\　
最後まで触れなかったが、列挙名やメンバ名、タグ名等は全て識別子であるので、識別子の命名規則に則って名付けを行わなければならない。また、違う構造体/共用体/列挙型のメンバ(列挙名)が同一であっても良いし、構造体/共用体のメンバと同じ名前の変数を用いたり、(列挙型も含めて)タグ名と同じ名前の識別子を用いても構わない(タグ名の前につくstructやunion,enumで識別可能であるため)。
\newpage

\begin{shadebox}
\section*{本講の要点}
本講では、構造体・共用体・列挙型について学んだ。

\subsection*{共通の性質}
\begin{itemize}
\item 構造体・共用体・列挙型の型の名前は、"(struct/union/enum)+タグ名"である。
\item 宣言時にはタグ名を省略でき、その場合はタグ名が内部で自動的に決まる。
\end{itemize}

\subsection*{構造体}
\begin{itemize}
\item 構造体はひとつの実体に複数の属性をもたせた、変数の集合体である。
\item 構造体は同一の型でなければ代入ができない。簡単に代入を行うためには複合リテラルを活用する。
\item 構造体(共用体も)のメンバの参照には直接選択演算子\verb|.|を用いる。
\item 構造体のメモリ上での配置は、後ろのメンバのほうが後側に配置される以外に定まった規則はない。多くの場合、4バイト毎に区切りが定まっており、その区切りを必要以上にまたがないように「穴」を作るため、構造体メンバの連続性は保証されない。
\item 構造体を関数に渡す場合は値渡しである。
\item 構造体は様々な派生型を関数とやり取りする際のオブラートの役目を果たす。
\item 構造体を用いる際にはint型を任意のビット数に分けて用いることができる(ビットフィールド)。
\item 構造体を用いる際には関係性の見えるものをひとつにまとめなければならない。
\end{itemize}

\subsection*{共用体}
\begin{itemize}
\item 共用体はビット列に複数の読み方を当てはめられるようにしたものである。
\item 共用体の初期化は原則先頭メンバで行われる。ただし、指示付き初期化子を用いて別のメンバを用いることもできる。
\end{itemize}

\subsection*{列挙型}
\begin{itemize}
\item 列挙型は取りうる値に名前をつけ、列挙したものである。
\item 列挙型は内部的に整数型として扱われ、整数に対する演算と同じ演算を行うことができる。
\end{itemize}
\end{shadebox}

いよいよ、C言語において山場とされるポインタに入る。ポインタは、その広がりを考え、今回その基礎を説明し、次回は活用方法について学んでいく。
\\ \\　
ポインタは難しいと一般に言われるが、あくまでも変数の一種であり、派生型の一種である。それ故、変数であることを念頭において今回の内容を学んでいってほしい。また、ポインタはここまでに学んできた内容とも密接に関わっている部分であるので、十分に復習しながら、関連付けながら読み進めていただきたい。

\section{メモリ領域再論}
ポインタの解説に入る前に、もう一度メモリ領域について復習しておこう。
\\ \\　
C言語で扱う際のメモリ領域には大きく分けて次の4つがあった。
\begin{itembox}[l]{メモリの4領域}
\begin{itemize}
\item \textbf{プログラム領域}\index{ぷろぐらむりょういき@プログラム領域}:プログラムを実行するためのプログラムコードが置かれる領域。
\item \textbf{静的領域}\index{せいてきりょういき@静的領域}:外部変数や静的変数等の、プログラムの実行の間=寿命となる変数を格納する領域。
\item \textbf{スタック領域}\index{すたっくりょういき@スタック領域}:一般の変数、関数の引数や返却値、長い計算式の一時変数などが置かれる領域。
\item \textbf{ヒープ領域}\index{ひーぷりょういき@ヒープ領域}:プログラム中で動的にメモリが確保される場合に使われる領域。
\end{itemize}
\end{itembox}

ポインタを用いれば、これらの領域のうちプログラム領域を除く各領域を扱うことができる。この際、重要なのが、メモリには\textbf{アドレス}\index{あどれす@アドレス}(address)という番号がふられており、これによってメモリ上に配置されているデータの場所が示される、という事である。アドレスはその環境によって「区切り」(アラインメント)が定められている。例えば、メモリは4バイト単位で用いられたり、開始アドレスの1の位が一定であったり、といった現象が起こる。また、アドレスは1バイト区切りでしか取得できない。例えばビットフィールドを用いた時、そのメンバへの直接の(scanfなどを用いた)入力はできないし、各メンバの位置が4の倍数の位置になるように穴が空いた。穴が空くのはアラインメントに従って位置を揃えるためである。一方、入力できないのはビットフィールドが特殊な区切りになっているためにアドレスを取得できず、それ故にscanf関数を用いることができないためである。アドレスを取得できなければscanf関数が使えないとは一体どういうことかは、ポインタを学ぶことで理解できる。

\section{アドレスとポインタ}
ポインタは先に少々書いたとおり、アドレスと密接な関係がある。ここではまず、C言語におけるアドレスの扱いについて学んだ後、それを保持する変数の必要性について論ずることでポインタを自然な形で導入していく。
\subsection{アドレスの取得と意義}
関数を扱う場合、原則的に実引数には影響を与えなかった。だが、例えば「実引数を初期化する関数」や「実引数に何かを代入する関数」等を実現することはできないのであろうか。この問いかけに対して、一つの答えとなっているのが慣れ親しんできたscanf関数である。scanf関数は「実引数に、入力された値を代入する」関数である。これは、関数の章で学んだ「関数は実引数に影響を与えない」ということとは異なっている。これは一体どうしたことか。
\\ \\　
翻ってscanf関数の引数を見てみると、scanf関数の引数には\&という怪しげな記号が付いていることがわかる。これが全ての魔法の種である。では、早速この\&について見ていくことにしよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{配列のアドレス確認}
配列の各要素が連続的に配置されているかどうかを、配列の各要素のアドレスを出力することによって確認する。ここでは1バイトであり連続性がわかりやすいchar型配列を用いる。
\begin{lstlisting}[caption=配列のアドレス確認,label=program10_1]
#include<stdio.h>

int main(void){
  char array[10],i;
  for(i=0;i<10;i++)
    printf("%p\n",&array[i]);
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

\minisec{メモリの性質の確認}
プログラムそのものの解説に入る前に、出力結果を確認し、配列の性質などを確認しておこう。なお、リスト\ref{program10_1}は配列\verb|array|の各要素のアドレスを出力するプログラムである。

リスト\ref{program10_1}を筆者の環境でコンパイルして実行した所、第1回の実行では
\begin{code}
0x7fff3416bda0
0x7fff3416bda1
0x7fff3416bda2
0x7fff3416bda3
0x7fff3416bda4
0x7fff3416bda5
0x7fff3416bda6
0x7fff3416bda7
0x7fff3416bda8
0x7fff3416bda9
\end{code}
となった。もう一度実行してみると、今度は
\begin{code}
0x7fff0ab542e0
0x7fff0ab542e1
　　(中略)
0x7fff0ab542e9
\end{code}
と出力された。先頭に\verb|0x|が付いていることからわかるとおり、アドレスは16進数で表されており、単位はバイトである。実際にそれぞれの値を見てみると、第1回でも第2回でも、たしかに1バイト毎にアドレスがかわっており、連続的に配置されていることがわかる。

また、これに加えて何回か実行してみても、筆者の環境では必ず1の位が0であった。これは、先に書いたように「区切りがあって、始まる値が定まっている」という事に合致している。
\\ \\　
更に、もうひとつ注目すべきこととして、実行するたびにアドレスが変わるという事が挙げられる。しかも、何度か実行してみればわかるが、この変化は規則的なものではない。このことこそ、RAMのRA=Random Accessの証拠である。Random Accessは実行するたびに異なるアドレスが割り当てられるものだった。そして、ここでの出力結果は確かに毎回変わっているのである。
\\ \\　
なお、リスト\ref{program10_1}の配列の宣言を、例えばint型にした所、int型が4バイトである筆者の環境では
\begin{code}
0x7fff69b80c20
0x7fff69b80c24
0x7fff69b80c28
0x7fff69b80c2c
    :
\end{code}
と4バイト毎のアドレスが得られた。これは他の大きさの型でも同様である。

\minisec{アドレスの取得方法}
では、アドレスを出力したからくりについて説明していこう。リスト\ref{program10_1}において、知らない文法はただ1行、$l$.6だけであろう。$l$.6にある\verb|%p|書式指定子は、アドレスを出力するための書式指定子であり、対応する可変引数のアドレスを、前述のように16進で出力する。そしてもうひとつが、scanfでさんざん用いてきた\&(アンパサンド)である。
\\ \\　
\&はそれを付した項にのみ働く単項演算子で、付したオブジェクトのアドレスを取得する演算子であり、\textbf{アドレス演算子}\index{あどれすえんざんし@アドレス演算子}(address operator)と呼ばれる。一般の変数や構造体(共用体・列挙型)変数及びそのメンバ\footnote{共用体のメンバのアドレスは定義から考えてわかるとおり、何れも同じである。従って、単にアドレスを見たいだけであれば共用体に直に\&を付しても良い。}、配列の各要素については、\&を付すだけでアドレスを取得することができる。
\\ \\　
一方、関数のアドレス\footnote{関数にアドレスがあるというのは、一見想像しにくいかもしれない。だが、関数もスタック領域にあるという事、関数型は派生型の一種であることを思い返せば、関数にもアドレスがあってしかるべきだろう。}や配列のアドレス\footnote{配列のアドレスは配列の先頭アドレス=配列の先頭の要素であるので、\verb|&a[0]|としても取得することができるが、「配列全体の先頭アドレス」というニュアンスが伝わりにくくなるため推奨し難い。}を取得したい場合は、この演算子は用いない。関数と配列の場合は、その関数名/配列名のみを記せばその先頭のアドレスになる。これらをまとめておこう。
\begin{itembox}[l]{アドレスの取得方法}
あるオブジェクトのアドレスを取得する場合は通常
\begin{code}
&オブジェクト
\end{code}
によってアドレスを取得する。但し、関数及び配列のアドレスを取得したい場合は
\begin{code}
関数(配列)名
\end{code}
と、単に関数/配列の名前だけを記す。
\end{itembox}

なお、ビットフィールドはバイト区切りになっていないため、レジスタ変数はそもそもメモリ上に置かれていないため、アドレスを取得することはできない。
\\ \\　
また、\&はアドレス演算子である他に二項演算子としてビット毎のアンド演算を行う算術演算子でもある。これは文脈から読み取る必要があるわけだが、\&の直前に項があるかないかを注意深く見て、混同しないようにしなければならない。

\minisec{何故アドレスを用いるのか}
先に習った\&演算子はscanfの第2引数以降に、ここまで天下り的に「記すこと」と書いてきた\&そのものである。このことは先にも触れたが、何故これによって実引数の実体に影響を及ぼすことができるのかを考えてみよう。
\\ \\　
実体を渡す場合(\textbf{値渡し}\index{あたいわたし@値渡し})とアドレスを渡す場合(\textbf{アドレス渡し}\index{あどれすわたし@アドレス渡し})の違いは何だろうか。値を渡す場合、実引数の情報はただ値だけしか渡されない。元の型をキャストして渡したものなのか、計算式によって計算されたものなのか、それとも予定通りの型の変数そのものなのかは分からない。一方、アドレスを渡した場合には、そのオブジェクトの場所がわかり、ひいてはその実体にアクセスできる。換言すれば、値渡しの場合、変数という箱の中身しかわからず、どのような箱かを知ることはできないが、アドレス渡しの場合は元の箱の場所がわかるためそれを直接弄ることができる、という事である。
\\ \\　
より厳密に値渡しとアドレス渡しの違いを記そう。
\begin{itembox}[l]{値渡しとアドレス渡しの差異}
\begin{description}
\item[値渡し] 関数がローカルで用意した変数に、元の値だけをコピーして利用する。
\item[アドレス渡し] 関数に元の変数の場所を渡し、その場所にある変数=元の変数を直接操作する。
\end{description}
\end{itembox}
このことからわかるとおり、変数の位置さえわかってしまえば、元の変数を適当な型に当てはめて使うことができるのである。これこそが"何故アドレスを用いるのか"の答えである。

\minisec{アドレス渡しはスコープに影響を与えるか}
アドレスを用いて他の関数から元のオブジェクトを操作できるというのは、スコープの考えからするとおかしな話のように思える。スコープの定義は、「そのオブジェクトがコード上のどの位置で有効であるか」であった。だが、これだけでは先の「アドレスを渡せば他の関数から元の引数を弄ることができる」という話と矛盾するように見える。
\\ \\　
スコープは、より厳密に言うと「そのオブジェクトが、その型・識別子で、コード上のどの位置まで通用するか」である。従って、あるオブジェクトがメモリ上にある時、これを他の関数などから「別の名前・別の型で」参照したり、書き込んだりすることは可能かもしれない。要するに、宣言された識別子が、どこまでその宣言通りに動作するかというのがスコープなのである。この「識別子が通用する範囲」のことを\textbf{名前空間}\index{なまえくうかん@名前空間}(namespace)という。厳密に言えば、宣言によって名前空間が定まり、その名前空間がスコープになる、というのが本来の名前空間・スコープの考えである。

翻って、別関数にアドレスを渡して元の変数を操作することを考えよう。これはアドレスが渡された段階で別の名前空間に位置する。すなわち、操作する対象は同じなのだが、それを表す識別子(及び型)は異なるのである。main関数では\verb|a|という名前であるが、自作関数ではこれを\verb|b|という名前にする。そして、実際は同じ物を指しているのであるが、main関数の中では\verb|a|と呼び表さなければならず、自作関数の中では\verb|b|と呼び表さなければならない、という事になる。この\verb|a|および\verb|b|という名前が通用する範囲が名前空間、スコープなのである。

もう少し別の例を出してみよう。英語のappleと日本語の林檎は同じ物を指している単語である。だが、英語しか使えない人の集団ではappleと呼び表さなければならず、日本語しか使えない人の集団では林檎とよび表さなければならない。このappleないし林檎と呼ばれているものを食べる場合、英語圏の人はappleが口の中に入っていく様子を、日本語圏の人は林檎が口の中に入っていく様子を思い浮かべるだろう。この思い浮かべられた動作は全く同じであるし、対象となっている事物も同じなのであるが、呼び名(=識別子)は異なっている。これがmain関数と他の関数の間でも起こっているのである。そして、appleと言ってどこまで通用するか、林檎と言ってどこまで通用するかを示しているのが名前空間、スコープというものなのである。

\minisec{アドレスを用いた参照の危険性}
先のスコープの議論から、アドレスを用いて別関数からそのオブジェクトに対して操作を施す場合、それは既に異なるスコープに属しているのであり、元々学んできたスコープには何ら影響を与えないという事がわかった。そして、このことが厄介な(あるいは危険な)問題の引き金にもなるのである。
\begin{boxnote}
\begin{multicols}{2}
\minisec{const修飾子付き変数への入力}
const修飾子をつけた変数はRead Onlyであり書き換えることができない。しかし、それがローカルに宣言されている場合、名前空間が異なることを考慮に入れれば別関数にアドレスを渡して操作できるのではないだろうか？この疑問を確かめてみる。
\begin{lstlisting}[caption=const修飾子付き変数への入力,label=program10_2]
#include<stdio.h>

int main(void){
  const int a=3;
  scanf("%d",&a);
  printf("%d\n",a);
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

リスト\ref{program10_2}をコンパイルした所、筆者の環境では警告こそ出たもののコンパイルそのものには成功した。また、実際にプログラムを実行させてみた所、入力した値を出力するという、const修飾子を付さない場合と全く同様の動作であった。これでは、constの意味がなくなってしまう。
\\ \\　
実は、アドレスを用いれば、本来そのプログラムが参照すると想定されていた領域とは違う「想定外の領域」を参照する/書き換えることもできてしまうのである。ここでは、const修飾子を用いた例でそれを示したが、同じ事はより大規模に拡張することができる。例えば、起動したプログラムが、ファイアウォールやセキュリティソフトの確保しているメモリ領域を書き換えて、それらのソフトの動作を変えてしまうこともある。通常はOS等の安全機構が働くのであるが、OSを作ったのも人間であり、穴がないとは言えない。これらの穴を突き、意図的にメモリの改変を起こしたものが\textbf{マルウェア}\index{まるうぇあ@マルウェア}(Malware)\footnote{コンピュータウィルス、トロイの木馬、スパイウェアなどの「悪意のこもった」ソフトウェアのこと。}の一種あるいは一機能となるのである。

以上のように、アドレスというのは取り扱いを誤ると大惨事をも引き起こしかねない、ある意味「プログラミングにおける原子力」のようなものである\footnote{この危険性=取り扱いの難しさ故に、言語によってはこれに代わるより安全な機能を導入し、アドレスを直接的に扱う機構を隠蔽している場合もある。だが、アドレスはコンピュータに非常に近いところに位置するものであるため、これらの「より安全な機能」も内部的にはアドレスを利用しているのである。しかし、少なくともC言語ではアドレス(及びポインタ)に代わる機構はなく、むしろこれらが直接扱えることが利点でもあるため、その運用には十分に注意を払わなければならない。}。だが、その一方で、適切に活用した時の恩恵は計り知れない。アドレスを取り扱うときには、そのアドレスの示している部分に一体何があるのか、\textbf{示しているものを明確にして}取り扱わなければならない。さもなくば、誤ったプログラムによりシステムが不安定になることも、最悪システムを再インストールしなければならないような事態に遭遇することも考えられる。
\\ \\　
C言語の特徴として、コンピュータに近いところまで扱うことができる、比較的低水準言語に近い言語であるという事を述べた。それ故、C言語は「何でもできる」のである。何でもできてしまうという事は、危険なソフトウェアも作れてしまうという事である。我々プログラマは、その倫理に則ってマルウェアを開発しないのは勿論、プログラミングの際に十分注意を払って、特にフェータルなバグは作りこまないように気をつけなければならない。「ポインタが難しい」と言われる理由は、まさにここの「適切に扱わなければ…」というところにあるのではないだろうか。

\subsection{アドレスのための変数=ポインタ}
先に述べたとおり、scanf関数では、アドレスを引数として渡している。引数として渡すためには、それを保持するために変数が必要になる。この、アドレスを格納するための変数こそ\textbf{ポインタ}\index{ぽいんた@ポインタ}(pointer)である。ここではまず、ポインタについて理論的な部分を述べていき、その後実際に利用してみることにする。

\minisec{ポインタは何故派生型なのか}
ポインタはアドレスを格納するための変数であると述べたが、これは一見、基本型として用意するべきものには見えないだろうか。intやfloatといった基本型からどのように派生すればポインタになるのか、「アドレスを格納するための変数」という事から直ちに思いつくだろうか。
\\ \\　
アドレスはメモリについている番号であるから、メモリを抜きにしては語れない。メモリについて、もう一度考えてみよう。我々は、変数をどのようにして格納しているのであっただろうか。

答えはもちろん、ビット列として保存している、である。ビット列を定まった規則=型に従って読むことでその変数の値を得ることができた。共用体はその読み替えを行うための機能であり、キャストは値をそのまま保持しつつ、違う規則でのビット列に変換する機能だった。可変引数リストから値を読み出す\verb|va_arg|マクロは、第2引数に型を取ることで「何型かわからない」可変引数にビット列解釈の規則を与えていた。このように、メモリに保持されているビット列に意味を与えるために、データ型は必要不可欠である。
\\ \\　
では、仮に、ポインタがアドレスだけを保持する型であったならどうだろうか。そのアドレスの指し示す先にあるオブジェクトを正しく把握することができるだろうか。scanf関数で書式指定子により型を与えなければならない事や、アドレスだけではビット列解釈の規則がわからないことを考えればわかるとおり、答えはNoである。ちょうど、所在地がわかっても建物を見なければその形がわからないのと同じように、アドレスだけではオブジェクトを正しく把握することはできないのである。アドレスによりオブジェクトの位置を知り、型によりオブジェクトの輪郭を知る。これによって初めてアドレスを用いてのオブジェクト操作が可能なのである。

であれば、ポインタに「指し示した先のビット列をどう読むべきか」という情報、つまり「指し示したオブジェクトの型」を与えてやれば良い。つまり、"double型のオブジェクトが置かれているアドレスを格納するための変数"としてdouble型から派生したポインタや、"ある構造体変数が置かれているアドレスを格納するための変数"として構造体を指し示すためのポインタなどが考えられる。ポインタが派生型である理由は、アドレスと共に、指し示している先のオブジェクトをどのような規則に従って読むべきかを示さなければならないからである。
\\ \\　
なお、単純にアドレスだけを格納し、その規則はキャストなどによって与えたいという場合もある。このような場合には\textbf{汎用ポインタ}\index{はんようぽいんた@汎用ポインタ}(generic pointer)と呼ばれる、「アドレスを格納するためだけの型」を用いる。汎用ポインタは文法規則で見ると\verb|void|型へのポインタとして宣言することになる(宣言については後述)。だが、\verb|void|型というのは「持たないこと」を示す型であった。この「持たないこと」から、「特定の型に縛られない」と連想し、\verb|void|型へのポインタ=汎用ポインタ、となったものと考えられる\footnote{考えられる、と記したのは正式にどのような議論があったのかは不明であるため。}。

\minisec{ポインタのサイズ}
ポインタはアドレスを保持するための変数であるので、アドレスを保持するための大きさがあれば良く、その大きさは基本型によらない。アドレスは環境毎に決まっており、その上にオブジェクトを配置するのだから、どの基本型からの派生であるかによらず大きさが一定であるのは、想像に難くないだろう。

このポインタの大きさは、近年意識されることの多い、OSやCPUの"32bit","64bit"という言い方によってわかる。実は、この"32bit","64bit"は、どちらもポインタの大きさを示しているのである。従って、32bit環境でのポインタは4バイトだし、64bit環境でのポインタは8バイトである。
\\ \\　
ポインタが32bitであるという事は、アドレスが32bitで表現されているという事である。32bitといえば、以前2038年問題を紹介したが、ポインタでもこのようなオーバーフローが起こりうるのではないだろうか。つまり、アドレスが32bitで足りなくなる場合というのが考えられるのではないか。

この問題はすでに現実のものとなっている。32bitで表されるアドレスというのは、$2^{32}$個である。1バイトに1つのアドレスを割り当てるのだから、32bitで扱うことができるのは高々4GBという事になる。一方、パソコンなどを買いに行くと「32bitのOSでは4GBまでしかメモリを認識しない」等と書かれていることが多い。これこそがアドレスの不足である。ポインタが32bitでは、4GB分のアドレスしか用意できないため、認識できる/使えるメモリの量は4GB程度\footnote{メモリ以外のハードウェア等にアドレスを割り当てないといけない場合があるため、実際は4GiBまで使えることは少なく、3GBぐらいまでしか認識しない場合が多い。}に制限されてしまうのである。

一方で、64bitの場合、他の要因で制限を設けなければ$2^{64}$B=16EiB\footnote{エクサビバイト。Ei接頭辞は$2^{60}$のことである。k,M,G,Tぐらいは聞いたことがあるだろう。TのあとはP(ペタ),E(エクサ),Z(ゼタ),Y(ヨタ)と続く。後ろにiをつければ、Pi(ペビ),Ei(エクサビ),Zi(ゼビ),Yi(ヨビ)となり、$2^{10}$単位となる。}ものメモリを扱うことができる。そのため、32bitでのメモリ枯渇問題は64bitが主流になるにつれて解消されるだろう。

\minisec{ポインタの宣言}
そろそろポインタについて理解を深めたところと思うので、実際にポインタを使ってみよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{再帰処理のメモリ確保状態}
再帰関数中のローカル変数のアドレスを出力し、再帰処理がスタック領域を確保している事を確かめる。
\minisec{解説}
再帰処理がスタック領域中に確保されているならば、再帰呼び出し毎に確保される再帰関数中のローカル変数のアドレスは順次小さくなっていくはずである。これを出力して確認する。

なお、入力値(整数)の深さの再帰を行うため、あまり大きい値を入れるとスタックオーバーフローしてしまう。逆にこれを利用して、スタックオーバーフロー時のメモリはどれぐらいになっているか確認するのも良い(その際は、printfを条件付き実行にして間引くと良い。)

\begin{lstlisting}[caption=再帰のメモリ確保,label=program10_3]
#include<stdio.h>

int n;

void rec(int k){
  int *p;
  p=&k;
  printf("%d-rec:%p\n",*p,p);
  if(k<n) rec(*p+1);
}

int main(void){
  scanf("%d",&n);
  rec(0);
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
リスト\ref{program10_3}でポインタを利用しているのは、$l$.6である。
\begin{itembox}[l]{ポインタの宣言}
ポインタを宣言する際には、
\begin{code}
指し示す先の型 * 識別子
\end{code}
と、\verb|*|をつけて宣言する。なお、汎用ポインタを宣言する際には、「指し示す先の型」をvoidにすれば良い。
\end{itembox}

宣言を行う際、\verb|*|の付け方は幾つかある。識別子につけて
\begin{code}
int *p;
\end{code}
という形式でも良いし
\begin{code}
int* p;
\end{code}
と型名の後ろに記しても良い。また、
\begin{code}
int * p;
\end{code}
のように、スペースを用いて独立させても問題ない。但し、どの場合でも、ポインタを宣言する場合の\verb|*|は\textbf{直後の識別子名のみにかかる}点に注意しなければならない。例えば、
\begin{code}
int* p1,p2;
\end{code}
と書いた場合、p2は\verb|int|型になる。もしもp2も\verb|int *|型にしたい場合には
\begin{code}
int* p1,*p2;
\end{code}
のように、p2の前にも\verb|*|を付さなければならない\footnote{この規則のため、マクロを用いて型の別名を定義した場合とtypedefを用いて型の別名を定義した場合の結果が異なってくる点に注意されたい。仮に、
\begin{code}
intp p1,p2;
\end{code}
という宣言があった場合、このintpがマクロを用いて
\begin{code}
#define intp int*
\end{code}
と定義されていたら、p1は\verb|int *|型、p2は\verb|int|型である。一方、typedefにより、
\begin{code}
typedef int * intp
\end{code}
と宣言されていた場合、p1,p2とも\verb|int *|型になる。}。

\minisec{間接演算子}
ポインタにアドレスを代入する場合、リスト\ref{program10_3}の$l$.7のようにポインタをそのまま記せばよく、右辺がアドレスになるだけである。一方、先までの説明からわかるとおり、ポインタはその指し示した先の実体を操作できるのであるから、「ポインタの示した先のオブジェクトを参照する」機能が必要になる。これを行うのが\textbf{間接演算子}\index{かんせつえんざんし@間接演算子}(indirect operator)である。
\begin{itembox}[l]{ポインタの示すオブジェクトの参照}
あるポインタが示しているオブジェクトを参照したい場合には
\begin{code}
*ポインタ名
\end{code}
のように、ポインタ識別子の前に\verb|*|を付す。
\end{itembox}

これを用いてオブジェクトを直接参照したら代入、演算など元の変数を扱うのと同じ要領で扱うことができる(リスト\ref{program10_3}の$l$.8や$l$.9など)。但し、これはポインタに指し示す先の実体があるからできるのであって、\textbf{参照先実体が不明であるポインタにこれを用いて参照を行なってはならない}。先にも書いたとおり、意図しない箇所の書き換えは重大な問題を引き起こす。それゆえ、ポインタを利用する場合には\textbf{格納アドレスが指し示す場所を明確にして}用いなければならない。
\\ \\　
間接演算子の\verb|*|は\textbf{宣言に用いた}\verb|*|\textbf{とは別物}の単項演算子である。C言語で用いられる\verb|*|には\verb|&|演算子同様に何種類もの意味があるので、構文などから解釈しなければならないし、別の構文にならないように注意しなければならない。以下に、C言語中で用いられる\verb|*|の意味をまとめておく。
\begin{itembox}[l]{C言語中でのアスタリスクの意味}
\begin{itemize}
\item ポインタ型の単項オペランドを伴い、間接演算子として働く。
\item 型名の後ろに付し、ポインタ型への派生を示す。
\item 二項オペランドを伴い、掛け算を行う。
\item /の前後に付され、コメントの開始/終了を示す。
\end{itemize}
\end{itembox}
特に、ポインタ参照先を除数にして割り算を行う場合に注意しよう。
\begin{code}
a/*b;
\end{code}
などと書いた場合、これは「\verb|a|を\verb|b|の参照先の値で割る」を意図しているのだろうが、コンパイラは\verb|/*|以降をコメントとみなしてしまい、コンパイルできなくなってしまう。この問題を回避するためには\verb|a/(*b)|と括弧を付したり、\verb|a/ *b|とスペースを入れたりして、\verb|/|と\verb|*|を独立させれば良い。
\\ \\　
ポインタ・アドレス関連の演算を表\ref{chap10_tab1}にまとめておこう。
\begin{table}[htb]
\centering
\caption{アドレス・実体の関係}\label{chap10_tab1}
\begin{tabular}{|c||c|c|}\hline
変数の種類&実体&アドレス\\ \hline
&&\\[-15.5pt] \hline
基本型・構造体・共用体&識別子を書く&\&演算子を付す\\ \hline
関数型&識別子後に\verb|(引数一覧)|を書く&識別子を書く\\ \hline
配列型&識別子後に\verb|[要素番号]|を書く&識別子を書く\\ \hline
ポインタの中身&\verb|*|演算子を付す&識別子を書く\\ \hline
\end{tabular}
\end{table}

注意しなければならないのは、表\ref{chap10_tab1}のうち、ポインタの欄のアドレスはあくまでも「ポインタに格納されているアドレス」であり、ポインタそのもののアドレスではない。ポインタも変数であるから、もちろんアドレスを持つ。ポインタそのもののアドレスをとりたい場合には、通常の変数同様\&演算子を付せば良い。すなわち、ポインタ\verb|p|について
\begin{code}
p+i
\end{code}
などとした場合、この\verb|p|は\verb|p|に格納しているアドレスの意味になるが、
\begin{code}
&p+i
\end{code}
などとした場合、\verb|&p|は\verb|p|の置かれているアドレスの意味になる。
\\ \\　
ここまでの議論からわかるとおり、\&演算子と\verb|*|演算子は互いに打ち消しあう。すなわち、
\begin{code}
&*p
\end{code}
などと書いた場合、これは単に\verb|p|と書くのと同じという事である。

\section{ポインタ演算}
ポインタ(アドレス)にも演算の機能がある。
\begin{boxnote}
\begin{multicols}{2}
\minisec{文字列の小文字出力}
入力された文字列の英字をすべて小文字に直して出力するプログラムを作成する。
\minisec{解説}
文字列の終端にあるNULL文字をターミネータとして、入力された文字列を全て小文字に変更して出力する。入力にはfgets関数を用い、空白などがあっても対応できるようにしている。
\begin{lstlisting}[caption=文字列の小文字出力,label=program10_4]
#include<stdio.h>
#include<ctype.h>

int main(void){
  char str[256];
  char *p;
  fgets(str,sizeof(str),stdin);
  p=str;
  do{
    putchar(tolower(*p));
  }while(*(++p)!='\0');
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
ポインタに対して許される演算は、整数の加減算と、ポインタ同士の減算のみである。

\minisec{ポインタと整数の加減算}
今回、リスト\ref{program10_4}の$l$.11で用いているのが、ポインタと整数の加減算(インクリメント・デクリメントも同様)である。
\begin{itembox}[l]{ポインタと整数の加減算}
ポインタ\verb|p|と整数\verb|i|の加算をする場合、
\begin{code}
p+i
\end{code}
はポインタ\verb|p|の示すアドレスから、\verb|sizeof(*p)|$\times$\verb|i|だけ進んだ場所を示す。減算の場合も同様。
\end{itembox}

ここで用いている\verb|p|のインクリメントは、\verb|p|の指し示している位置から一つ後ろにポインタを送る、という意味になる。最初は\verb|str[0]|を指している\verb|p|であるが、一度インクリメントされる毎に、ここでは\verb|char *|型であるので、\verb|char|型変数1個分ずつ後ろに送られ、\verb|str[1]|,\verb|str[2]|,$\cdots$と順に指し示す位置を変えていっている。これにより、\verb|p|の参照先を変えることで文字列を全て見ているのである。

\minisec{ポインタ同士の減算}
一方で、同じ型のポインタ同士の引き算も行うことができる。
\begin{itembox}[l]{ポインタ同士の減算}
ポインタ同士の減算は、その2つのポインタの指し示しているアドレスの差異が、そのポインタの派生前の型幾つ分であるかを示す。
\end{itembox}

\verb|p1,p2|を共にint*型とする。\verb|p2-p1|が3ならば、\verb|p1|より\verb|p2|がint型変数3個分だけ後ろを指している(\verb|*p1|が配列の第0要素、\verb|*p2|が配列の第3要素のような状況)ことになる。先のポインタと整数の演算の関係式を整数について解いたものと思えばよい。

\minisec{ポインタを用いた配列アクセス}
ここまでの方法を用いると、ポインタを用いて配列にアクセスすることができるようになる。一般に、配列とポインタの参照の間には次の関係が成り立つ。
\begin{itembox}[l]{ポインタを用いた配列の参照}
配列のアドレス(ないし、それを指し示すポインタ)\verb|array|及び\verb|int|型変数\verb|i|に対して
\begin{code}
*(array+i)
\end{code}
という参照と
\begin{code}
array[i]
\end{code}
という参照は全く同じものである。
\end{itembox}

この原理は、配列が連続的に並んでいるという事、配列のアドレスは配列の先頭要素のアドレスであるという事が理解できていれば容易にわかるであろう。間接演算子を用いた表現は\verb|array|から\verb|i|個進んだところの中身は？という意味であるので、もちろん\verb|array[i]|であるはずである。

実際コンパイラは、\verb|array[i]|という表現が出てきた場合、これを\verb|*(array+i)|と同じものだと解釈している。また、要素数を指定しない配列(\textbf{不完全配列}\index{ふかんぜんはいれつ@不完全配列}(incomplete array))を引数にとる関数を使った場合、呼び出し側は\verb|array[]|を\verb|*array|と等価とみなす。配列がアドレス渡しなのは、この等価とみなすステップがあるためである。
\\ \\　
ここで、ちょっとしたマジックを紹介しておこう。配列\verb|array|と整数型変数\verb|i|について
\begin{code}
i[array]
\end{code}
と書いてもコンパイラを通り、意図した動作になるのである。なにか配列を使っているプログラムについて、このようにひっくり返してコンパイル・実行してみよう(尚、\verb|[]|内が1変数でない場合は、\verb|[]|内の式に()をつけてひっくり返すこと。例えば、\verb|array[a+b]|は\verb|(a+b)[array]|となる。)。

これがうまくいく理由こそ、先の置き換えにある。\verb|i[array]|は内部的に\verb|*(i+array)|と展開される。この演算は整数とポインタの加算であるので、コンパイルエラーとはならない。ここで、加法演算には交換則が成立するので、2項を交換して\verb|*(array+i)|とすれば、\verb|array[i]|と同じものになり、なるほどたしかにひっくり返しても問題ないという事がわかるだろう。とはいえ、この方法はわかりにくいので、普段使うことは推奨されない。あくまでもマジックとしての紹介である。

\minisec{間接演算子の演算順序について}
ここまで、何の気なく括弧をつけて間接演算子を扱ってきたが、この演算順序はどうなっているのであろうか。ここでは、この問題について説明していく。なお、必要に応じて、宣言の差異についても説明するが、利用方法については次講に回す。

間接演算子は単項演算子である。単項演算子は、他の2項演算子などよりも先に評価される。そのため、\verb|+|などを用いる場合には、括弧を付していたのである。

一方で、配列の要素や関数の引数、構造体のメンバは単項演算子よりも先に評価される。これは、各種派生型を自然に扱えるようにするためなのだが、これが間接演算子と混ざると少し複雑になる。
\\ \\　
まず、配列の場合であるが、\verb|*a[5]|はどういう意味であろうか。これは、\verb|a[5]|に格納されているアドレスの参照先、という意味になる。すなわち、\verb|*(a[5])|と解釈される。一方で、\verb|(*a)[5]|という書き方もあり、この場合は\verb|a|に格納されているアドレスの参照先のアドレスから更に5個分進めた場所の値、という意味になる。これは、宣言時においても同様で、\verb|int *a[5]|は、\verb|int *|型の5要素の配列であるが、\verb|int (*a)[5]|は「5要素のint型配列のアドレスを格納するためのポインタ」という意味になる。
\\ \\　
次に、関数の場合について説明をしておこう。関数の場合、\verb|(*f)(...)|という記述は\verb|f(...)|という記述と同じとされるため、さほど困ることはない。だが、前者にも意味はあるので、利用法は次講にまわすが、関数へのポインタがあることだけ紹介しておく。実は、宣言時に\verb|型 (*f)(引数の型リスト)|とすることで、型・引数が整合する関数のアドレスを格納するためのポインタを宣言できる。したがって、\verb|(*f)(...)|という記述は、関数ポインタによって示される、参照先の関数の呼び出しを行うという意味となり、間接参照であることを明確にするための記法である。なお、\verb|*f(...)|は、関数\verb|f|の返却値のアドレスの参照先実体である。
\\ \\　
構造体や共用体のメンバについても考える。\verb|*st.mem|などの場合、これは\verb|*(st.mem)|と解釈される。つまり、「メンバのポインタ」の参照先の実体を示す。一方、\verb|(*st).mem|と書けば、構造体(共用体)へのポインタ\verb|st|の参照先にある実体のメンバ\verb|mem|の意味になる。だが、この記法は、よく使われるため、より簡単な表記が用意されている。
\begin{itembox}[l]{間接参照演算子}
構造体(共用体)へのポインタ\verb|st|に対し、
\begin{code}
(*st).mem
\end{code}
という記述は、\textbf{間接参照演算子}\index{かんせつさんしょうえんざんし@間接参照演算子}(indirection reference operator)または\textbf{アロー演算子}\index{あろーえんざんし@アロー演算子}(arrow operator)と呼ばれる\verb|->|を用いて
\begin{code}
st->mem
\end{code}
と書き換えられる。
\end{itembox}
この関係は公式として丸暗記してしまってよいだろう。
\\ \\　
このように、間接演算子の演算順序は、とりわけ派生型と組み合わせるときに厄介なことになりがちである。一般の単項演算子と同じ順序で、他の派生型の書き方に比べて遅いという事、適切に括弧をつけること、そして何より、\textbf{今用いているポインタが何を指し示しているのか明確にする}ことにより、間接演算子を適切に扱うことができるのである。

なお、アドレス演算子も同様の演算順序を持つが、こちらは\verb|(&st).mem|などの書き方が許されないため、ここで特筆する必要はないだろう。
\\ \\　
最後に、違いをまとめておく。
\begin{itembox}[l]{括弧と間接演算子・宣言}
\begin{itemize}
\item 関数について
\begin{itemize}
\item \verb|*f(...)|は、関数の返却値のアドレスの参照先実体である。もちろん、\verb|int *f(...)|は\verb|int *|型返却値の関数である。
\item \verb|int (*f)(...)|等で、関数へのポインタを宣言でき、\verb|f(...)|で間接参照可能であるが、明確にする際には\verb|(*f)(...)|と記す。\\
\end{itemize}
\item 配列について
\begin{itemize}
\item 宣言時に\verb|int *a[5]|とした場合は\verb|int *|型の5要素の配列になる。この時は、\verb|*a[3]|で、\verb|a[3]|に格納されているアドレスの参照先実体を示す。
\item \verb|int (*a)[5]|は、5要素のint型配列へのポインタである。この時は\verb|(*a)[3]|などとすることで、\verb|a|の参照先の\verb|[3]|要素を示す。\\
\end{itemize}
\item 構造体・共用体について
\begin{itemize}
\item \verb|*st.mem|は\verb|*(st.mem)|と同じで、メンバの参照先実体を示す。
\item \verb|(*st).mem|は\verb|st->mem|と同じで、ポインタの参照先実体の構造体(共用体)のメンバを示す。
\end{itemize}
\end{itemize}
\end{itembox}

\section{ポインタを用いる関数}
ここでは、ポインタを利用する関数について説明する。
\subsection{ポインタを用いる自作関数}
自作関数の引数や返却値にポインタを用いる場合、型が違う事を除けば通常の基本型を用いた関数と同じ手順で関数を作れば良い。
\begin{boxnote}
\begin{multicols}{2}
\minisec{二つの変数の値を交換する関数}
二つのint型の値を交換する関数を作成する。
\minisec{解説}
元の変数に影響を与えるため、ポインタを引数に使う必要があることはわかることだろう。ポインタ引数によってアドレスを取得し、その中身を交換するという処理を記述する。この時、作成したい関数は交換処理のみで返却値が不要なので、void型としている。
\begin{lstlisting}[caption=交換を行う関数,label=program10_5]
#include<stdio.h>

void swap(int *a,int *b);

int main(void){
  int a=3,b=5;
  swap(&a,&b);
  printf("a=%d,b=%d\n",a,b);
  return 0;
}

void swap(int *a,int *b){
  int tmp=*a;
  *a=*b;
  *b=tmp;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

\minisec{ポインタ引数関数}
ポインタを引数に取る関数はリスト\ref{program10_5}の$l$.3ないし$l$.12のように、引数をポインタ型にすれば良い。関数の章で学んだ通り、仮引数は通常の変数の宣言と同様で、初期値が実引数の値になるものであるため、このように通常の宣言と同様に書けば良いのである。

ポインタ引数関数を呼び出す際には、scanf関数同様に、\&を付けるなどして、\textbf{アドレスを引数として渡してやる}必要がある。本来であれば、このアドレスが実引数であるので、冒頭に記した"実引数に影響を与える"というのは些か不正確な表現である。正しく言えば、"実引数に影響を与えることはできないため、アドレスを渡して間接的に変数そのものに影響を与えるようにした"となる。

\minisec{ポインタを返却値に取る関数}
ポインタを返却値に取る関数も、基本型などを返却値に取る型と同様に
\begin{code}
int * func(...)
\end{code}
のように、ポインタ型を用いて宣言すれば良い。後は普段通りに関数を書けば良い。
\\ \\　
ポインタを返却値にする場合、その示した先の変数の寿命に気をつけなければならない。例えば、関数内の局所変数のアドレスを返した場合を考えてみよう。この場合、関数が終了するとその局所変数はメモリから取り除かれる。だが、返却値であるポインタはその「取り除かれた場所」を示したままになっている。そこを参照しようとすると、当然セグメンテーション違反になってしまう。従って、ポインタを返却値に取る場合は、寿命が尽きた部分のメモリを参照しないようにしなければならない。

\subsection{ポインタを用いる標準ライブラリ関数}
ポインタを取り扱う標準ライブラリ関数は数多くある。実際にどのような関数があるかは付録に譲り、ここでは文字列に関する例を出してポインタの利用方法について説明する。

文字列を扱う関数は、先に書いたとおり"不完全配列はポインタとして扱われる"規則のため、ポインタ引数のうまい活用で様々に扱うことができる。例えばstrncpy関数を用いて、文字列\verb|str1|の\verb|m1|文字目から\verb|m2|文字目までを\verb|str2|にコピーしたい場合
\begin{code}
strncpy(str2,str1+m1,m2-m1)
\end{code}
を実行すれば良い。

\minisec{NULLポインタ}
ポインタを扱う関数の説明に先立ち、"条件に合う部分がない"などの際によく使われる\textbf{NULLポインタ}\index{NULLぽいんた@NULLポインタ}(NULL pointer)について紹介しておく。

NULLポインタは値が0のポインタとして定義されることが多い、"何をも指し示さない特殊なポインタ"で、ターミネータやエラー処理に使われる。NULLポインタは幾つかのヘッダにおいてマクロ\verb|NULL|で定義されており、これと比較することでNULLポインタでないかどうかを判別することができる。
\\ \\　
NULLポインタとNULL文字は名前こそ似ているものの、全く別物である。前者はポインタ型であり、プログラム中では\verb|NULL|と書く。一方、NULL文字は文字コード0の文字型定数で、プログラム中では\verb|\0|と記される。もしも誤って、文字列\verb|str|に対して
\begin{code}
while(str++!=NULL)
\end{code}
などとした場合、これは無限ループになってしまう(それ以前に、コンパイラで警告を出してくれたりエラーになったりすることのほうが多いが)。とりわけ初心者に多い間違いであるので、NULL文字とNULLポインタはきっちりと区別するように心がけたほうが良いだろう。

\minisec{文字列関数について}
文字列関連の関数には、ポインタを用いる関数が多い。これは、文字列を配列として与えるよりも、途中の部分を示すことが可能なポインタで渡したほうが楽だからである。それ故、文字列を扱う場合には、ポインタを用いた配列アクセスの手法が役に立つ場合が多い。実際、ポインタと、ターミネータがNULL文字であることを利用すれば、文字列関数の大半は実装できるのである\footnote{試しに、いくつかの関数を実装してみると練習になる。また、自分自身で文字列関連の関数を作る際にも、ポインタとNULL文字の判定だけで作ったほうが、メモリが少なかったりアクセスが速くなったり汎用性が高くなったりするので、おすすめである(主に汎用性のためであるが)。}。以下の関数はこのことを踏まえ、「文字列をポインタとして使う」ことを前提に見てほしい。

\minisec{文字列の分割}
以下、ポインタを用いた関数の例を2例紹介する。第1の例はstrtok関数を用いた文字列の分割である。
\begin{boxnote}
\begin{multicols}{2}
\minisec{多項式の分割}
展開・整理された、括弧がない多項式を、+や-を目印に区切って項別に出力するプログラムを作成する(但し、符号は消える)。入力の例としては
\begin{code}
x^3+ax^2-3x+1
\end{code}
などで、出力は以下のようになる。
\begin{code}
x^3
ax^2
3x
1
\end{code}
\begin{lstlisting}[caption=多項式の分割,label=program10_6]
#include<stdio.h>
#include<string.h>

int main(void){
  char src[256], *p;
  fgets(str,sizeof(str)-1,stdin);

  p=strtok(str, "+-");
  while(p!=NULL){
    puts(p);
    p=strtok(NULL,"+-");
  }
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

ここで用いたstrtok関数は第1引数に指定した文字列から、第2引数に指定した文字集合に含まれる文字を探し、見つかったらそれをNULL文字に置き換える、という動作を行う。そして、置き換えた動作を行った場合または文字列終端に来た場合、呼び出し時の文字列への先頭ポインタを返す。

このstrtok関数は内部状態を持ち、2度目以降の呼び出しの際の第1引数にNULLポインタを指定することによって、先に区切った続きの部分を探索してくれる。これを繰り返していくと、最終的に探索開始位置から文字列終端までに区切り文字が見つからなくなる。この状態で再度strtokを呼び出すと、今度はNULLポインタを返してくれるので、それによって終了を判別すれば良い。以下にまとめよう。
\begin{itembox}[l]{strtokの動作}
\begin{enumerate}
 \item 初回の呼び出しでは、リスト\ref{program10_6}の$l.8$のように元の文字列と区切り文字を引数に指定する。この時、文字列の先頭から区切り文字を探す。
 \item 2回目以降の呼び出しでは、リスト\ref{program10_6}の$l.11$のように第1引数に NULL を指定する。この時、前回NULL文字を書いたところの続きから区切り文字を探す。
 \item 区切り文字が見つかったらそれをNULL文字に置き換え、呼び出しに使われた文字列のポインタを返す。
 \item 区切り文字が見つけられなかった場合は、探索開始位置を返却するだけである。この次にstrtok関数を呼び出すと、NULL が返却される。
\end{enumerate}
\end{itembox}

なお、文字列\verb|"A+BC-D"|を\verb|+-|の記号で分割する場合に、文字列がどのように書き換えられるかを図\ref{strtok_fig}に示しておく。

\begin{figure}[H]
{\small
\begin{center}
 \begin{tabular}{cccccccc} \cline{2-8}
  文字列の内容 & \multicolumn{1}{|c}{\tt 'A'} & {\tt '+'} & {\tt 'B'} & {\tt 'C'} & {\tt '-'} & {\tt 'D'} & \multicolumn{1}{c|}{\tt '$\backslash$0'} \\ \cline{2-8}
 & & & & ↓ & & & \\ \cline{2-8}
  文字列の内容 & \multicolumn{1}{|c}{\tt 'A'} & {\tt '$\backslash$0'} & {\tt 'B'} & {\tt 'C'} & {\tt '-'} & {\tt 'D'} & \multicolumn{1}{c|}{\tt '$\backslash$0'} \\ \cline{2-8}
  返却値 & ☆ & & & & & & \\
 & & & & ↓ & & & \\ \cline{2-8}
  文字列の内容 & \multicolumn{1}{|c}{\tt 'A'} & {\tt '$\backslash$0'} & {\tt 'B'} & {\tt 'C'} & {\tt '$\backslash$0'} & {\tt 'D'} & \multicolumn{1}{c|}{\tt '$\backslash$0'} \\ \cline{2-8}
  返却値 & & & ☆ & & & & \\
 & & & & ↓ & & & \\ \cline{2-8}
  文字列の内容 & \multicolumn{1}{|c}{\tt 'A'} & {\tt '$\backslash$0'} & {\tt 'B'} & {\tt 'C'} & {\tt '$\backslash$0'} & {\tt 'D'} & \multicolumn{1}{c|}{\tt '$\backslash$0'} \\ \cline{2-8}
  返却値 & & & & & & ☆ & \\
 & & & & ↓ & & & \\ \cline{2-8}
  文字列の内容 & \multicolumn{1}{|c}{\tt 'A'} & {\tt '$\backslash$0'} & {\tt 'B'} & {\tt 'C'} & {\tt '$\backslash$0'} & {\tt 'D'} & \multicolumn{1}{c|}{\tt '$\backslash$0'} \\ \cline{2-8}
  返却値 & \multicolumn{7}{c}{NULL} \\
 \end{tabular}
\end{center}
}
\caption{strtok関数による文字列の分割}
\label{strtok_fig}
\end{figure}

\minisec{整数/小数の判別}
もう一例、今度は入力の工夫を見てみよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{整数/小数を判別して型を選ぶ}
入力される数が整数か小数かを判別して代入し、出力する。
\minisec{解説}
整数型変数と浮動小数点数型変数をいちいち用意するのはメモリの無駄遣いであるので、ここでは共用体を用いている。浮動小数点数を使うべきかどうかは、入力に「小数を表す\verb|.|(小数点)」があるかないかで判別できるので、これを文字列内から検索して、見つからなければ整数、見つかれば浮動小数点数としている。

ポインタ自体は用意していないが、アドレス渡しの関数が多い点に注目されたい。

\begin{lstlisting}[caption=整数/小数の判別,label=program10_7]
#include<stdio.h>
#include<stdlib.h>
#include<string.h>

int main(void){
  char input[16];
  union{
    int i;
    float f;
  }num;
  scanf("%15s%*c",input);
  if(strchr(input,'.')==NULL){
    num.i=strtol(input,NULL);
    printf("%d\n",num.i);
  }else{
    num.f=strtof(input,NULL);
    printf("%f\n",num.f);
  }
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

ここで用いた"ポインタを用いる関数"はstrchr関数とstrtol/strtof関数である。以下、これについて説明する。
\\ \\　
strchr関数は第1引数の文字列の先頭から順に第2引数の文字を探索し、それが見つかればその場所のアドレスを、見つからなければNULLポインタを返す関数である。複数ある場合は最初に見つかったものを返す。逆に、後側から順に文字を探すstrrchr関数や、文字列から文字列を探す(第1引数の文字列に第2引数の文字列が含まれているかどうかを調べる)strstr関数もあり、これらは全て最初に見つかった場所のアドレスを返す関数である(見つからなければNULLポインタ)。従って、リスト\ref{program10_7}の$l$.12は、文字列\verb|input|の中に\verb|.|がなければ、という意味のif文になる。なお、strchrで見つかった文字がその文字列の文字の何文字目にあるかを知りたい場合は
\begin{code}
char *p;
if((p=strchr(str,c))!=NULL) i=p-str;
\end{code}
というように、ポインタの引き算を利用すれば良い(なお、\verb|str|は文字列、\verb|c|は文字、\verb|i|はint型変数である。) 
\\ \\　
strtolなどのstrto*系関数は、*で示される型に文字列を変換する関数で、ato*関数の上位互換である。ここで紹介したstrtol関数はatoi関数の、strtof関数はatof関数のバージョンアップ版と言えるものである。この関数は、ato*関数に第2引数を追加したもので、第2引数には文字型へのポインタのアドレスを記す。すなわち
\begin{code}
char *p;
strtol(str,&p);
\end{code}
のような形式である。これにより、\verb|p|に、該当する数字を変換したその直後のアドレスが代入される。すなわち、strto*関数は
\begin{itemize}
\item 返却値として第1引数の文字列を変換した値を返し、(ここまでato*と同じ)
\item 第2引数のポインタにその変換した直後のポインタを返す。
\end{itemize}
という、atoiを多機能化したものなのである。ここで使ったように第2引数をNULLポインタにすればstrto*関数はato*関数とほぼ同じ働きをする。但し、ato*関数と違い、指数表現にも対応しているなどの点が異なる。通常はstrto*関数のほうが高機能であるので、こちらにお世話になる方が多いだろう。

\newpage

\begin{shadebox}
\section*{本講の要点}
本講ではアドレス・ポインタについて学び、その基本的な使い方を概観した。
\subsection*{アドレスとポインタ}
\begin{itemize}
\item \textbf{アドレスやポインタを扱う際には、その指示アドレスを明確にして利用しなければならない。}
\item アドレスを取得する場合、その識別子に\&を付す。但し、関数や配列の場合はその識別子のみを記す。
\item ポインタはアドレスを格納するための変数であり、その位置にある実体を操作するのに用いる。
\item ポインタは指示先実体の型に対する派生であり、これによって間接演算子で正しい型を当てはめて参照できるようにしている。
\item アドレスを用いて別の関数に渡した変数は、同一実体でも違うスコープの変数として扱われる。
\item ポインタのサイズはOS/CPUのビット数で、これにより認識メモリ量が定まる。
\item ポインタを宣言する際は、複数宣言する際も識別子毎に\verb|*|を付す。
\end{itemize}

\subsection*{ポインタの利用}
\begin{itemize}
\item ポインタ(アドレス)に整数$n$を加減した場合、その指示位置から派生元の型$n$個分前後した位置を示す。
\item ポインタ(アドレス)同士の減算を行った場合、前側の項の指示位置が後側の項の指示位置から、派生元の型幾つ分前後の位置にあるかを整数で返す。
\item \verb|*(a+i)|と\verb|a[i]|は同じものと解釈される。
\item 間接参照演算子は演算順序に注意しなければならない。この問題を解決する一つの手段が\verb|->|演算子である。
\item ポインタを引数に取る関数を作ることで、呼び出し元関数のオブジェクトを操作できる。
\item 返却値がポインタ型である関数を作る際には、その指示先オブジェクトの寿命に注意しなければならない。
\item NULLポインタは「何をも指し示さないポインタ」で、エラー処理などに用いられる。
\end{itemize}
\end{shadebox}

前講では関数の原理的な部分についてじっくりと学んだ。今度は、活用する方法として、関数の利用の幅を広げていこう。まず、標準ライブラリの利用法として、よく使う関数をいくらか紹介する。次いで、自作関数の幅を広げる上でよく用いられる再帰処理について説明する。また、同様に(使われることはやや少ないが)自作関数の幅を広げるという意味で可変引数関数の自作方法やインライン関数についても述べる。

\section{標準ライブラリの利用}
C言語には多くの標準ライブラリがあり、これらを有効に活用することでプログラミングの幅が広がる。ヘッダの詳細については付録を見てもらうとして、ここではよく使う関数や、知っておくと便利な関数に焦点を当てる。
\subsection{時間計測}
\begin{boxnote}
\minisec{時間計測}
時間のかかる処理($l$.10)の時間を計測してみる。
\begin{lstlisting}[caption=時間計測の方法,label=program7_1]
#include <stdio.h>
#include <time.h>

int main(void){
  int i,j,k,t;
  clock_t before, after;

  before = clock();

  for(i=0;i<1024;i++) for(j=0;j<1024;j++) for(k=0;k<1024;k++) t=i*j*k;

  after = clock();
  printf("%f\n", (double)(after - before) / CLOCKS_PER_SEC);
  return 0;
}
\end{lstlisting}
\end{boxnote}
C言語で時間計測をする場合には、時間計測したい直前のポイントと直後のポイントで時間を取り、その時間の差をとって出力を行う。
\\ \\　
時間を取る関数は\verb|time.h|に入っており、次のような関数がある。
\begin{itemize}
\item time関数：秒単位で時間を取得する(起点は1970年1月1日00:00:00 UTC(世界標準時))。返却値は\verb|time_t|型である。
\item clock関数：マクロ\verb|CLOCKS_PER_SEC|に対し、1.0/\verb|CLOCKS_PER_SEC|秒単位で時間を取得する(起点はプロセス開始時)。返却値は\verb|clock_t|型である。
\end{itemize}

time関数は精度があまりよくないが、長時間計れる場合が多い。一方、clock関数は精度こそいいものの、\verb|clock_t|型の実装によってはすぐにオーバーフローしてしまう\footnote{例えば、\verb|CLOCKS_PER_SEC|が$10^6$であり(つまり、1マイクロ秒単位とし)、\verb|clock_t|型が32bit符号なし整数型で実装されていたとすれば、71分30秒程度までしか計れない。32bit符号あり整数型ならばその半分である。筆者の環境では1マイクロ秒単位で\verb|clock_t|は8バイトだったので、符号付き整数型を仮定しても2924世紀は計れるとわかる。}\footnote{\verb|time_t|型にも同様のオーバーフローの問題がある。32bit符号付き整数型が一般の実装であるので、これを仮定すると、2038年にオーバーフローが起こる(\textbf{2038年問題}\index{に2038ねんもんだい@2038年問題})。しかし、現在では64bitの実装が増えてきているので、この問題が起こる2038年には問題は軽減されているかもしれない。なお、64bit符号付き整数型の場合、およそ西暦3000億年までオーバーフローしないので大丈夫である。}。この為、必要に応じて両方を使い分ける必要がある。
\minisec{time関数}
time関数を用いる場合は、
\begin{code}
time_t before,after;
\end{code}
のように宣言した後、適切な場所でtime関数を呼び出して直前と直後の時刻を取得し、
\begin{code}
difftime(after,before)
\end{code}
により時間の差を計算することで、double型で時間の差が出る。\verb|difftime|は処理系によって変わる\verb|time_t|型の定義に対して適切に設定された関数であるので、単に引き算をするよりもこちらを使うほうが推奨される。
\minisec{clock関数}
clock関数を用いる場合は、まさしくリスト\ref{program7_1}のように
\begin{code}
clock_t before,after;
\end{code}
と宣言した後、適切な場所でclock関数を呼び出して直前と直後のCPU時刻を取得し、
\begin{code}
(double)(after-before)/CLOCKS_PER_SEC
\end{code}
により、double型・秒単位での時間を計測することができる。一般に、time関数よりもこちらのほうが精度がよく、またclock\_tが64bitであれば\footnote{これをチェックするには\verb|time.h|をインクルードした上で\verb|sizeof(clock_t)|を出力すればよい。}そう簡単にオーバーフローしないので、普段はこちらを使えば良い。32bit環境で、30分を超えるであろう処理を計測する場合に限り、time関数を用いて計測を行えば良い。
\\ \\　
なお、ここでは時間の計測に話を絞ったが、time関数は本来カレンダ時刻を取得するための関数である。clockの方が計測に向いているからと言って、不要な過去の関数になっているわけではないので注意されたい。

\subsection{文字の分類に関する関数}
ASCIIコードかどうかわからない環境も含めて文字を扱う場合、その文字が数字かどうか、英小文字かどうかなどを判定するのは煩わしいことになる。これらを解決してくれるのがctype.h\footnote{ctypeはCharacter TYPEの略である。}に収録されている、文字の分類に関する関数である。
\begin{boxnote}
\begin{multicols}{2}
\minisec{大文字/小文字の判定}
入力される文字が大文字か小文字かを判定するプログラムを作成する。アルファベットでない文字が入力された場合、その旨を出力する。
\minisec{解説}
文字を1文字入力するにはgetchar関数を用いた。

文字の分類には文字コードを使わず、ctype.hをインクルードしたその中にある関数を用いた。これにより、プログラムの移植性が向上する。
\begin{lstlisting}[caption=文字の判定,label=program7_2]
#include<stdio.h>
#include<ctype.h>

int main(void){
  char ch; 
  ch=getchar();
  if(isupper(ch)){
    puts("Large"); 
  }else if(islower(ch)){
    puts("Small"); 
  }else{
    puts("Not Alphabet"); 
  }
  return 0; 
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
\minisec{is〜〜〜関数}
ctype.hの関数は、後に説明するtoupper関数とtolower関数を除いてis〜〜〜の形式\footnote{これは、[is+種別]の名前であり、isはbe動詞のisである。}である。これらは何れも、引数が〜〜〜の種別に適合していれば真値を、適合していなければ偽値を返す関数である。例えば、リスト\ref{program7_2}ではisupper関数とislower関数を使っているが、isupper関数は引数がupper=大文字であるかどうか、islower関数は引数がlower=小文字であるかどうかを判定する関数である。

以下に、is〜〜〜関数のうち、よく使われるものを記す(全て見たい場合は付録参照)。
\begin{itembox}[l]{is〜〜〜系関数}
\begin{itemize}
\item \verb|isalnum|:半角英数字判定
\item \verb|isalpha|:アルファベット判定
\item \verb|islower|:英小文字判定
\item \verb|isupper|:英大文字判定
\item \verb|isdigit|:数字判定
\end{itemize}
\end{itembox}
\minisec{大/小文字変換}
ctype.hに入っている、is〜〜〜でない関数はただ二つ、toupper関数とtolower関数だけである\footnote{これらは、to+upper,to+lowerという意味である。}。この2つの関数は、それぞれ英小文字/英大文字が引数に取られた時のみに機能し、それに対応した英大文字/英小文字を\underline{intで}返す。それ以外の場合は、文字コードをそのまま、やはり\underline{intで}返す。従って
\begin{code}
isupper(c)?tolower(c):toupper(c)
\end{code}
などとすれば、大文字と小文字を変換することができる。

\minisec{ctype.hの引数と返却値}
実は、先に書いた返却値がintであるという仕様は、toupper/tolower関数に限ったことではなく、ctype.h全ての関数に言えることである。
\begin{itembox}[l]{ctype.hの引数と返却値}
\textbf{ctype.hの関数の引数や返却値は全てint型である。}
\end{itembox}

実際に使用する場合はchar型が整数型であるので暗黙の型変換が起こるため問題ないだろうが、時として「引数の型が違う」等の警告などを出す場合があるので書いておいた。

\subsection{プログラムの終了}
例外処理などの際に、プログラムを終了させたい場合がある。main関数であればその場でreturn文を用いればよいが、main関数以外の関数からプログラムを終了させたい場合もあるだろう。これを実現するための関数がstdlib.h\footnote{STanDard LIBraryの略。}に入っている。

exit関数とabort関数である。
\minisec{exit関数}
exit関数はプログラムを\underline{正常終了}させる関数である。
\begin{itembox}[l]{exit関数}
exit関数は
\begin{code}
exit(return_val)
\end{code}
の形式で用いる。この時、引数に与えた値がプログラム(=main関数)の返却値となる。
\end{itembox}

プログラムを正常終了させた場合は、その後にOSが適切な処理を施してくれる場合が多く、通常この関数を用いて終了すれば、main関数を\verb|return 0|で終了させた場合とほぼ同様の操作をおこなってくれる\footnote{一応、処理を具体的に示しておくと、
\begin{itemize}
\item 後で学ぶファイルの操作において、ファイルが開かれていれば自動で閉じてくれる。
\item 同じくファイルの操作において、出力ストリームをフラッシュしてくれる。
\item 一時ファイルを削除する
\end{itemize}
などの処理を行う。これ以外の処理を使う場合にはatexit関数というものを使うのだが、関数ポインタを理解しないと使いこなせないのでここでは説明しない。
}。

\minisec{abort関数}
exitは正常終了であったが、\underline{異常終了}させる関数もある。それがabort関数である。
\begin{itembox}[l]{abort関数}
abort関数は
\begin{code}
abort()
\end{code}
の形式で用い、これによりプログラムが異常終了させる。
\end{itembox}

この関数は、OS等のホスト環境に対して、そのプログラムが異常終了したことを示してプログラムを終了させる。この関数ではexit関数のような終了処理は行われないが、OSが異常終了の際の処理を施してくれるため、主としてデバッグの際に便利である。または、ユーザーが変な操作をした場合に、その警告を促すなどの用途でも用いられる。

\minisec{終了関連マクロ}
通常、プログラムの終了の成否は各々0か非0に対応しており、0が正常終了である。だが、環境によっては必ずしも0/非0により正常終了/異常終了が区別されるとは限らない\footnote{ここまで、main関数の終了には0を返すものとしてきた。実際、大抵のPC環境ではreturn 0としておけば正常終了になる。だが、組み込みプログラミングなどにおいて特別な処理を行う場合には、変わってくる場合がある。とはいえ、特殊なデバイスを考えない限り、これらのマクロは利用しなくても良いだろう(実際、筆者のLinux環境でこれらのマクロの定義を見てみると、0/1と定義されていた)。移植性を十分高めたいと考える場合に限り、これらを利用すると良い。}。この環境依存の問題を解決するために、stdlib.hにおいて終了関連のマクロが定義されている。
\begin{itembox}[l]{終了に関連したマクロ}
\begin{description}
\item[EXIT\_SUCCESS] 正常終了を示す。
\item[EXIT\_FAILURE] 異常終了を示す。
\end{description}
\end{itembox}

これらのマクロを利用すれば、特殊な処理系において終了処理を記述する場合でも、適切な終了方法を選択してプログラムを終了させられるようになり、移植性に富む。

\subsection{型に関する標準ライブラリ}
変数の型について思い出すと、変数の型において「何型が何bitである」という正確な定義は殆ど無かっただろう。勿論、sizeof演算子を用いて大きさを取得すればその型についての性質はわかるだろうが、計算機イプシロンなどいちいち計算して出すのは面倒である。そこで、変数の型を扱うために必要な情報が書かれたヘッダがいくつか用意されている。ここでは、これらについて簡単に説明する。
\minisec{float.hとlimits.h}
float.hは浮動小数点数関連の、limits.hは整数関連の情報を記録したヘッダであり、マクロのみが書かれている。詳細は付録を参照されたいが、これらのヘッダにおけるマクロの命名規則のみ説明しておくこととする。
\\ \\　
これらのヘッダにおいて、全てのマクロは
\begin{code}
(型名)_(属性名)
\end{code}
の形式で書かれている。例えば、\verb|ULONG_MAX|というマクロはunsigned longの最大値という事が読み取れるだろう。
\\ \\　
これらのマクロは型の様子を知りたい場合の他、「十分大きい値を代入したい」「誤差を上手く処理したい」などの場合に利用できる。

\minisec{fenv.hによる例外処理}
fenv.h\footnote{Float ENVironmentの略である。}は浮動小数点環境について扱うヘッダで、C99によって新たに定義されたヘッダである。これは、浮動小数点演算において出てくる\textbf{例外}\index{れいがい@例外}(exception)について処理する(\textbf{例外処理}\index{れいがいしょり@例外処理}(exception handling))など、浮動小数点絡みの細かな部分の扱いに用いる。以下、例外処理に的を絞って記述する。
\\ \\　
例外とは、プログラムが処理を実行している途中で、コンピュータが処理できない何らかの異常が発生することを言う。異常と一口に言っても内容は様々である。
\begin{itembox}[l]{例外の具体例}
\begin{itemize}
\item ファイルが開けなかった
\item 入力形式がおかしい
\item メモリを確保できなかった
\item メモリの変な場所にアクセスした
\item 許されない演算を行った(演算例外)
\end{itemize}
\end{itembox}
このように、例外(異常)として考えられることを列挙していけば枚挙に暇がない。これらの例外が現れた場合、プログラムは通常適切な事後処理を施して(異常)終了するように書かれる。C言語では例外を処理するための構文がない\footnote{JavaやC++といった比較的新しい言語では\verb|try〜catch|などの例外処理用構文がある。}ため、プログラマが考えて例外を検知するようにプログラムを書かなければならない。
\\ \\　
fenv.hには先に挙げたような例外のうち、浮動小数点数演算例外について処理する為の関数が揃っている。これを用いれば、0割などの例外処理を読みやすく実現できる。
\begin{boxnote}
\minisec{0割例外処理を含む除算}
2数の除算を行う処理について、0割例外を用いて例外処理を行う。
\minisec{解説}
$l$.7で0割例外を発生させておき(0割例外が起きていることを示しておき)、それを$l$.8で受けて処理を行なっている。なお、gccでコンパイルする際には\verb|-lm|オプションが必要である。
\begin{lstlisting}[caption=0割例外処理,label=program7_3]
#include<stdio.h>
#include<fenv.h>

int main(void){
  double x,y;
  scanf("%lf %lf",&x,&y);
  if(y==0) feraiseexcept(FE_DIVBYZERO);
  if(fetestexcept(FE_DIVBYZERO)) puts("Exception!");
  else printf("%f/%f=%f\n",x,y,x/y);
  return 0;
}
\end{lstlisting}
\end{boxnote}

リスト\ref{program7_3}のように、例外が起きていることをferaiseexcept関数を用いて知らしめておき、fetestexcept関数によって「ある例外が発生しているかどうか」を調べ、例外発生時の処理を書くことで例外処理を行える。この書き方を採用することによって例外処理が明確になり、プログラムが読みやすくなる。簡単なプログラムの場合は必要ないが、大規模プログラムの場合などには上手く利用すると良い。

\minisec{inttypes.hとstdint.h}
整数について扱うヘッダとして、C99で新たに追加されたのがinttypes.hとstdint.hの2つのヘッダである。
\\ \\　
int型は何bitか、規格には書かれていない。この為、int型を使った場合に、環境によって齟齬が生じる可能性がある。これらを解決するのがstdint.hの役目である。

マクロの一覧は例によって付録を参照してもらうこととして、ここでは簡単な使い方を紹介しておく。もしも、厳密に64bitの符号付き整数型を使いたい場合(環境依存性を無くしたい場合)、
\begin{code}
#include<stdint.h>
\end{code}
としてstdint.hをインクルードした後
\begin{code}
int64_t a,b,c;
\end{code}
などのように\verb|int64_t|という名前の型を使えば、これは厳密に64bitの符号付き整数型を表してくれる。この64の部分を8,16,32に変更することでビット数を変えることができる。この他、「その環境で使える最大の符号なし整数型を使いたい」というような場合には\verb|uintmax_t|型などを使うことができる。

stdint.hには、これらの型を使う場合の属性関連のマクロも定義されており、特に整数型の大きさに注意を払ったプログラムを書く場合に利用できる。
\\ \\　
しかし、ここで注意しなければならないのは、出力などの際である。printf関数を用いて先に書いたような型の変数を出力しようとした時、どのような書式指定子を用いればよいだろうか？あるいは、絶対値を計算する場合、abs,labs,llabsの3種類があるわけだが、これらをどのように使い分ければよいだろうか？これらの問題を解決してくれるのがinttypes.hである。

書式指定子は、表\ref{inttypes_macro}に示すような形式で記す。ここで、各形式における\verb|?|は実際には書式を示す1文字になり、\verb|*|は型の幅になる。すなわち、\verb|uint64_t|型をそのまま出力したいのであれば\verb|PRIu64|になるし、\verb|intmax_t|型を10進表記でそのまま入力したい場合には\verb|SCNdMAX|となる。
\begin{table}[htb]
\centering
\caption{書式指定子マクロ(記号は本文参照)}\label{inttypes_macro}
\begin{tabular}{|c||c|c|}\hline
型名&printf系関数&scanf系関数\\ \hline
&&\\[-15.5pt] \hline
\verb|int*_t|&\verb|PRI?*|&\verb|SCN?*|\\ \hline
\verb|int_least*_t|&\verb|PRI?LEAST*|&\verb|SCN?LEAST*|\\ \hline
\verb|int_fast*_t|&\verb|PRI?FAST*|&\verb|SCN?FAST*|\\ \hline
\verb|intmax_t|&\verb|PRI?MAX|&\verb|SCN?MAX|\\ \hline
\verb|intptr_t|&\verb|PRI?PTR|&\verb|SCN?PTR|\\ \hline
\end{tabular}
\end{table}

ここで、注意して欲しいのは、これらを書式指定文字として用いる場合には、\verb|%|の後にダブルクォーテーション(\verb|"|)で囲んで書かなければならないという事である\footnote{マクロの展開結果を見てみると、括らなければならない理由がよくわかる。}。例えば、先の例で言えば
\begin{code}
printf("%"PRIu64"\n",var1);
scanf("%"SCNdMAX"",&var2);
\end{code}
のようになる。
\\ \\　
abs関数などについては、\verb|intmax_t|型向けの関数がinttypes.h内に定義されており、普通の関数と同様に用いれば良い。一例を示しておこう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{絶対値の出力}
コンパイル環境において扱える最大の整数範囲で、絶対値を出力するプログラムを作成する。
\minisec{解説}
ここまでに学んだ文法を用いて、\verb|intmax_t|型の整数を宣言し、それについて入力・絶対値・出力の各処理を書けば良い。
\begin{lstlisting}[caption=最大範囲の絶対値,label=program7_4]
#include<stdio.h>
#include<stdint.h>
#include<inttypes.h>

int main(void){
  intmax_t num,ans;
  scanf("%"SCNdMAX"",&num);
  ans=imaxabs(num);
  printf("%"PRIdMAX"\n",ans);
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

\subsection{代替綴りとトライグラフ}
C言語は日本語や英語にとどまらず、世界中で広く使われている。この際、環境によっては記号が足りない場合などがあり、その場合の代替記法を用いなければならない。これらの代替記法を提供するのがiso646.hとトライグラフである。この2つの記法を採用することにより、ISO/IEC646規格において規定された文字コードのみのソースを書くことができる。通常は必要ないが、複数の国で使うようなソースを書く場合には出てくることもあるので紹介しておく(とはいえ、主要な国はこれを使わなくても大丈夫なのだが)。
\minisec{代替綴りとiso646.h}
iso646.hは記号の代替表記を定義するヘッダである。このヘッダはC95で追加されたヘッダであり、記号が使えない場合だけに限らず使うことができる。

一例として、ハット(\verb|^|)記号を考えよう。これはC言語ではXOR演算の演算子であるが、他の言語では累乗の演算子となっている場合があり、直感的に合わないという場合がある。このようなときには
\begin{code}
#include<iso646.h>
\end{code}
とiso646.hをインクルードしておいて
\begin{code}
a xor b
\end{code}
などと、代替表記をすれば直感にもわかりやすくなるだろう。

\minisec{トライグラフ}
\textbf{トライグラフ}\index{とらいぐらふ@トライグラフ}(trigraph)ないし\textbf{3文字表記}\index{さん3もじひょうき@3文字表記|see{トライグラフ}}は、\verb|??|の後に記号を一文字加えることで他の記号を表すという代替表記である\footnote{この3文字表記で\verb|?|が使われるため、\verb|?|そのものはエスケープシークエンス\verb|\?|となっている。}。3文字表記は表\ref{trigraph}に示す全9種類である\footnote{iso646において、文字コードによっては表せないASCII文字は10種類あり、トライグラフはひとつ足りていないように見える。これは、記号\verb|$|をCコード中で制御文字として使用することがないので、省いたためである。}。
\begin{table}[htb]
\centering
\caption{トライグラフの一覧}\label{trigraph}
\begin{tabular}{|c|c||c|c||c|c|}\hline
トライグラフ&記号&トライグラフ&記号&トライグラフ&記号\\ \hline
& && && \\[-15.5pt] \hline
\verb|??=|&\verb|#|&\verb|??/|&\verb|\|&\verb|??<|&\verb|{|\\ \hline
\verb|??(|&\verb|[|&\verb|??'|&\verb|^|&\verb|??>|&\verb|}|\\ \hline
\verb|??)|&\verb|]|&\verb|??!|&\verb`|`&\verb|??-|&\verb|~|\\ \hline
\end{tabular}
\end{table}

この表記を用いると、例えば、
\begin{code}
printf("How are you???/n");
\end{code}
は
\begin{code}
printf("How are you?\n");
\end{code}
と展開される。日本語環境でこれを使うことはまずないだろうが、逆に\verb|??|と連続して書いてしまって意図しないでトライグラフを用いてしまうことがある(とはいえ、実際にはトライグラフの有無をコンパイルオプションで指定できるが)ため、ここで簡単に紹介した。

\subsection{manコマンド}
Unix(Linux)ではこれらの関数を簡単に調べるためにmanコマンド\footnote{MANualコマンドの略である。}があり
\begin{code}
man 関数名
\end{code}
とすることで、Cの関数の用途を調べることができる。

これによって開かれた画面では上下のカーソルキーでページ送りできる他、終了時にはqキーを押せば良い。

ここまでにいくつもの関数を紹介し、また、今後も多数の関数が出てくるがこれらを逐一覚える必要は全くない。使いたい時に、本書の付録を引いて用途に合いそうな関数を探し、見つかったらそれをmanコマンドで調べればよいだけである。

\section{再帰関数}
\textbf{再帰}\index{さいき@再帰}(recursive)は自分自身に再度帰着させるという概念である。これはプログラミングに特有のものではないが、プログラミングにおいても重要な役割を果たす。再帰は確かにその言葉通り、自分自身に再度帰着させるという意味であるが、これではわかりにくい。そこで、「例示は理解の試金石」ということで、具体例から再帰処理を理解していこう。
\\ \\　
階乗を再帰的に定義することを考える。やや冗長かもしれないが、次の定義は階乗の定義になっている。
\begin{itemize}
\item 0の階乗は1である。
\item $n$の階乗は、$n-1$の階乗に対して$n$を乗じたものをいう。但し、$n$は自然数とする。
\end{itemize}
これに従って「$3$の階乗」を理解していくと
\begin{enumerate}
\item $3$の階乗は、$2$の階乗に対して$3$を乗じたものである。
\item $2$の階乗は、$1$の階乗に対して$2$を乗じたものである。
\item $1$の階乗は、$0$の階乗に対して$1$を乗じたものである。
\item $0$の階乗は$1$である。
\item 従って、逆にたどれば、3の階乗が求められる。
\end{enumerate}
という順になる。これは階乗の定義に階乗そのものを用いている。このようにある処理の中で自分自身を呼び出すものが再帰処理である。
\\ \\　
再帰処理を含む関数を\textbf{再帰関数}\index{さいきかんすう@再帰関数}(recursive function)という。以下、この実装方法について学んでいこう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{再帰を用いた累乗}
再帰関数を用いて累乗(整数乗)を行う関数を実装する。
\minisec{解説}
\begin{itemize}
\item 自然数乗は繰り返し2乗法を用いれば速いが、ここでは愚直に掛け算を行った。
\item 0乗は全ての数について1とした。つまり$0^0=1$と定義した。
\item 負数乗は逆数の自然数乗をとることで計算した。
\end{itemize}
\begin{lstlisting}[caption=整数乗を行う関数,label=program7_5]
double powint(double f,int n){
  double ret=1;
  if(n<0) return powint(1/f,-n);
  while(n--) ret*=f;
  return ret;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
$n$が非負整数であれば、このプログラムはこれまでの文法で学んだ事で理解できる。このことからもわかるとおり、この関数において重要なのは$l$.3の処理である。

\minisec{負数の場合の処理}
リスト\ref{program7_5}の$l$.3の処理は、ifから明らかに$n$が負の数の場合に実行される。すると、今度は\verb|powint(1/f,-n)|として、また\verb|powint|関数が呼ばれる。すると、今度は$1/f$を新たな$f$(以下$f'$)として、$-n$を新たな$n$(以下$n'$)として\verb|powint|の処理が実行される。$n'>0$であるので、これは$f'$の$n'$乗である。この計算結果を中で呼ばれた\verb|powint|($f',n'$が引数の方の\verb|powint|)が返す。すると、この結果を元々の\verb|powint|($f,n$が引数である\verb|powint|)も返す。これにより、計算が実行されている。
\\ \\　
ここまでの説明よりわかるとおり、\verb|powint|関数は内部的に自分自身=\verb|powint|関数を呼び出す処理を行なっている。このような関数が再帰関数であり、用いる場合はリスト\ref{program7_5}のように(他の関数から呼び出すのと同様に)自分自身を書けば良い。(なお、必ずしもreturnの値として書く必要はない)。

\subsection{再帰関数のメモリ上での動作}
リスト\ref{program7_5}での再帰呼び出し回数は、高々1回であった。今度は、もっと多くの回数の呼び出しを行う再帰処理を見てみよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{アッカーマン関数}
次の式により定義されるアッカーマン関数を実装する。
\[
\mathrm{Ack}(m,n)=\begin{cases}
    n+1\ (m=0)\\
    \mathrm{Ack}(m-1,n)\ (n=0)\\
    \mathrm{Ack}(m-1,\mathrm{Ack}(m,n-1))
    \end{cases}
\]
\begin{lstlisting}[caption=アッカーマン関数,label=program7_6]
typedef unsigned int u_int;
u_int ack(u_int m,u_int n){
  if(m==0) return n+1;
  if(n==0) return ack(m-1,1);
  return ack(m-1,ack(m,n-1));
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
この関数において、\verb|4 1|を渡してみると、計算に随分時間がかかった他、\verb|5 5|などを渡すとSegmentation fault(メモリ上のアクセス禁止領域にアクセスした時に出る警告)と出てプログラムが終了してしまった。これは一体なぜなのだろうか。再帰関数の動作を理解し、この疑問を解明しよう。
\minisec{再帰呼び出しの様子}
再帰呼び出しを行う場合、その呼び出した側の関数はどうなっているのだろうか。また、呼び出された側の関数はどうなっているのだろうか。
\\ \\　
通常の関数の場合、別の関数を呼び出したら、その処理が終わるまで待っており、その処理が終わり次第続きの処理を行う。これは再帰関数でも同じである。再帰呼び出しを行った場合、一連の再帰処理が全て終わるまで待ち続け、終わった後に処理が続けられる。その間関数は開きっぱなしである。つまり、複数回の再帰呼び出しを行った場合、その最も根元にある関数は、再帰が全て終わるまでずっと待ち状態を続けているのである。再帰が深くなった場合、このように待ち続けている関数が増えてくるし、呼び出し回数も馬鹿にならない。例えば、アッカーマン関数において、\verb|3 3|を渡せば関数の呼び出し回数は2432回になり、\verb|4 1|を渡すと2862984010回もの呼び出しが行われることになる。ここから、仮に1億回の呼び出し処理を1秒でこなすとしても、\verb|4 1|を渡した場合には30秒弱かかる計算になってしまう。
\\ \\　
このように再帰処理で計算を行う場合、計算回数(呼び出し回数)が爆発的に増えてしまう場合がある。これは、一度計算した値についても、再度(多数の呼び出しを含む再帰処理の)計算を行ってしまうからである。例えばアッカーマン関数において\verb|4 1|を渡した場合、$\mathrm{Ack}(0,1)$は65512回も計算されている。これは明らかに無駄である。そこで、後で学ぶ配列などを用いて、一度計算した値をメモしておき、それを用いて再帰を高速化する\textbf{メモ化再帰}\index{めもかさいき@メモ化再帰}(MemoizationないしMemoized recursive)の方法が知られている。

\minisec{再帰処理とメモリ}
先に書いたとおり、再帰では呼び出し側の関数はずっと待ち続けている。これは、実行されている関数が常にメモリに居座るという事である。
\\ \\　
自作関数を呼び出した場合、メモリ上のスタック領域と呼ばれる場所に関数が展開される。そして、関数が終了すれば通常その場所は明け渡される。だが、再帰処理の場合は、明け渡すことなく多くの呼び出しを行なってしまうことになりかねない。これがある一定回数を超えると、スタック領域の許容量に達してしまい、「これ以上メモリがない！」という状況になってしまう。だが、再帰処理の終了の条件を満たしていないため、プログラムは更にメモリを取ろうとしてしまう。そこで、メモリ上のアクセス禁止領域に踏み込んでしまい、Segmentation faultになってしまったのである。このように、スタック領域からあふれるエラーを\textbf{スタックオーバーフロー}\index{すたっくおーばーふろー@スタックオーバーフロー}(stack overflow)と呼び、再帰処理の場合には特に注意を払わなければならない。

\subsection{再帰関数の注意点}
再帰処理は先に書いたメモ化再帰の技法なども含めて、簡単にソースを書くために、あるいは読みやすいソースを書くために必要である。構造化定理に立ち返れば、再帰処理は必ずしも必要ではなく、反復処理で書き換えられるはずだが、実際に反復処理に書き換えようとすると多大な労力を要するようなものも少なからずある。
\\ \\　
だが、再帰処理は反復処理ではない。これは、先に書いたメモリ上での動作を見れば明らかであろう。反復処理であれば、無限ループを書いたと言っても「終わらない」だけで済むが、無限再帰を組んでしまうとメモリが不足し、最悪の場合OSなどに異常をきたしてしまう場合もある(通常はOSの安全機能が働くが、穴がないとは限らないため)。
\\ \\　
以上の点から、再帰処理を行う際には、とりわけメモリに注意しなければならないことがわかる。以下に、その注意点をまとめておこう。
\begin{itembox}[l]{再帰処理を使う際の注意点}
\begin{itemize}
\item \textbf{再帰処理を行う場合は充分少ない回数で再帰が終了することを保証して作成しなければならない。}
\item 関数Aから関数Bを呼び出し、関数Bから関数Aを呼び出すような再帰処理(複合再帰処理)は再帰処理を行なっていることがわかりづらくバグの元なので作らないほうが良い。
\item 再帰処理を行う際には、スタック領域でメモリを取るので、ある程度メモリを空けておいて実行する方が良い。また、必要に応じてスタックサイズを大きくする。
\item 単純に再帰をするのではなく、メモ化するなどの工夫を凝らして、再帰処理の呼び出し回数を低減させなければ、計算回数が増えやすい。
\end{itemize}
\end{itembox}

\section{可変引数関数}
printf関数やscanf関数は引数の個数が不定であり、第1引数の文字列リテラルによってその引数の個数が決まる。このように、引数の個数が不明であるような関数のことを\textbf{可変引数関数}\index{かへんひきすう@可変引数関数}(variable arguments function)と呼ぶ。本節ではこの可変引数関数の作り方について説明を行う。

可変引数関数には大きく分けて2種類の作り方がある。この2種類は、引数の個数を確定する手段が異なっている他は、同様に実装できる。可変引数の個数を決定するためには
　\begin{itemize}
  \item 引数の最後にターミネータ(終端を示す値)を入れる。
  \item 可変引数以前の引数に、可変引数の個数を情報として含む引数を与える。
　\end{itemize}
の2種類がある\footnote{この2つの方法は、配列引数の関数で配列のサイズを知りたい場合などにも共通する。}。これは後に扱う文字列と同様である。つまり、文字列はC言語ではNUL(NULL文字)というターミネータを用いるが、Pascalなどの言語では、長さを示す値を文字列に付加して格納しているのである(詳しくは文字列の解説を参照のこと)。以下、この2種類と、可変引数リストを引数に取る関数について説明を行う。
\subsection{stdarg.hの利用}
可変引数関数では、1個以上の引数の個数を任意に変えることができる。これは、stdarg.h\footnote{STanDard ARGumentの略である。}の宣言によるものである。

可変引数関数を用いる場合の手順は次のようになる。
\begin{itembox}[l]{可変引数関数を用いるための手順}
\begin{enumerate}
\item stdarg.hをインクルードしておく。
\item 関数の宣言の際に、可変引数部を\verb|func(par1, par2, ...)|のように\verb|, ...|を用いて宣言する。
\item 関数内で\verb|va_list|型変数を宣言する。
\item 関数内で\verb|va_list|型変数を\verb|va_start(va_list型変数, 可変引数の直前の引数)|として、\verb|va_list|型変数を初期化する。
\item 引数を前から順に\verb|va_arg(va_list型変数, 可変引数の型)|により呼び出す。
\item 利用し終えたら\verb|va_end(va_list型変数)|により、後始末を行う。
\end{enumerate}
\end{itembox}
ここで、型\verb|va_list|は可変引数関数の引数一覧を示す型である。この手順は引数の個数の取得方法によらないので、一連の方法として理解しておくと良い。実例は後の引数の個数の取得方法別の解説で見せる。
\\ \\　
可変引数関数のプロトタイプ宣言についても、通常の関数と同じように扱うことができる。一方、呼び出しを行う場合はprintf関数のように、コンマ区切りで可変引数を列挙すれば良い。

\subsection{ターミネータを用いる方法}
\begin{boxnote}
\begin{multicols}{2}
\minisec{総和計算関数(ターミネータ利用)}
int型の引数の和を計算する可変引数関数sumを作成する。この時、0という要素が出るまで足し続けるものとする。
\minisec{解説}
仕様から、可変引数のターミネータに0を用いる。また、\verb|va_start()|を利用するためには可変引数の直前の引数が必要になるため、ここでは\verb|i1|という変数を宣言しておいた。
\begin{lstlisting}[caption=ターミネータ利用による総和計算関数,label=program7_7]
#include <stdarg.h> 

int sum(int i1, ...) {
  va_list vars; 
  int s=i1,n; 
  va_start(vars, i1); 
  do{
    n=va_arg(vars,int); 
    s+=n; 
  }while(n!=0); 
  va_end(vars); 
  return s; 
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
以下、リスト\ref{program7_7}の解説を行う。

\begin{description}
\item[$l$.3] \verb|...|の宣言により、可変引数関数であることを示す。
\item[$l$.4] 可変引数リストを格納するための変数\verb|vars|を宣言する。
\item[$l$.6] 可変引数の始まりを、\verb|va_start|により設定する(可変引数リストの初期化)。
\item[$l$.8] \verb|va_arg|を用いて、可変引数リスト\verb|vars|の「次の引数」をint型で読み込む。
\item[$l$.10] do以下の処理を、読み込んだ可変引数が0になるまで繰り返す。
\item[$l$.11] 用いた可変引数リストについて、\verb|va_end|を用いて後始末を行う。
\end{description}

このように、可変引数は、ひとまずリストに全て格納しておいて、随時\verb|va_arg|により引数を呼び出してくる形になる。これらのリストの扱いを行うための関数が格納されているのがstdarg.hである。
\\ \\　
この実装から明らかなように、ターミネータの場合、読み取った値が終端条件であるかどうかを確かめることで引数の終了を確かめられる。このターミネータは自分で決め、終了処理も自分でやらなければならない(可変引数が尽きたからと言って勝手に動作が終わるわけではない)点に注意しなければならない。

\subsection{可変引数より前の引数で個数を示す方法}
printf関数などを見ると明らかなように、可変引数より前の引数から可変引数の個数が読み取れるならば、それを用いて可変引数処理を行うことができる。ここでは、直接個数を指定する形の総和を作ってみよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{総和計算関数(個数情報利用)}
int型の引数の和を計算する可変引数関数sumを作成する。ただし、第1引数として総和を取りたい値の個数が与えられる。
\minisec{解説}
今度は、第1引数に総和をとりたい可変引数の個数が与えられるように総和関数を作りなおした。これにより、\verb|va_start()|を利用するための直前の引数は、この個数を与える引数となるように変更した。
\begin{lstlisting}[caption=個数情報利用による総和計算関数,label=program7_8]
#include <stdarg.h> 

int sum(int num,...){
  int i,s=0; 
  va_list vars; 
  va_start(vars,num); 
  for(i=0;i<num;i++)
    s+=va_arg(vars,int); 
  va_end(vars); 
  return s; 
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

リスト\ref{program7_8}を見てもらえば明らかなように、可変引数の利用方法自体は先のターミネータを利用したものと何ら変わりない。ただ、ループの処理が変わっているだけである。
\\ \\　
個数の情報を引数から読み取る方法を応用すれば、可変引数のうち前いくつかは用途Aで用い、それ以降は用途Bで用いるなどの方法を取ることもできる。また、このように可変引数にいくつもの意味を混在させる場合など、ターミネータと個数の両方法を混在させることも可能である。いずれにせよ、可変引数関数は引数が尽きたからと言って勝手に動作が終わるわけではないため、終了処理を適切に書いてやる必要がある。

\subsection{可変引数を一括処理する関数}
printf関数は可変引数関数の代表例であるが、この可変引数部を\verb|va_list|に変えた関数としてvprintf関数がある\footnote{C99ではscanf関数の可変引数部を\verb|va_list|に変えたvscanf関数ができた}。これらprintf/scanf系関数はstdio.hに入っている。この利用例を見てみよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{改行されるprintf}
最後で自動的に改行されるprintf関数として、lineprintf関数を作る。
\minisec{解説}
第1引数formatは見慣れないと思うが、これは書式文字列を指定するものである。この詳しい意味については後の章で学ぶ文字列やポインタについて学んだ後わかるだろう。これを出力するときに、可変引数を、\verb|va_list|型変数で与えるのがvprintf関数である。
\begin{lstlisting}[caption=改行付きprintf,label=program7_9]
#include<stdio.h> 
#include<stdarg.h> 

int lineprintf(char *format, ...) {
  va_list ap; 
  va_start(ap, format); 
  vprintf(format, ap); 
  putchar('\n'); 
  va_end(ap); 
  return 0; 
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

リスト\ref{program7_9}の$l$.7にあるように、vprintf関数(及びそれに類する関数)では、\verb|va_list|型変数を引数にとり、それに応じた処理を行う。この場合は、\verb|va_start|により可変引数リストを初期化した後、それらの\verb|va_list|を利用する関数を用い、\verb|va_end|により後始末を行う。

\section{インライン関数}
関数マクロは、単に式を展開するだけであるので処理が速いが、型チェックがないのが難点であった。そこで、型チェックがあり、速度面で十分速い関数を作りたいと考えた。これが\textbf{インライン関数}\index{いんらいんかんすう@インライン関数}(inline function)である。インライン関数は、コンパイル時にインライン展開と呼ばれる技法を用いて最適化される関数で、通常の関数に比べて呼び出しのオーバーヘッドがなく、速くなるという利点がある。

インライン関数はC99において新たに登場した関数の定義方法であり、次のように定義する。
\begin{itembox}[l]{インライン関数の定義方法}
ある関数をインライン関数として定義する場合、
\begin{code}
inline 通常の関数定義
\end{code}
のように、関数の定義の前にinlineキーワードを付す。
\end{itembox}
　この定義方法によって定義された関数は、コンパイル時にインライン展開を用いて可能な限り速い関数になるように最適化される。実例として、Euclidの互除法により2数の最大公約数を求める関数をinline関数で定義する場合
\begin{code}
inline int euclid(int m,int n){
  return n?euclid(n,m%n):m;
}
\end{code}
のようになる。
\\ \\　
インライン関数には、次のような原則があり、これに則って利用する必要がある。
\begin{itembox}[l]{インライン関数の原則}
\begin{itemize}
\item inlineキーワードをつけた関数は、コンパイル時に、そのコンパイル単位内で見える位置に定義が書かれている必要がある。
\item inlineキーワードをつけた関数に対し、これにインライン展開の技法を適用して最適化するかどうかはコンパイラ側の自由である。すなわち、inlineキーワードをつけたからと言って必ずインライン展開されるとは限らない\footnote{この点はregister記憶クラス指定子に似ている。}。
\item inlineキーワードをつけた関数が、実際にインライン展開される場合、その関数の意味が改変されたり損なわれたりすることはない。
\item インライン関数の展開は、関数形式マクロのそれに似ているが、引数の型チェックがあることや、引数に式を入れても値が評価されて渡されるという点が違う(＝通常の関数と同様)。
\end{itemize}
\end{itembox}
先の制約「定義が可視である」ことから、インライン関数を定義する場合はある一つのファイル内でその関数が完結するように書くのが一般的である\footnote{外部参照定義も適切に行えば可能であるが、ここでは触れない。}。

\newpage

\begin{shadebox}
\section*{本講の要点}
本講では、標準関数の使い方と、自作関数の応用的な使い方について学んだ。
\subsection*{標準関数}
\begin{itemize}
\item 時間計測にはtime.hのtime関数やclock関数を用いる。
\item 文字コードに依存しない文字処理にはctype.hを用いると良い。
\item main関数以外からプログラムを終了させる場合、正常終了を行うexit関数や異常終了を行うabort関数を用いる。
\item 標準ライブラリには型について適切に扱うためのライブラリがあり、これを用いて移植性の高いプログラムを書くことができる。
\item ASCIIコードの文字のうち、環境によっては存在しない文字を書くために、代替綴りの方法が定義されている。
\item manコマンドを用いれば関数のマニュアルを読むことができる。
\end{itemize}
\subsection*{再帰関数}
\begin{itemize}
\item 再帰関数とは、自身をその中で呼び出す関数のことである。
\item \textbf{再帰処理を行う場合は充分少ない回数で再帰が終了することを保証して作成しなければならない。}
\end{itemize}
\subsection*{可変引数関数}
\begin{itemize}
\item 可変引数関数の実装の際にはstdarg.hをインクルードした上で、可変引数リストを格納する変数を宣言し、その変数を初期化し、次いで順に可変引数を型を指定して呼びだし、最後に後始末を行う。
\item 可変引数関数を実装する際には、可変引数の個数を示す引数を先行する引数に入れるか、ターミネータを用いて、引数の終了を示さなければならない。
\end{itemize}
\subsection*{インライン関数}
\begin{itemize}
\item インライン関数は、できるだけインライン展開と言われる技法を用いて展開されるように指定された関数である。
\item インライン関数は、inlineキーワードをつけて宣言し、コンパイル時に見える位置で定義する。
\end{itemize}
\end{shadebox}

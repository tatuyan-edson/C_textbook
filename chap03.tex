第2講に引き続き、変数の扱い方を学んでいくことにする。前講では簡単な演算のみを扱ったが、今回はより多くの演算や理論を学び、変数を活用できるようにしよう。
\section{計算の誤差}
浮動小数点数演算には誤差が出ることが知られている。実際どのような感じか見てみよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{誤差の確認}
リスト\ref{program3_1}に示したプログラムの出力結果を予想し、また実際に実行して、どのような結果になるか確認せよ。
\\ \\　
人間の頭で計算すればaは0.1,bは100,cは1000000.0000001となるはずである。前回までの文法で学んだ内容を用いているので、特に読めない箇所もないと思う。だが、物は試しなので、必ず打ち込んで実行してみること。はたして、考えた通りの動作をするだろうか？しないとすれば、何が原因だろうか？
\begin{lstlisting}[caption=様々な誤差,label=program3_1]
#include<stdio.h>

int main(void){
  float a , b , c;
  
  a = 0.1 / 3.0;
  a *= 3.0;
  b = 1000000.00001;
  b -= 1000000;
  b *= 1E7;
  c = 1000000 + 1E-7;

  printf( "a=%.8f\n" , a );
  printf( "b=%.8f\n" , b );
  printf( "c=%.8f\n" , c );
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

筆者の環境で実行してみると
\begin{code}
a=0.10000001
b=99.99959564
c=1000000.00000000
\end{code}
となってしまった。何れも、予想した結果とは違うことがわかる。これが誤差であり、場合によっては大きなバグに発展してしまうこともある厄介な問題である。
\\ \\　
このように、数値の計算を行う場合にパソコンの性質その他によって起こる誤差を\textbf{計算誤差}\index{けいさんごさ@計算誤差}という。前講の計算例外が「パソコンの性質その他により起こる、計算できない値」であるのに対して、計算誤差は「計算することはできるが、実際に期待される値と食い違いが生じる」というものである。以下、各種の計算誤差について見ていこう。
\subsection{丸め誤差}
リスト\ref{program3_1}の変数$a$の出力のずれを起こした誤差が\textbf{丸め誤差}\index{まるめごさ@丸め誤差}(round-off error)である。
\\ \\　
丸め誤差について考える前に、100円均一ショップなどで売っている普通の電卓を用いて、1/3*3を計算してみよう。0.9999$\cdots$となるだろう。これは、電卓の表示桁に限界があるため、それよりも下の値が切り捨てられて起こる現象である。

似たような現象として、やはり電卓で、ルートを繰り返しとった後、逆に同じ回数だけ2乗を繰り返しても、元の数に戻らない場合がある\footnote{手持ちの電卓で試した所、元の数を2として、16回ルートをとった後、2乗を16回繰り返すと、1.999997708という値になった。}。これも計算中にあふれた桁が捨てられることによって起こると考えられる。
\\ \\　
パソコンは浮動小数点などを用いて様々な数を扱えるようにしているが、内部で使われているビットは有限であり、それ故、無限の桁を保持することができない。そのため、やはりあふれた桁が捨てられ(あるいは切り上げられ)真の値との誤差が出てくる。これが丸め誤差である。具体的には、10進数の0.1を2進数で表現すると無限小数(循環小数)になるため、丸め誤差が生じている(パソコンでは内部的に2進数として保存されていることに注意！)。これが、3での除算・乗算過程を経ることによって見える値になったのが今回の事例ということである。

\subsection{桁落ち}
リスト\ref{program3_1}の変数$b$の出力のずれは\textbf{桁落ち}\index{けたおち@桁落ち}(cancellation of significant digitsあるいは単にcancellationやcancellation errorとも)によるものである。
\\ \\　
この例では、絶対値の近い二つの大きな数の引き算を行っている。浮動小数点の原理を考えると、計算結果の小数点以下の値の精度があまり良いとは思えない。ところが、引き算によって有効桁数が減少し、この「精度が良くない部分」が表に出ることになってしまった。こうして誤差が顕在化したものが桁落ちである(このソースでは見やすくなるように増幅させている)。単純には、絶対値の大きな2数があり、これらの値が近い時に、0方向に近づく加減算を行うと有効桁数が減少すること、と言える。
\\ \\　
桁落ちはその原理を考えれば、絶対値の近い2数の引き算を上手に避けることで回避できる。アルゴリズムの変更は勿論、混合計算の場合等、うまい変形で避けられることもある。例えば、二次方程式の解の計算の際など、$\frac{-b+\sqrt{b^2-4ac}}{2a}=\frac{-2c}{b+\sqrt{b^2-4ac}}$と変形することで桁落ちを避けられる。

\subsection{情報落ち}
リスト\ref{program3_1}の変数$c$に関する誤差は\textbf{情報落ち}\index{じょうほうおち@情報落ち}(loss of trailing digitsあるいはinformation loss)とよばれるものである。情報落ちはアンダーフローと似た原理で起こる誤差である。
\\ \\　
絶対値の大きい数に対し、絶対値のごく小さい数の加減を行う。計算後の値を浮動小数点表現すると、足された部分が元の数に比べて小さすぎて、仮数部への代入時に無視されてしまうことがある。これが情報落ちである。この処理は、例えば総和を行う場合などに出やすい(特に級数和の計算に出る情報落ちを\textbf{積み残し}と呼ぶ。)。
\\ \\　
原理から、情報落ちを回避するに法は絶対値の違いすぎる数の加減を避ければ良い。また、情報落ちの典型例である積み残しに対しては、誤差をうまく評価して適切に総和を計算する\textbf{Kahanの加算アルゴリズム}\index{Kahanのかさんあるごりずむ@Kahanの加算アルゴリズム}(Kahan summation algorithm)が知られている。

\subsection{計算機イプシロン}
情報落ちに関連して、\textbf{計算機イプシロン}(machine epsilon)についても紹介しておく。1より大きい最小の浮動小数点数$s$に対し、$\varepsilon=s-1$を計算機イプシロンという\footnote{$1+\varepsilon$が1と見なされなくなる最小の$\varepsilon$と説明される場合もある(本書でも最初そう書いていた)が、丸め処理によって値が変わってしまうことがあるため、厳密にはこの説明は誤りである。}。
\\ \\　
計算機イプシロンは環境及び型によって異なるが、limits.hにある値を用いることで調べられる。limits.h等の利用については付録(リファレンス)に譲る。

\subsection{打ち切り誤差}
リスト\ref{program3_1}のソースでは見られないが、\textbf{打ち切り誤差}(truncation error)と呼ばれる誤差も存在する。これは、コンピュータで数学の計算を行う際の近似のために無視された部分による誤差である。例えば、級数の和を用いた計算を行うとき、実際に無限の項を足し続けるわけには行かないので、途中何処かでやめることとなる。このとき、無視された部分は当然誤差となって効いてくる。これが打ち切り誤差である。これはパソコンの性質というより、アルゴリズムに依存するものであり、アルゴリズムの解析を行うことでその大きさを評価できる場合が多い。

\section{ビット演算}
コンピュータの数値表現にはビットが用いられていると述べた。場合によっては、そのビットを直接扱うことができると便利であろう。整数型についてこれを実現したのが、ビットを直接扱う\textbf{ビット演算}である(浮動小数点型には適用できない)。早速見てみよう。
\begin{boxnote}
%\begin{multicols}{2}
\minisec{IPv4 addressの解析}
IPアドレスは、32bitからなり、それを8桁ずつに区切って10進数に直され表現される。このうち、上位何ビットかはそのアドレスがどのようなネットワークに属するかを示す「ネットワークアドレス」である。これが何ビットかは「サブネットマスク」と呼ばれる数値で表される。例えば、サブネットマスクが12bit=255.240.0.0であるようなネットワークは、上位12ビットがネットワークアドレスである。これを用いて、IPアドレスは、a.b.c.d/nの形で表される。a,b,c,dは0以上256未満の整数で、n(サブネットマスクのビット数)は0以上32以下の自然数である。この形式で入力されるIPアドレスのネットワークアドレスを出力するプログラムを書く。
\begin{lstlisting}[caption=IPv4からネットワークアドレスを求める,label=program3_2]
#include<stdio.h>

int main(void){
  unsigned int ip;
  unsigned int a,b,c,d,n;
  unsigned int mask,tmp;

  scanf("%u.%u.%u.%u/%u",&a,&b,&c,&d,&n);
  ip=(a<<24)+(b<<16)+(c<<8)+d;
  mask=(-1<<(32-n));
  ip&=mask;
  tmp=(1<<8)-1;
  a=(ip>>24)&tmp;
  b=(ip>>16)&tmp;
  c=(ip>>8)&tmp;
  d=ip&tmp;
  printf("%u.%u.%u.%u\n",a,b,c,d);
  return 0;
}

\end{lstlisting}
%\end{multicols}
\end{boxnote}
解法で少し難易度が高いと思われる発想もあるのだが、何はともあれビット処理について理解しないことには話が進まないので、ビット処理について学んでいこう。
\minisec{各種のビット処理}
先に述べた整数のビット演算には、表\ref{bitope}のような種類の演算がある。
\begin{table}[!htb]
\centering
\caption{ビット演算子}\label{bitope}
\begin{tabular}{|c|c|c|c|}\hline
記法&意味&形式&種類\\ \hline
&&&\\[-15.5pt] \hline
\verb|&|&ビット毎論理積&\verb|a & b|&2項演算子\\ \hline
\verb/|/&ビット毎論理和&\verb/a | b/&2項演算子\\ \hline
\verb|^|&ビット毎排他的論理和&\verb|a ^ b|&2項演算子\\ \hline
\verb|~|&ビット毎否定&\verb|~a|&単項演算子\\ \hline
\verb|<<|&左ビットシフト&\verb|a << b|&2項演算子\\ \hline
\verb|>>|&右ビットシフト&\verb|a >> b|&2項演算子\\ \hline
\end{tabular}
\end{table}

各演算子は=を伴って代入演算子として用いることができる(リスト\ref{program3_2}の第11行等。)。なお、ビット演算子の優先順位は低く、掛け算や足し算を行う時は勿論、第5講で紹介する比較演算よりも後なので、順番には十分注意しなければならない。
\\　\\
　それでは、各演算について見ていくことにする。以下、簡単のため、$a=(1100)_2,b=(1010)_2$とする。

論理積は、\textbf{AND演算}\index{ANDえんざん@AND演算}とも呼ばれ、各ビットについて、ともに1ならば1を、それ以外の時ならば0を返す。例えば、$a\&b$は$(1000)_2$となる。

論理和は、\textbf{OR演算}\index{ORえんざん@OR演算}とも呼ばれ、各ビットについて双方が0でなければ1を、双方が0ならば0を返す。$a|b$は$(1110)_2$である。

否定は各ビットを反転する演算で、\textbf{NOT演算}\index{NOTえんざん@NOT演算}とも呼ばれる。\verb|~a|$=(0011)_2$,\verb|~b|$=(0101)_2$である。

排他的論理和は\textbf{XOR演算}\index{XORえんざん@XOR演算}\footnote{XORはeXclusive OR(排他的論理和)の略である。}とも呼ばれ、各ビットを見比べ、双方が違うビットならば1を、双方が同じビットならば0を返す。$a$\verb|^|$b=(0110)_2$となる。

左ビットシフト、右ビットシフトは、2進数において指定した桁数だけ左/右にずらすことを言う。$a$を左1ビットシフトすると$(11000)_2$と、右1ビットシフトすると$(110)_2$となる。なお、実際には、はみ出たビットは捨てられる。右ビットシフトには、符号ビットを含めて行われる論理シフトと、含めずに行われる算術シフトとがある。C言語では、右ビットシフトにどちらのシフトを採用するかは処理系定義である。
\\　\\　
これらの演算を用いると、例えば$2^n$などの計算を高速化できたり、コンピュータでよく用いられる2進数関連の計算をわかりやすく行うことができる。ビット演算は一般に四則演算よりも速いため、2倍するよりは1ビット左シフトする、偶数かどうか判定するためには剰余を利用するより1とAND演算する、といった等価な操作をビット演算によって記すことで、プログラムを高速化できることがある(ただし、最近は最適化の技術向上のため、必ずしもビット演算で書いたほうが速いとは限らない)。

\minisec{リスト\ref{program3_2}の解説}
ここまでの内容を踏まえて、リスト\ref{program3_2}が要求されたプログラムになっているかどうかを見ていこう。
\\　\\　
$l$.9においては、まず、32bitとしてひとつの変数にまとめる処理を行っている。これは、後の処理を楽にする目的であり、この処理により、32bitのint型変数一つで全て扱うことができるようになる。変数が順番に8bitずつ並ぶことがわかるだろう。

$l$.10はmaskの作成である。これは、上位$n$ビットが1、それ以下のビットが0であるような数である。整数型の-1のビットは全て1であり、0は全て0であることから、意図的にオーバーフローを起こして適切なビットに調整している。式について検証すると、これが正しくマスクを生成することがわかるだろう。

$l$.11で目的の処理を行い、これによってネットワークアドレスを取得することができる。後は、それを分けるため、tmpを作成し、順次分けていき、出力している。
\\　\\　
このように、ビット処理はIPv4アドレスの解釈などに利用できる。ビット処理は人間の視点からだと、使うことは稀のように思える機能であるが、コンピュータに根ざしている処理を行う上で非常に便利なものである。有効利用してほしい。

\section{数学関数と複素数演算}
パソコンは「計算機」であるから、様々な計算ができる。先までの演算の話とはうってかわって、今度はC言語による数学計算について見ていこう。
\subsection{数学関数の利用}
まず、実数(浮動小数点数)に関して、数学関数がどのように適用できるかを見ていくことにする。なお、この節には多数の新出関数があるが、その解説は付録A等を適宜参照されたい。
\begin{boxnote}
\minisec{対数関数の使用例}
視等級$m$等の恒星が地球より$d$(ly,光年)離れた場所にあるとき、その絶対等級$M$は
$M=m+5-5\log _{10}\frac{d}{3.26} $
によって与えられる。$m,d$が入力されるとき、その絶対等級を出力するプログラムを作成する。
\begin{multicols}{2}
\minisec{解法}
単純な計算問題であるが、対数関数が必要になる。指数対数関数や三角関数といった、演算子では用意されていない数学演算は\verb|math.h|というヘッダに入っている。

なお、このコンパイルにあたっては、
\verb|gcc filename -lm|
と、コンパイル時に末尾に\verb|-lm|オプションをつけなければならない。
\begin{lstlisting}[caption=絶対等級の計算,label=program3_3]
#include <stdio.h>
#include <math.h>

int main(void){
  double z,m,d;
  scanf("%lf",&m);
  scanf("%lf",&d);
  z=m+5-5*log10(d/3.26);
  printf("%f\n",z);
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
\minisec{数学関数利用の上で}
数学関数は、リスト\ref{program3_3}に見られるように、\verb|func(args)|等の形式で書けば、その値を返してくれる。そのため、数学関数を利用する場合は、通常の数学の式を書くのと同様に\verb|2*sin(x)|などと記せば良い。
\\ \\　
数学関数は\verb|math.h|に入っているため、利用する場合はこれをインクルードしなければならない。更に、\verb|math.h|内の関数を用いたC言語のソースをgccでコンパイルする場合、先に記したように\verb|-lm|オプション\footnote{lmはlink to math.hの略である。}を\underline{末尾に}
\footnote{gccのバージョンによっては、\verb|gcc -lm source -o output|のように、中間に\verb|-lm|オプションを付しても大丈夫な場合もある。ただ、必ず通るわけではないので、通常末尾にしておくほうが安全である。

この問題は、gccの引数解析及びリンカとスタティックリンク・ダイナミックリンクの差異などから起こっているものである。以下、簡単に解説を書いておく(ここまでの内容を逸脱している部分もある)が、詳しく知りたい場合は「エキスパートCプログラミング」(P.Linden著,梅原系訳,ASCII,1996)などを参照されたい。なお、以下がわからなくとも、末尾においてさえいれば実害はない。

スタティックリンクは、ライブラリそのものが実行ファイルに組み込まれる方法である。一方で、ダイナミックリンクは実行時に都度引いてくるリンク方法である。ダイナミックリンクの場合、実行速度に劣るが、サイズが小さい実行ファイルが生成される。数学関数のライブラリ\verb|math.h|(リンク先の実体は\verb|libm|というライブラリ)は、実行速度を優先する場合が多いため、スタティックライブラリとして提供されている。

スタティックリンクとダイナミックリンクの違いは、コンパイル時にも及ぶ。ダイナミックリンクの場合は、一旦メモリにライブラリを持ってきて、それをひと通り関連付ける。一方で、スタティックリンクは、ライブラリの検索が始まる段階で「未定義である」となっているシンボル(関数、マクロなど)に対してのみ、ライブラリのオブジェクトが関連付けられる。つまり、スタティックリンクの場合、リンクを行う前の段階で、ソース中にある全未定義シンボルを洗い出しておかないといけない。

ここで、\verb|-lm|をソースファイルの前においた場合、前から順に引数解析を行うと、"\verb|math.h|にリンクをする"$\rightarrow$"ソース中を解釈する"となってしまい、未定義シンボルが残ってしまう。後ろに置けば、この問題は解決する。前に付して上手くいっているのは、引数解析の際にスタティックリンク処理を最後にまわすように考えられているか、あるいは\verb|math.h|に対して自動でリンクが張られるように設定されているかの何れかである。これらの設定は前提にできるほどのものではないため、リンクオプションは末尾につけたほうが良いのである。

なお、この説明からわかるとおり、この問題は\verb|math.h|に限った話ではなく、一般のライブラリにも起こりうるものである。本書で扱う中では、\verb|math.h|関連で最初に出てきた問題であるので、ここに記述した。}付さねばならない。


数学関数を利用するにあたっての注意点を記しておく。
\begin{itembox}[l]{math.hの関数の一般の注意点}
\begin{itemize}
\item 大抵の関数は一般性を失わない範囲で適切に設定されているため、自作の関数のほうが速かったり誤差が小さかったりする場合は稀である。但し、扱うデータの特殊性によっては、より適切にできる場合も少なくない。
\item 浮動小数点数を扱う以上、丸め誤差を始めとして各種の計算誤差は避けられない。したがって、誤差に関する処理を施したり、最悪の場合、目的に応じて(速度等を落としてでも)自作のルーティンを用いたほうが良い場合もある。(さすがにそんなケースは稀なように思えるが)
\end{itemize}
\end{itembox}
\\ \\　
また、個々の関数において、自作関数のほうが良い場合が(math.hに限らず)存在する。ここでは、数学関数における代表例を示そう。
\begin{itembox}[l]{math.hの関数で不利になることがある関数の例}
\begin{itemize}
\item pow関数は実数用に作られているので、整数乗を計算する場合は、後に学ぶ文法と繰り返し自乗法を適切に用いて自作で関数を用意したほうが速い。
\item fabs関数は実数向きであり、整数向きの関数はstdlib.hにabs関数あるいはlabs関数として用意されている。また、これらの関数は、後に学ぶ関数マクロを用いて定義し、型依存性をなくして用いる場合も多い。
\item 正の数に対するfloor関数や、負の数に対するceil関数は、「浮動小数点数型を整数型にキャストした場合0方向に丸められる」という性質のため、整数型へのキャストによっても実装できる。したがって、結果を整数型に代入する場合は、キャストを用いることもある。
\end{itemize}
\end{itembox}
　ここに述べた以外にも、速度やメモリなど、何らかに特化させる必要がある場合は、自作の関数に置き換えたほうが良い\footnote{なお、標準関数を自作の同名の関数で置き換え、再定義することを、\textbf{インターポジショニング}\index{いんたーぽじしょにんぐ@インターポジショニング}(interpositioning)と呼ぶ。これは実に強力であるが、意図しない場合に悲惨な結果をもたらすこともある危険な機能である。それゆえ、ここで言う置換えも、同名ではなく、別名の関数で置き換えたほうが良い(つまり、標準関数との衝突を避けて、別名で定義しておくほうが良い)。このインターポジショニングという機能は、本書レベルでは必要ないが、「自作関数での置換え」について述べたため、ここに記した。}場合もある点、注意しておこう。但し、一般の用途においては、通常はライブラリ関数のほうが良い。これは、ライブラリ関数が広い汎用性のもとでできる限り最適化されているためである。

なお、数学関数の実装は、当該関数をMclaulin展開した級数の計算である場合が多い。そのため、計算にはある程度時間がかかるという事も知っておくと良い。

\minisec{数学関数の型}
数学関数の引数の型は、通常doubleである。C言語ではfloat型やchar型、short型を用いても、内部的にはdouble型やint型として扱われる場合が多いため、floatにdouble型の関数を用いても多分問題はない(暗黙の型変換が行われるため、精度が失われることもないと考えられる)。だが、long doubleを用いる場合には、問題が出てくる可能性もある。

そこで、各々の関数の名前の後ろにfやlを付し、名前の後ろにfを付した関数はfloat型として、lを付した関数はlong double型として用いるようにした\footnote{この機能ができたのはC99であるため、一部のコンパイラでは機能しない場合がある。例えば、Visual Studioやバージョンが古いgccでコンパイルできない場合がある。}。したがって、先のプログラムをlong doubleに書き直したい場合は、log10l関数を用いれば良い\footnote{この「分けて書かないといけない」現象を解決するのがこのあと取り上げるtgmath.hである。}。

数学関数に限らず、C言語の浮動小数点演算はdouble型が基本であるため、特別な理由がなければ、浮動小数点型にはdouble型を用いると良い。同様に、整数にはint型を、文字にはchar型を用いるのが一般的である。

\subsection{複素数演算と型総称数学関数}
C言語は1999年の改訂により、数学関連の機能が大幅に強化された。この強化された機能を見ていこう。
\begin{boxnote}
\minisec{ド・モアブルの定理の確認}
ド・モアブルの定理は、次のような定理である。
\[(\cos\theta+i\sin\theta)^n=\cos n\theta+i\sin n\theta\]
但し、$\theta,n$は実数、$i=\sqrt{-1}$とする。この成立を確認する。
\begin{lstlisting}[caption=ド・モアブルの定理,label=program3_4]
#include<stdio.h>
#include<math.h>
#include<complex.h>
#include<tgmath.h>

int main(void){
  double theta,n;
  double complex a,b;
  scanf("%lf %lf",theta,n);
  a=cos(theta)+I*sin(theta);
  a=pow(a,n);
  b=cos(n*theta)+I*sin(n*theta);
  printf("a=%f+%fi\n",creal(a),cimag(a));
  printf("b=%f+%fi\n",creal(b),cimag(b));
  return 0;
}
\end{lstlisting}
\end{boxnote}

ド・モアブルの定理は複素数に関する定理であるので、当然ながら複素数演算を利用している。このソースを読み解いていこう。

\minisec{複素数型と虚数型}
通常、複素数型の宣言には、\verb|_Complex|型を、虚数を用いる際には\verb|_Imaginary|型を用いる。だが、\verb|complex.h|のインクルードによってこれらの型を\verb|complex|ないし\verb|imaginary|と記述できるようになる。この方がわかりやすいため、\verb|complex.h|を用いて宣言する場合が多い。これを踏まえて、リスト\ref{program3_4}の8行目を見てみると、\verb|complex|の前に\verb|double|がついていて、よくわからない。
\\ \\　
複素数型は、内部的には2つの浮動小数点数型により実現されている(虚数型は1つ)。先に学んだ通り、浮動小数点型には精度によって3つの型がある。これが複素数や虚数にも適用される。\verb|double complex|は実部および虚部が各々\verb|double|の精度を持った複素数型変数であり、\verb|long double imaginary|は実部が0で虚部が\verb|long double|の精度を持つ純虚数を表す型である。このように、複素数/虚数の宣言の際には、その精度を指定しなければならない。

\minisec{複素数型/虚数型の型変換}
複素数型、虚数型も通常の浮動小数点型などと同じように扱うことができるが、型変換関連では注意する必要がある為、ここに述べる。なお、以下では区別のために、\verb|float|や\verb|double|を総称して実数型と呼ぶことにする。
\\ \\　
複素数型は実数型、虚数型の双方よりも広い範囲を表す型である。このため、二項オペランド\footnote{\textbf{オペランド}\index{おぺらんど@オペランド}(operand)はプログラミングにおいて演算の対象となる値や変数のことを指す。和訳される場合は通常\textbf{被演算子}\index{ひえんざんし@被演算子|see{オペランド}}とされる。これは、演算子(operator)に対して、その効果を受けるという意味からの訳である。}の一方が複素数型である場合、その計算結果は複素数型になる(暗黙の型変換である)。なお、\verb|complex.h|をインクルードしない場合、四則演算において演算例外が起きる場合があるので、インクルードすることを推奨する。
\\ \\　
虚数型はやや複雑な型変換体系を持つ。虚数型同士の積/商は実数型になる。一方、実数型と虚数型の積/商は虚数型である。和・差については、虚数型同士の場合虚数型のままであるが、実数型と虚数型との間で行った場合、その結果は複素数型になる。具体的に、リスト\ref{program3_4}の10行目について、型変換の手順を見てみよう。なお、リスト\ref{program3_4}中に出てくる\verb|I|は虚数単位($\sqrt{-1}$)を表す定数(定数マクロ)であり、虚数型である。
\begin{enumerate}
\item \verb|I*sin(theta)|は虚数型と実数型の積なので、虚数型の結果になる。
\item \verb|cos(theta)+I...|は、実数型と虚数型の和なので、複素数型の結果になる。
\end{enumerate}

上記のように、暗黙の型変換は比較的数学に近い形で行われるようになっているが、キャストはやや面倒である。表\ref{comp_cast}に、実数型、虚数型、複素数型の各キャスト結果をまとめた。
\begin{table}[htb]
\centering
\caption{実数型・虚数型・複素数型の間のキャスト}\label{comp_cast}
\begin{tabular}{|c|c|c|} \hline
キャスト元&キャスト先&結果\\ \hline
&&\\[-15pt] \hline
実数型&虚数型&値が0の虚数型\\ \hline
実数型&複素数型&実部が元の値、虚部が0の複素数型\\ \hline
虚数型&実数型&値が0の実数型(\verb|_Bool|のみ例外(後述))\\ \hline
虚数型&複素数型&実部が0、虚部が元の値の複素数型\\ \hline
複素数型&実数型&元の数の実部を値とする実数型\\ \hline
複素数型&虚数型&元の数の虚部を値とする虚数型\\ \hline
\end{tabular}
\end{table}

\minisec{複素数関数}
複素数の演算にも、それ専用の関数があり、\verb|complex.h|に収められている。このヘッダの詳細は付録を見てもらえばよいが、以下のような法則だけを紹介しておく。
\begin{itembox}[l]{complex.h内の関数の命名法則}
\begin{itemize}
\item 実数型に同様の機能の関数がある場合(sin等)、その複素数型のものは関数名の先頭にcをつけたもの(csin等)になる。
\item 複素数型関数にも精度による別があり、数学関数と同様の命名規則になっている(csinf,csin,csinl等)。
\end{itemize}
\end{itembox}

\minisec{型総称数学関数ヘッダ}
ここまでで、実数にも複素数にも同じ機能のある関数は、その型に応じて6種類を使い分ける必要があることがわかる(例えば、正弦関数の場合、実数型のsinf,sin,sinlがあり、複素数型のcsinf,csin,csinlがある)。だが、これらをわざわざ分けて書くのは、読みづらい上に書く側としても面倒である。そこで、こういった例を統一的に扱うことができるように、JavaやC++では同名ながら引数の型/個数が違う関数を定義できるようにした。これを\textbf{多重定義}\index{たじゅうていぎ@多重定義|see{オーバーロード}}ないし\textbf{オーバーロード}\index{おーばーろーど@オーバーロード}(overloading)と呼ぶ。だが、残念ながら、Cにはこの機能が存在しない。
\\ \\　
とはいえ、マクロ/プリプロセッサ文を上手く使うことで、C言語のソースでも似たような機能を実現できる(また、C11ではそのような機能が充実した)。C99まででは、言語としてのオーバーロード機能はないものの、コンパイラの機能に頼ることでそれに近い効果を得られる。C言語の標準関数のうち、ここで紹介した\verb|math.h|および、次に紹介する\verb|complex.h|については、\verb|tgmath.h|\footnote{これは、 Type-generic mathの略である。}でこの機能が提供されているため、これをインクルードすればいちいち使い分けなくてすむようになる。

例えば、リスト\ref{program3_4}の11行目であるが、これは引数・返却値とも\verb|double complex|型であるので、本来は\verb|cpow|関数であるはずである。だが、ここでは\verb|pow|と書いて通用している。これが\verb|tgmath.h|の効用である。
\\ \\　
\verb|tgmath.h|を利用する際に置き換える名前は、\verb|math.h|にも\verb|complex.h|にも共通する機能の関数ないし、\verb|math.h|のみの関数である場合は、\verb|math.h|の\verb|double|型関数の形で書く(sin,pow等)。\verb|complex.h|にしか関わらない関数は、cをついた名称で書く(creal,cimag等)。
\\ \\　
ここまで長々と書いてきた数学関連の関数の機能をまとめておく。
\begin{itembox}[l]{数学関連機能のまとめ}
\begin{itemize}
\item \verb|math.h|を用いている際には\verb|-lm|オプションを末尾につけてコンパイルすること。
\item 複素数演算を用いる際には\verb|complex.h|をインクルードすること。
\item 必要に応じて\verb|tgmath.h|をインクルードし、可読性を向上させること。極論、\verb|math.h|、\verb|complex.h|、\verb|tgmath.h|を常にセットでインクルードしても良い。
\end{itemize}
\end{itembox}
\newpage

\begin{shadebox}
\section*{本講の要点}
本講では、前講で学んだ変数を活用し、連接構造で更に多くの計算処理を行う手法を学んだ。
\subsection*{計算誤差}
\begin{itemize}
\item コンピュータで浮動小数点数の演算を行う場合、その内部表現やアルゴリズムなど故に、様々な計算誤差が出る。
\item 丸め誤差は不可避であるが、桁落ちや情報落ちはその原因となる計算をなくすことで避けることができる。
\item 打ち切り誤差はアルゴリズムに依存する誤差で、アルゴリズムからある程度見積もることができ、アルゴリズムの改良によって小さくすることができる。
\item 計算機イプシロンとは1以上の最小の浮動小数点数から1を引いた値のことである。
\end{itemize}

\subsection*{ビット演算}
\begin{itemize}
\item ビット演算は整数型のみに適用される演算で、AND,OR,XOR,NOT,ビットシフトなどの演算がある。
\item ビット演算は通常の四則演算よりも負荷が少ないため、等価な四則演算をビット処理に置き換えることで、プログラムの高速化が期待できる。
\end{itemize}

\subsection*{数学関連機能}
\begin{itemize}
\item 数学的な演算を行う関数は\verb|math.h|に収められている。
\item \verb|math.h|を用いている際には\verb|-lm|オプションを末尾につけてコンパイルする。
\item 複素数演算を用いる際には\verb|complex.h|をインクルードする。
\item \verb|math.h|、\verb|complex.h|、\verb|tgmath.h|を常にセットでインクルードしておくと、似たような機能の関数を型に応じて書き分ける必要がなくなり、読みやすいソースになる。
\item これらのヘッダで定義される関数は\verb|func(args)|等の形式で呼び出すことで、その計算結果をそのまま値として返却するので、式中に直接書けば良い。
\end{itemize}
\end{shadebox}

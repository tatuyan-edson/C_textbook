本講では関数について学ぶ。\textbf{関数}\index{かんすう@関数}(function)とは、引数をとって、ある一定の処理を行い、返却値を返すものである(引数が無かったり返却値が無かったりするものもある)。実際、printfやrandなどは引数を取り、返却値を返す関数である。だが、これらC言語に標準搭載されている関数(\textbf{標準関数}\index{ひょうじゅんかんすう@標準関数})だけでは物足りないこともある。例えば、暗号化や数論でよく使われる素数の判定関数は標準関数としては提供されていない。だが、素数の判定は多くの目的で用いられるため、関数として準備し、使い回したほうが効率的にプログラミングできる。このような、自作の関数を作る方法の基礎を見ていく。とはいえ、main関数も自作関数であるので、この講で扱う自作関数とは、厳密には「main関数以外の自作関数」である。
\\ \\　
また、関数の作成に必要な「スコープ」「寿命」などについても学習し、それと関連の深いプリプロセッサについても説明する。

\section{関数の呼び出しと利用}
実際の関数を作る前に、ざっと復習しておこう。

既存の関数を呼び出す際には、次のように行った。
\begin{itembox}[l]{関数の呼び出し}
関数を呼び出す際には、関数を呼び出す場所で
\begin{code}
関数名(引数)
\end{code}
のように記す。
\end{itembox}

これにより、既存の関数の値(ないし処理)を利用することができた。このように、名前を書いて呼び出すためには、関数そのものの定義が必要であるが、これはヘッダファイル及びその機能を提供するライブラリによって行われている。

したがって、自作関数を利用する際には、ヘッダファイルやライブラリで行われているようなことをソースに埋め込み(ないし、ヘッダやライブラリを自作し)、後は上記の\verb|関数名(引数)|の形式で呼び出せばよい。

\subsection{関数化の意義}
ここで、改めて関数化する理由を考えてみよう。

我々は既に複数の関数を用いている。仮に、これらがなかったとしたらどうなるだろうか。例えば、math.hのceil関数を考えてみよう。

誤差がなく、絶対値が極端に大きくないとすれば、ceil関数は、
\begin{code}
(double)(int)x+(x-(int)x>0)?1:0;
\end{code}
のような一文で実装することができる。だが、この一文を見てすぐさま"これはceil関数の処理だ！"とわかるだろうか。ceilという名前をつけておいたほうがわかりやすいのではないだろうか。また、誤差や絶対値が大きい場合にはこの方法は通用しないので、別の実装が必要になる。これをいちいち組むのは面倒であるばかりでなく、腕による違いも出てきてしまう。そもそも、そのような場合にどう実装すればよいか、すぐに思いつくだろうか。これらの実装がceilの一言ですむのであれば、そちらのほうが余程わかりやすいだろう。
\\ \\　
このように、関数化をすることは
\begin{itemize}
\item 可読性を上げる。(どんな処理かが明確になりやすい)
\item 似たような処理を書くときなどに面倒でない。(使い回しが可能である)
\item 内部が厳密にわからなくても使うことができる(処理のブラックボックス化)
\end{itemize}
等、多くの利点がある。この内、我々が自作関数を使う場合は、主に前の2つの理由をもって、自作関数を作ることになる。

熟達したプログラマは、自分がよく使う関数をライブラリとしてまとめて持っている場合も多い。これはまさに、前の2点の利点のためのものといえよう。

\subsection{関数の要素}
冒頭で説明したとおり、関数には大きく分けて3つの要素がある。
\begin{description}
\item[引数] 関数に渡すべき値。
\item[処理] 関数の中でどのようなことが行われているかという動作。
\item[返却値] 関数において処理が行われた後に返される値。
\end{description}

この内、引数には関数の定義の際に用いられる\textbf{仮引数}\index{かりひきすう@仮引数}(parameter)と、実際の呼び出しの際に用いられる\textbf{実引数}\index{じつひきすう@実引数}(argument)とがある。これらについては、後で自作関数を作る際に実例を伴って理解して欲しい(その際に再度紹介する)。
\\ \\　
一方で、関数の処理には、返却値以外にも後に影響を与えるものが存在する。例えば、srand関数は返却値を持たないが、randの呼び出しに影響を与える。このように、返却値以外で関数が処理によってコンピュータの状態等に与える影響を\textbf{副作用}\index{ふくさよう@副作用}(side effect)と呼ぶ。関数によっては、返却値より副作用に重きを置かれることもあり(printf関数やscanf関数など)、そもそも返却値がなく副作用目的の関数も存在する(先にあげたsrand関数など)。このような副作用目的の関数は「引数をとって何らかの処理を行い、その返却値を返す」という関数本来の説明よりも、「引数をとって、それに応じて動作する」という、ある種の「操作」と捉えたほうが理解しやすいかもしれない\footnote{実際、言語によっては返却値を返すようなものを関数と、操作を目的とするものをサブルーチンとして分けているものもある(Fortran等)。}。

\section{自作関数の利用}
では、ここまで前置きが長かったが、実際に関数を作成してみることにしよう。ここでは、比較的汎用性が高い「素数の判定関数」を考える。
\begin{boxnote}
\begin{multicols}{2}
\minisec{素数の全列挙}
入力される自然数$n$までの素数をすべて出力するプログラムを作成する。
\minisec{解説}
素数を判定する関数はisPrimeとして作成した。この関数の内部の実装は「2以上の自然数$p$が素数かどうか判定するには、$\sqrt{p}$未満の全ての素数で割り切れるかどうか判定すればいい」を弱め、「$\sqrt{p}$未満の全ての奇数及び2で割り切れなければいい」を用いた。

一方、main関数においても、簡単のため偶数を無視して、奇数だけを判定するように書いてある。すなわち、isPrime関数は一般化されたものであるが、その呼び出し回数を減らし、無駄な計算を避けるために、main関数でも工夫を凝らしているということである。

なお、紙面の都合上、forやifで\verb|{}|を省いた書き方を多用している。

\begin{lstlisting}[caption=素数の判定,label=program6_1]
#include<stdio.h>
#include<stdbool.h>

typedef unsigned int u_int;

bool isPrime(u_int p);

int main(void){
  u_int n,i;
  scanf("%u",&n);
  if(n>=2) puts("2");
  for(i=3;i<=n;i+=2)
   if(isPrime(i)) printf("%d\n",i);
  return 0;
}

bool isPrime(u_int p){
  u_int i;
  if(p==2)
   return true;
  else if(!(p%2) || p<=1)
   return false;
  for(i=3;i*i<=p;i+=2)
   if(!(p%i)) return false;
  return true;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

新出文法が多いソースであるので、新出文法事項毎に説明していこう。

\subsection{自作関数の作成方法}
まず、ここまでに議論してきた自作関数の実例を見ていくことにしよう。リスト\ref{program6_1}において、自作関数として作られているのは、$l$.17から$l$.26のisPrime関数である\footnote{冒頭にも書いたが、厳密にはmain関数も自作関数である。}。これを見てもらえばわかるとおり、関数はmainと同じように、\verb|{}|で囲まれており、その前に引数リストが、その前に名前があって、その前に型が書かれている。main関数も同様の形式で書かれており、関数の実装の際にはこの形式を守らなければならないことがわかる。以上をきちんとまとめると、次のようになる。
\begin{itembox}[l]{自作関数の実装}
自作関数を実装する際には
\begin{code}
返却値の型 関数名(引数リスト){
  処理
}
\end{code}
の形で記す。
\end{itembox}
この、「処理」の部分の書き方はmain関数と同じであるので、省略してよいだろう。残りの「返却値」「関数名」「引数リスト」について説明していこう。
\minisec{自作関数の返却値}
返却値について押さえておくべきことは、その型と決定方法である。
\\ \\　
返却値の型は変数の型と同じように書くことができるが、変数の型には存在しない\verb|void|\index{void@void}というキーワードがある。これは、「返却値なし」を意味する。すなわち、先に説明した「処理のみを目的とする関数」などで使われる型である。たとえば、isPrime関数では、返却値の型はbool型である。

なお、返却値の型を省略した場合、勝手に型を定めるコンパイラもある\footnote{試しに、適当なプログラムについてmain関数の前のintを省略してみよう。問題なく動作するはずである。(とはいえ、main関数は特別扱いという処理系もあるが)。}が、とりわけ自作関数の場合は型がないと分かりづらいため、必ず型を書く癖をつけておくこと。また、返却値の型は関数を代表する型であるため、一般には関数の型と呼ばれる。「関数の型」という場合「関数の返却値の型」と補って理解すればよい。
\\ \\　
これらによって、返却値の型が定まったら、後は具体的に返却値を定めればよい。
\begin{itembox}[l]{返却値の決定}
返却値は、
\begin{code}
return （返却値);
\end{code}
の形式で定める。この返却値には変数や計算式を指定してもよい。
\end{itembox}

関数は、返却値が定まった時点(=returnが実行された時点)で、その処理を終了し、呼び出し元に戻る。すなわち、returnは返却値を定めるだけでなく、関数の終了を示す役割も果たしているわけである。isPrimeの中には沢山のreturnが書かれているが、このうちのどれか一つが実行された段階で関数の処理は打ち切られ、呼び出し元に返却値が返されることになる。

この「関数を終了させる」という役割のため、void型関数でもreturnが用いられることがある。この場合は単に
\begin{code}
return;
\end{code}
とだけ書かれ、それが実行された段階で関数の処理が打ち切られる。
\\ \\　
なお、返却値はどのような関数についても1つまでしか持てない。2つ以上の値を返したい場合、後に学ぶ構造体を用いて2つ以上の値を変数1つに見せかけたり、副作用を利用して返却したりといった工夫が必要になる。
\minisec{関数名について}
自作関数の名前は\textbf{識別子}\index{しきべつし@識別子}(identifier)の一種であるので、変数名の命名規則の時に説明したようなルールを守らなければならない。また、似たような処理を行う関数であっても、関数名は明確に違うものをつけなければならない\footnote{一方、JavaやC++では、引数の型や個数が違えば、同じ名前の別の関数を作ることができ、呼び出し側の与えた引数に応じて自動的にどの実装を呼び出すかを決定して実行してくれる。これを関数の\textbf{多重定義}ないし\textbf{オーバーロード}\index{おーばーろーど@オーバーロード}(overload)と呼ぶ。C言語でこれと似たような機能を実装する場合には、後述するマクロを用いるか、C11の新機能を用いるかといった手段がある。似た機能を提供するtgmath.hでも、その内部実装にはマクロを用いている。}。これは、math.h中のsin関数が、sinf,sin,sinlの3つに分かれているということからもわかるだろう。

\minisec{引数について}
関数の引数は、関数名の後の()に、コンマ区切りで記す。一つ一つの引数には型をつけ、変数の宣言と同様の形式で記す。
\begin{itembox}[l]{引数リスト}
関数の引数は
\begin{code}
関数型 関数名(引数1の型 引数1の識別子,引数2の型 引数2の識別子,…)
\end{code}
の形式で記す。
\end{itembox}
実際、引数リストの各引数は、その関数の実装において用いられる変数の宣言でもある。つまり、引数として()内に記された各変数は、呼び出しの際に呼び出し元の値で自動的に初期化される、関数内のみで通用する変数であるということである。このように、関数の定義において用いられる引数を\textbf{仮引数}\index{かりひきすう@仮引数}(parameter)と呼び、呼び出しの際に呼び出し元の値が代入される点を除いては変数と同じ扱いができる。一方で、呼び出し元の関数の引数のことを\textbf{実引数}\index{じつひきすう@実引数}(argument)と呼ぶ。

先のリスト\ref{program6_1}において、仮引数は$l$.17の\verb|p|であり、実引数は$l$.13の\verb|i|である。なお、これらの型の\verb|u_int|は見たことがない型であろうが、これについては後で説明する。同様に、$l$.6についても後述する。
\\ \\　
仮引数と実引数において重要なのは、「仮引数はあくまでも実引数とは別の変数であって、値が代入されるだけである」ということである。別の変数であるため、関数中で仮引数をインクリメントしたりしても、実引数(=元の呼び出し側の引数)には影響しない。このように、仮引数に値をコピーするような引数の渡し方を\textbf{値渡し}と呼ぶ。C言語では、一部の例外を除き、関数への引数の渡し方は値渡しである\footnote{後に習うポインタを用いると\textbf{ポインタ渡し}\index{ぽいんたわたし@ポインタ渡し}の関数も作ることができるが、これは単にポインタの値を渡しているだけ=「ちょっと変わった型の」値渡しであるので、本質的にはこれだけといってしまってもいいかもしれない。配列渡し、関数ポインタ渡しなど少し怪しい(値渡しのように見えない)渡し方もあるが、これらも「特殊な型の」値渡しと考えられる。それ故、C言語には原則値渡ししかないと思っていいだろう。}\footnote{C++などでは、値渡しだけでなく、変数の実体そのものを渡すような\textbf{参照渡し}\index{さんしょうわたし@参照渡し}もある。C言語で参照渡しをするためには、後に学ぶポインタを用いたポインタ渡し(=ポインタの値渡し)を用いる。}。この仕ようにより、関数内で気軽に仮引数をいじることができるが、反面、実引数に影響を及ぼすような関数は別の方法を用いて作る必要が出てくる。

\subsection{関数プロトタイプ宣言}
ここまでで、自作関数の作成方法について説明したが、リスト\ref{program6_1}の新出文法はこれだけではない。今度は$l$.6の関数の宣言らしきものについて見ていこう。
\\ \\　
この$l$.6の宣言は\textbf{関数プロトタイプ}\index{かんすうぷろとたいぷ@関数プロトタイプ|see{プロトタイプ宣言}}(function prototype,関数原型\index{かんすうげんけい@関数原型|see{プロトタイプ宣言}}とも)ないし、\textbf{プロトタイプ宣言}\index{ぷろとたいぷせんげん@プロトタイプ宣言}(prototype declaration)という宣言である。

通常、ソースは上から読まれる。これは、コンパイル時も同様で、変数や関数は、それが使われるより上で宣言しなければならない(後でより詳細に説明する)。ところが、main関数より上で、必要な関数ばかり書いていると、最も重要であるmain関数が下の方に来てしまい、可読性を損なうことになりかねない。そのため、main関数より上で「このような引数を取り、型が〜〜〜の関数***を使います」と宣言のみ行い、定義はmain関数より下に記す、という方法を取るのが一般的である。
\begin{itembox}[l]{プロトタイプ宣言}
自作関数を用いる際には、main関数より前に
\begin{code}
関数型 関数名(引数1の型 引数1の識別子,引数2の型 引数2の識別子,…);
\end{code}
という形で宣言のみしておき、これと同じ形でmain関数より後に実態を定義する部分を書く。(引数の識別子は付さなくても良い)。
\end{itembox}

ここで出された$l$.6の宣言がisPrime関数のプロトタイプ宣言であり、この宣言があるためにmain関数の中にあるisPrimeがコンパイルエラーにならないのである(試しに、コメントアウトしてコンパイルすると、コンパイルエラーになるだろう)。

\subsection{型の別名定義}
名前が長い型を何度も使わなければならない場合、煩わしいと感じる場合が出てくる。例えば、
\begin{verbatim}
unsigned long long func(unsigned long long par1,unsigned long long par2);
\end{verbatim}
などという関数を打てと言われたらどうだろうか。打つのも面倒であるし、また、読みづらくもある。

そこで、型の別名を定義できるようにしたのがtypedefという修飾子である。
\begin{itembox}[l]{型の別名定義}
ある型に別の名前を付けたい場合
\begin{code}
typedef 元の型 別名;
\end{code}
の形式で記す。
\end{itembox}

先に出した例において、プログラム冒頭で
\begin{code}
typedef unsigned long long ull_int;
\end{code}
などとしておけば、関数は
\begin{code}
ull_int func(ull_int par1,ull_int par2);
\end{code}
とずいぶん短くなり、読みやすくなる。これが型の別名定義で、通常はインクルードなどが終わった後(あるいはヘッダファイル)に記し、プログラム全体で使えるようにする。

リスト\ref{program6_1}では、\verb|unsigned int|が長いため\verb|u_int|として、読みやすくしたわけである。

\section{スコープと寿命}
リスト\ref{program6_1}には、2ヶ所も\verb|i|という変数が登場している。これはどこで通用するのだろうか。また、isPrimeの中の\verb|i|は何度も呼び出されるわけだが、その都度前の値を保持していたりはしないのだろうか。本節ではこの問題について議論する。
\subsection{オブジェクトのスコープ(有効範囲)}
何らかのオブジェクト(変数、関数、後述のマクロなど)には、\textbf{スコープ}\index{すこーぷ@スコープ}(scope)ないし\textbf{有効範囲}\index{ゆうこうはんい@有効範囲}というものが定まっている。これは、そのオブジェクトを(ソース上の)どこから呼び出せるか定まっているという事である。リスト\ref{program6_1}の$l$.9の\verb|i|はmain関数の中でしか通用しないし、$l$.18の\verb|i|はisPrime関数の中でしか通用しない(つまり別物であるという事)。このように、オブジェクト毎に定まっている「ソースのどこからアクセスできるか」の範囲のことをスコープと呼んでいる。
\\ \\　
オブジェクトのスコープは一般に次のとおりである。
\begin{itembox}[l]{一般オブジェクトのスコープの性質}
\begin{itemize}
\item オブジェクトのスコープは、それが宣言されたより後の部分である。宣言前のオブジェクトは使えない。
\item 何らかの節(\verb|{}|で囲まれた部分及び、if,for等の構造を作る節)の中で宣言されたオブジェクトは、その節及びそれよりも深い階層のネストでしか通用しない。
\item 同一名のオブジェクトのスコープが重複した場合(通常避けるべきである)、よりスコープが狭い側のオブジェクトが優先される。
\end{itemize}
\end{itembox}

簡単に言えば、ある\verb|{}|内で宣言されたとして、その宣言以降で、宣言した階層の\verb|{}|の終わりが来るまで、というのがスコープである。スコープの外では、そのオブジェクトにアクセスしようとしても、そのようなオブジェクトは存在しないという意味のコンパイルエラーが出る。

\minisec{宣言とスコープ}
ここまでの解説から、変数の宣言や関数のプロトタイプ宣言の意味を再考してみよう。

変数は宣言することにより、それを使うことができるようになった。これは、変数にスコープを付与することに他ならない。一方で、関数のプロトタイプ宣言は、実体定義を呼び出しよりも後で行う際に「そんな関数はない」と言われるのを防ぐため行うと書いた。しかし、先のスコープの性質に照らし合わせてみれば、何のことはない、関数プロトタイプ宣言は「定義とは別の宣言」であり、スコープを決めるための通常の宣言と何ら変わりない役目を果たしているのである。
\\ \\　
定義と宣言の違いは、ここまでの内容ではあまり良くわからなかっただろうが、スコープの概念を取り入れれば明解になる。
\begin{itembox}[l]{定義と宣言}
\begin{description}
\item[宣言\index{せんげん@宣言}(declaration)] あるオブジェクトのスコープを定める動作。
\item[定義\index{ていぎ@定義}(definition)] あるオブジェクトがどのような動作をするか定めてメモリ上に確保する動作。
\end{description}
\end{itembox}

最後に、スコープの違いがよくわかるソースをひとつ試して、1ソースの場合のスコープの解説を終わろう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{グローバル変数とローカル変数}
ソースの全ての関数で通用する変数(\textbf{グローバル変数}\index{ぐろーばるへんすう@グローバル変数}ないし\textbf{大域変数}\index{たいいきへんすう@大域変数|see{グローバル変数}})と、ある関数の中でしか通用しない変数(\textbf{ローカル変数}\index{ろーかるへんすう@ローカル変数}ないし\textbf{局所変数}\index{きょくしょへんすう@局所変数|see{ローカル変数}})の違いを見てみる。スコープを考えて動作結果を見てみよ。
\begin{lstlisting}[caption=変数のスコープの違い,label=program6_2]
#include<stdio.h>

int n;
void func(int x);

int main(void){
  int x;
  scanf("%d %d",&n,&x);
  printf("1:%d %d\n",n,x);
  func(x);
  printf("4:%d %d\n",n,x);
  return 0;
}

void func(int x){
  printf("2:%d %d\n",n,x);
  n++;
  x++;
  printf("3:%d %d\n",n,x);
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

\subsection{変数の寿命}
先に解説したスコープは「リスト\ref{program6_1}には、2ヶ所も\verb|i|という変数が登場している。これはどこで通用するのだろうか。」という問いに対する答えであった。もうひとつの疑問「isPrimeの中の\verb|i|は何度も呼び出されるわけだが、その都度前の値を保持していたりはしないのだろうか。」の答えを説明するのが変数の寿命である。
\\ \\　
変数は通常、宣言されると同時にメモリ上に確保されるわけだが、これはいつ取り除かれるのだろうか。この、「メモリ上に変数が確保されている期間」のことを\textbf{変数の寿命}\index{へんすうのじゅみょう@変数の寿命}(variable extentまたはvariable lifetime)という。変数の寿命とスコープは誤りやすいので、以下に違いをまとめておこう。
\begin{itembox}[l]{スコープと寿命の差異}
\begin{description}
\item[スコープ] ソースないしプログラムにおいて、どの部分からそのオブジェクトを呼び出すことができるかという「ソース上での位置」の意味での有効範囲。
\item[寿命] 変数がいつからいつまでメモリ上に置かれているかという、「メモリ上に置かれている期間」を示す指標。
\end{description}
\end{itembox}
\\ \\　
通常の変数の場合、定義された後スコープが尽きるまでが寿命である。例えばリスト\ref{program6_1}のisPrimeの中の\verb|i|は、isPrimeが呼び出される毎にメモリ上に配置され、isPrimeが返却値を返すたびにメモリから取り除かれる。実際には、このような変数はautoという指定の寿命にであり、\textbf{自動変数}(auto variable)と呼ばれる。このautoのように、寿命その他の変数の性質を決めるための指定子が\textbf{記憶クラス指定子}\index{きおくくらすしていし@記憶クラス指定子}(storage class specifier)である。

\minisec{記憶クラス指定子}
記憶クラス指定子は寿命(及びスコープ等の変数の記憶に関する性質)を定めるための修飾子で、表\ref{tab6_1}に示すような種類がある。
\begin{table}[h]
\centering
\caption{記憶クラス指定子の一覧}\label{tab6_1}
\begin{tabular}{|c|c|c|}\hline
修飾子&名称&意味\\ \hline
&&\\[-15.5pt] \hline
auto&自動変数&(通常の指定)\\ \hline
register&レジスタ変数&CPUレジスタに確保される変数\\ \hline
static&静的変数&寿命が宣言後プログラム終了までとなる変数\\ \hline
extern&外部参照変数&別ファイルにおいて定義された変数\\ \hline
\end{tabular}
\end{table}

これらのうち、自動変数については、先に書いたとおり、標準通り「定義された後スコープが尽きるまでが寿命の変数」のことである。また、外部参照変数の指定子externはスコープに関連する指定子で、1ファイルの場合には使わないので後回しにする。
\\ \\　
registerで指定される\textbf{レジスタ変数}\index{れじすたへんすう@レジスタ変数}(register variable)は、通常のメモリではなく、CPUレジスタと呼ばれる「CPUに最も近いメモリのような場所」に格納される変数である。この指定子をつけた変数はアドレスを取得できないなどの制限を受けるものの、優先的にレジスタに格納され、計算速度の向上に役立つ。但し、レジスタにおかれることが保証されるわけではなく、必ずしも速くなるとは限らない。
\\ \\　
重要なのはstaticで指定される\textbf{静的変数}\index{せいてきへんすう@静的変数}(static variable)である。これについて、簡単なプログラムを見て見ることにしよう。
\begin{boxnote}
\minisec{呼び出し回数を数える関数}
呼び出し回数を数える関数を作成する。入力は自然数とする。
\begin{multicols}{2}
\begin{lstlisting}[caption=呼び出し回数,label=program6_3]
#include<stdio.h>

int func(void);

int main(void){
  int n,k;
  scanf("%d",&n);
  while(n--) k=func();
  printf("%d\n",k);
  return 0;
}

int func(void){
  static int num=0;
  return ++num;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

リスト\ref{program6_3}では、入力された数と同じ値が出力されるはずである。これは、関数funcが入力されたと同じ回数だけ呼び出されたという事であり、確かにプログラムに合致する。このことから、\verb|++num|は\verb|func()|の呼び出し回数だけ実行されていることになり、呼び出し毎の初期化が行われていないこともわかる。このように、静的変数は
\begin{itemize}
\item 初呼び出し時に定義・初期化され
\item 以降プログラム終了まで初期化されることなくメモリ上に配置されている
\end{itemize}
という2つの性質をもつ変数である(試しに、staticを外すと適切に動作しないことを確認してみよう)。静的変数は、回数を数える他、関数が内部状態を持つ時\footnote{内部状態を持つ関数とは、引数等で指定する必要はないが、前回の値を利用する場合などにその前回の値を保持しているような関数のことである。例えば、rand関数は前回の計算結果を内部で保持していて、それを利用して計算する、内部状態を持つ関数である。回数を数える関数も、回数という内部状態を持つ関数である。}などに用いられる。

なお、大域変数は何もしなくとも静的変数の性質を持つため、staticはローカル変数にのみ用いられる指定子であることを付記しておく。

\section{前処理命令と分割コンパイル}
自作関数と、それに関連した1ファイルでの寿命やスコープについてここまで解説した。この節では、これまで決まり文句としてかいていた\#始まりの文――\textbf{前処理命令}\index{まえしょりめいれい@前処理命令}(preprocessing directive)、コンパイラに対する命令――の活用法について学ぶ。とりわけ、もう一つ重要なオブジェクトであるマクロと、毎度使っているインクルードに焦点を当てることにする。この説明によりインクルードの意味が詳らかになると、複数ファイルを用いたプログラムという観念が自然に意識されることだろう。ここでは、これらの複数ファイルからなるプログラムのコンパイルやその場合のスコープについても説明する\footnote{ここで説明する複数ファイルのコンパイルは、主に原理の部分であり、各種ツール(makeやIDEなど)の利用については触れない。}。
\subsection{マクロ}
\textbf{マクロ}\index{まくろ@マクロ}(macro)とはソースコード中において「このように書いたら置き換えてください」という指示である。例えば、NUMと書いたら512に置き換えると設定しておき、プログラム中でNUMと書いてソースを書いておけば、後からこのNUMを書き換えたくなった時に置き換えのルールを変更するだけですむ。このような「置き換え」がCプログラムにおけるマクロである。
\begin{boxnote}
\minisec{マクロの利用}
2種類のマクロを宣言して、その動作を見てみる。
\begin{lstlisting}[caption=マクロの利用,label=program6_4]
#include<stdio.h>
#define NUM 1024
#define ABS(x) (((x)<(0))?(-(x)):(x))

int main(void){
  printf("%d\n",ABS(NUM));
  return 0;
}
\end{lstlisting}
\end{boxnote}

では、マクロについて、学んでいくことにしよう。なお、ここではマクロの基本的な扱い方及び注意点を述べるに留める。より発展的な使い方については付録を参照すること。
\minisec{オブジェクト形式マクロ}
リスト\ref{program6_4}のプログラムの$l$.2で使われているような、単に数字や文字列を置き換えるだけのマクロを\textbf{オブジェクト形式マクロ}\index{おぶじぇくとけいしきまくろ@オブジェクト形式マクロ}(object-like macro)と呼ぶ\footnote{オブジェクト形式マクロという名前であるが、オブジェクトのみを置き換えられるわけではなく、何でも置き換えられる。これは、後に紹介する関数形式マクロも同様である。極論、ソースコードを全てマクロにして、マクロを乱発するだけでソースコードを構成することもできる。例えば、
\begin{code}
for(i=a;i<n;i++)
\end{code}
を、\verb|REP(i,n,a)|などというマクロにする人が少なからず見られる。}。この文は、「以降NUMと書かれていた場合、これを1024に置き換えてくれ」という意味である。では、これを確認するため、マクロの記述方法を述べよう。
\begin{itembox}[l]{マクロの記述}
マクロを利用する場合には
\begin{code}
#define 置き換え名称 元の名称
\end{code}
の形式で記述する。
\end{itembox}

このことから、$l$.2のマクロはたしかに、「以降NUMと書かれていた場合、これを1024に置き換えてくれ」という意味になっていることがわかる。
\minisec{関数形式マクロ}
リスト\ref{program6_4}のプログラムの$l$.3には、関数のように(引数)を伴ったマクロが定義されている。このようなマクロを\textbf{関数形式マクロ}\index{かんすうけいしきまくろ@関数形式マクロ}(function-like macro)と呼ぶ。
\begin{itembox}[l]{関数形式マクロ}
関数形式マクロを利用する場合には
\begin{code}
#define 関数名(引数リスト) 置き換え文字列
\end{code}
の形式で記述する。
\end{itembox}

関数形式マクロも関数と同様に引数リストを準備し、それを用いて置き換え文字列を書く。例えば、先の\verb|ABS(x)|というマクロが、実際のプログラム中(main関数の中など）で、
\begin{code}
ABS(-5)
\end{code}
と書かれていれば、これは、
\begin{code}
(((-5)<(0))?(-(-5)):(-5))
\end{code}
と展開される。このように、引数を用いたマクロが関数形式マクロであり、簡単な処理であれば関数を使うよりも速い場合が多い。

\minisec{マクロのスコープとマクロに関する命令}
マクロにもスコープがあり、これは定義されて以降定義が終了するか、ファイル終端かまで続く。しかし、マクロには階層がないため、新たに定義されてしまうと、元のマクロが置きかわってしまう。これは、コンパイラのWarningとしては検出されるが、Errorでは無いので、再定義しないように注意する必要がある。

だが、大きなプロジェクトになると、マクロを定義するたびにいちいち他のマクロ全てをみて「定義されていない」ことを確認するのは煩わしいか、場合によっては不可能である。そこで、マクロに関する各種のプリプロセッサ文が役に立つ。マクロの多重定義を防いだり、コードを状況に応じて書き換える等の操作を行うためのプリプロセッサ文をひと通り紹介しておこう。とりわけ、大規模なプロジェクトや、コンパイル環境に応じたソースコードの変更などに用いられることが多い。
\begin{itembox}[l]{マクロ関連の前処理命令}
\begin{description}
\item[\#define] マクロを定義する。
\item[\#undef] マクロの定義を解除する。
\item[\#if] 引数に示される定数式が真ならば\verb|#endif|までのテキストを挿入する。
\item[\#ifdef] 引数に示すマクロが定義されていれば\verb|#endif|までのテキストを挿入する。
\item[\#ifndef] 引数に示すマクロが定義されていなければ\verb|#endif|までのテキストを挿入する。
\item[\#elif] 上記の\verb|#if(n)def|や\verb|#if|と組み合わせて用い、プリプロセッサ文においてelse ifと同じ役割を果たす。
\item[\#else] 上記の\verb|#if(n)def|や\verb|#if|と組み合わせて用い、プリプロセッサ文においてelseと同じ役割を果たす。
\item[\#endif] 上記の\verb|#if(n)def|や\verb|#if|と組み合わせて用い、これらの節の終端を示す。
\item[defined] 通常\verb|#if|や\verb|#elif|と組み合わせて用い、「この引数のマクロが定義されていれば」という意味を持つ。
\end{description}
\end{itembox}

ここにあげた全ての命令を逐一解説するつもりはないが、簡単な書き換えの仕方だけ紹介することにしよう。例えば
\begin{code}
#ifndef NUM
  #define NUM 512
    (NUMを使ったソース(ソースA))
  #undef NUM
#else
  #define NUMBER 512
    (NUMBERを使ったソース(ソースB))
  #undef NUMBER
#endif
\end{code}
というコードを考えよう。これは、NUMをそれまでに定義していなければソースAの部分を採用してコンパイルし、定義していればソースBの部分を採用してコンパイルするようにしたコードである。このようにして、状況に応じてコンパイルするコードを自動的に選択させる機能として、上記の命令を用いることが多く、これによってマクロの多重定義を防ぐことができる。
\\ \\　
なお、このようにして条件をつけてコンパイルすることを、文字通り\textbf{条件付コンパイル}\index{じょうけんつきこんぱいる@条件付コンパイル}(conditional compilation)と呼ぶ。

\minisec{マクロに関する諸注意}
ここまで、マクロを色々と見てきたわけであるが、
\begin{itemize}
\item マクロの名称がすべて大文字であること
\item 関数マクロはやたら()が多いこと
\end{itemize}
が気にならなかっただろうか。これは、マクロを使う上で注意すべき点である。
\\ \\　
一般に、マクロは他のオブジェクトと区別するために、英大文字と数字、アンダースコアからなる名称を付ける。これは慣例的に決まっているものであるので、必ずしもこれに従う必要はないが、どれがマクロで、どれが変数なのか一目に区別がつくほうが読みやすいため、できる限り従うことを推奨する。
\\ \\　
関数マクロにやたら()が多いのは、次のような例について考えてみればわかるだろう。
\begin{code}
#define SQUARE(x) x*x
\end{code}
見た目には問題が無いように思える。しかし、ここで\verb|SQUARE(a+b)|という呼び出しは
\begin{code}
a+b*a+b
\end{code}
と展開されてしまい、$(a+b)^2$を返してほしいはずが、$ab+a+b$という、全く違った値を返す動作になってしまう。これは、関数と違って評価後に処理されるわけではなく、コンパイル時の単なる置き換えであるために起きる問題である。実際にこのような局面に出会ったとしたら、マクロによってエラーが隠蔽されてしまうため、人間の目で見つけるのが困難になってしまう。同様の演算子の計算順序や演算子の結合などから出るエラーを防ぐために、関数形式マクロでは逐一()を付けるのが安全である。また、インクリメント等と組み合わせると、一層意図しない動作になることがある(2度評価されてしまう等)ので、注意深く扱わねばならない。
\\ \\　
なお、マクロによるエラーを発見するためには、マクロの展開結果を見たほうがわかりやすい。gccでは、マクロを展開した後(厳密にはプリプロセッサの行動を実行した後)のプログラムを見ることができる。
\begin{itembox}[l]{プリプロセッサ実行結果の確認}
あるソースに対して、プリプロセッサの実行結果を確認するためには
\begin{code}
cpp ソース名
\end{code}
を実行する。
\end{itembox}
なお、リダイレクトすることで、展開後のソースそのものをファイルとして保存できる。プリプロセッサの動作を理解したい場合に使うと良い。
\\ \\　
関数マクロについて、もう少し注意点がある。これは利点でもあるが、関数マクロには型チェックがない。そのため、先の\verb|ABS|関数マクロのように型を気にせず使える反面、整数同士の割り算によるバグなどを招く場合もある。そのため、関数マクロを使う場合には、通常の変数だけを使う場合に比べ、プログラマが尚更型を意識しなければならない。

また、関数マクロの引数は見かけ上の引数であって、値がコピーされている関数の引数とは違うものである。マクロの引数は単に置き換えられるものに過ぎず、それ故マクロ中で変数いじりを行うとそれがモロに置き換え後の変数にも影響する。逆に言えば、変数を直接扱うこともできるという事でもある。
\\ \\　
先の多重定義も含め、マクロの利用で注意すべき点をまとめておこう。
\begin{itembox}[l]{マクロ利用上の注意}
\begin{itemize}
\item マクロは多重定義してはならない。できれば\verb|#ifdef|などを用いて、多重定義を防止するコードを書くように心がけよ。
\item マクロは他オブジェクトと区別するため、英小文字を使わない識別子とする。
\item マクロ定義時には、展開後の構文解釈の齟齬を防ぐため、項毎に()を付すこと。
\item プリプロセッサ展開結果を見るには\verb|cpp|コマンドを用いる。
\item 関数マクロには型チェックがない。
\item 関数マクロの引数は見かけ上の引数であり、値がコピーされて動作が行われるわけではない。
\end{itemize}
\end{itembox}

\subsection{ヘッダファイルの実態とインクルード}
ここまで天下りに書いてきたインクルードについてもう少し掘り下げよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{インクルード文の動作}
サブをsub.cとしてメインと同じディレクトリに保存した後、メイン側をコンパイルしてみよ。
\begin{lstlisting}[caption=インクルード確認(サブ),label=program6_5_1]
#include <stdio.h>
#define INC_STDIO 

int func(void){
  return 5;
}
\end{lstlisting}
\begin{lstlisting}[caption=インクルード確認(メイン),label=program6_5_2]
#include "./sub.c"
#ifndef INC_STDIO
  #include<stdio.h>
#endif

int main(void){
  int i;
  for(i=0;i<func();i++){
    puts("Hello World!");
  }
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
\minisec{インクルード文}
\textbf{インクルード文}\index{いんくるーどぶん@インクルード文}は、引数に示されたファイルをそのままソースに埋め込む命令である。試しにリスト\ref{program6_5_2}のファイルのコンパイルをcppに変えてみれば、埋め込みである証拠に、2つのソースが結合されて出力されるだろう。
\\ \\　
インクルード文を使う場合、システムが標準で用意してくれているライブラリは\verb|<>|中にヘッダファイルを記す。一方、自前のソースを埋め込む場合は\verb|""|で囲み、その中に埋め込みたいソースのパスを示す。したがって、普段よく書く\verb|#include<stdio.h>|は\verb|stdio.h|をその部分に埋め込む、という命令である。

\minisec{ヘッダファイルの実態}
\verb|stdio.h|を埋め込んだソースをcppで見るなり、Linuxの場合\verb|/usr/include|にある\verb|stdio.h|を見るなりして、その中身を確かめてみよう。すると、例えばputsの周辺は
\begin{code}
extern int puts (__const char *__s);
\end{code}
となっている。これはプロトタイプ宣言である。他の関数もプロトタイプ宣言が行われている他、必要に応じてマクロや型が定義されていることがわかる。
\\ \\　
このように、ヘッダファイルは、マクロや型の定義及びプロトタイプ宣言が行われているファイルであり、関数の実体そのものは別の場所にある\footnote{この、別の場所にある関数の実態そのものを引っ張ってくるのが「リンク」という作業である。ちなみに、リンクで呼び出される側のファイルはバイナリファイルであり、その実装元のソースは通常見ることができない。}。実際、自作ヘッダファイルを作る場合も、これを踏襲して、
\begin{itemize}
\item ヘッダファイルには共通定義すべきマクロや型と関数プロトタイプのみを記し
\item 実体は別のファイルに書いて分割コンパイルの手法を用いて利用する
\end{itemize}
のが一般的である。

\minisec{多重インクルードの防止}
先に出てきたinclude等を使っていると、同じソースを複数回インクルードしてしまうことがあり、バグの原因となりうる。これを防ぐため、適当なマクロを定義して、それが定義されていなければインクルードする、というように書くのが一般的である。このように、適当なマクロを定義して多重インクルードを防止する手法を\textbf{インクルードガード}\index{いんくるーどがーど@インクルードガード}(include guard)と呼ぶ。リスト\ref{program6_5_1}およびリスト\ref{program6_5_2}では\verb|INC_STDIO|というマクロを用意し、これが定義されているかどうかでインクルードガードを行なっている。通常、インクルードガードに利用するマクロはヘッダファイルに書かれている(自作する場合書くようにする)。例えば\verb|stdio.h|の場合は\verb|_STDIO_H|というマクロが定義されている。

\subsection{分割コンパイルと複数ファイルでのスコープ}
インクルードを用いて「はめこみ合成」を行えば、ソースを複数に分けて分割することも可能である。だが、それは単にひとつのソースを切っただけに過ぎない。巨大なプログラム開発だと
\begin{itemize}
\item コードを機能別に保守したい。
\item 少しコードを書き換えたからと言って全てコンパイルし直すのではなく、コードを書き換えた部分だけを更新したい。
\end{itemize}
などの要求が出てくるだろう。これらの要求に答えるのが分割コンパイルの手法と、それを支援するツール群\footnote{分割コンパイルに用いられるツールとしては、IDE(統合開発環境)は勿論のこと、makeやAutotoolset,Cmakeなどが知られている。}である。ここでは、分割コンパイルの手法と、その利用に必要な複数ファイルのスコープに関して簡潔に述べることとする\footnote{より細かいことを知りたい場合は「C言語によるスーパーLinuxプログラミング」(飯尾 淳 著,2011,ソフトバンククリエイティブ)など参照。}。

\minisec{分割コンパイルの手法}
分割コンパイルは、先に挙げたような要求に答えるための機能であり、分割の単位は人間がわかりやすいよう、関数単位などとすることが多い。ここでは、先にインクルードの解説で用いたプログラムを、分割コンパイル用に書きなおして見ることにしよう。
\begin{boxnote}
\minisec{分割コンパイル}
サブとメインを同じフォルダに入れて、適当な名前をつけて保存せよ。以降の解説では、Sub.cとMain.cとして記す。また、共有ヘッダも\verb|header.h|という名前で、同じフォルダにおいておくこと。
\begin{multicols}{2}
\begin{lstlisting}[caption=共有ヘッダ(header.h),label=program6_6_1]
#include<stdio.h>
int func(void);
\end{lstlisting}
\begin{lstlisting}[caption=分割コンパイル確認(サブ),label=program6_6_2]
#include "./header.h"

int func(void){
  return 5;
}
\end{lstlisting}
\begin{lstlisting}[caption=分割コンパイル確認(メイン),label=program6_6_3]
#include "./header.h"

int main(void){
  int i;
  for(i=0;i<func();i++){
    puts("Hello World!");
  }
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
このように、分割されたソースからなる一つのプログラムをコンパイルするときには、
\begin{code}
gcc Sub.c Main.c
\end{code}
のように、全てのソースファイルを指定すれば、通常と同じ結果が得られる。だが、これだけでは、いちいちすべてコンパイルしなければいけない煩わしさは変わっていない。
\\ \\　
そこで、次のようにコンパイルを実行する。
\begin{code}
gcc Sub.c -c
gcc Main.c -c
gcc Main.o Sub.o
\end{code}
この、最初の2行の\verb|-c|オプションをつけたコンパイルにより、結合直前までの作業を終わらせておき、最後の1行のコードで結合する、というような意味になる。このことから、例えばSub.cを書き換えた場合は第1行と第3行のみを実行すれば良い(実際に書き換えて試してみよ)。
\\ \\　
また、ここでは共通ヘッダファイルを用いている。これは、分割ファイルをコンパイルする際に面倒なエラーなどが起こらないようにする手法の一つである。例えば、関数\verb|func|は、メインプログラムには書かれていない。そのため、単に\verb|#include<stdio.h>|としただけでは、定義されていないとしてエラーが起こってしまう。そこで、必要なプロトタイプ宣言を記すわけだが、多数のファイルの先頭にいちいちプロトタイプ宣言を書くのは間違いの元なので、ヘッダファイルを作成してインクルードすることにより対処しているのである。

\minisec{複数ファイルでのスコープについて}
最後に、複数ファイルでのスコープについて述べておく。このような、複数ファイルでのスコープのことを\textbf{リンケージ}\index{りんけーじ@リンケージ}(linkage)と呼ぶ。この内、あるファイル内限定で使えるものは\textbf{内部リンケージ}\index{ないぶりんけーじ@内部リンケージ}(internal linkage)を持つといい、他のファイルでも使えるものは\textbf{外部リンケージ}\index{がいぶりんけーじ@外部リンケージ}(external linkage)を持つという。
\\ \\　
リンケージは関数と変数とで取り扱いが違う(マクロは通常、複数ファイル間のスコープは持たず、必要ならばインクルードを利用する必要がある)ため、個別に述べていく。
\\ \\　
関数の場合、通常の宣言では外部リンケージを持つ。したがって、プロトタイプ宣言さえしておけば、他のファイルに書かれている関数を自在に使うことができる。この「自在に使われる」現象を防ぐためには、関数の宣言前にstaticを付ける。このstaticは静的変数のstaticと\underline{全く意味が違う}ので注意せねばならない。
\begin{itembox}[l]{staticの意味}
\begin{itemize}
\item 変数の前のstaticは静的変数の意味。
\item 関数の前のstaticは内部リンケージを持つ関数の意味。
\end{itemize}
\end{itembox}

このように、C言語には綴りが同じであるのに意味が違う記号や言葉があるので、注意せねばならない\footnote{これについては「エキスパートCプログラミング」(P.Linden 著,梅原 系 訳,1996,ASCII)が詳しい。本講で出てきたvoidというシンボルも引数リストでは「引数がない」、返却値の型では「返却値を返さない」と複数の意味を持つし、extern指定子は関数につけた場合(冗長な宣言であり、通常付ける必要はないが)外部リンケージを持つ関数であるという意味になる(変数は別ファイルで定義しているのを呼ぶという意味で、違う意味であることに注意)。\\　
しかし、externやvoidといった例も、staticほどの意味の違いはない。staticについては、同書においてわざわざ脚注がつけられ、「なぜこれほどまでに違った意味が持たされたのか？」とまで書かれているほど意味が違う。}。
\\ \\　
関数はプロトタイプ宣言によって宣言を行い、実体定義を読みに行くが、変数にはプロトタイプ宣言などというものはない。そこで、別ファイルで定義された変数を読みに行く際には、同名同型の変数の宣言の前に\verb|extern|記憶クラス指定子を付す。なお、この方法で読めるのは大域変数のみであり、局所変数は(そもそもスコープがその関数内に制限されているため)読むことができない。つまりファイルAでグローバルに\verb|int a=5|などと定義しておき、ファイルBで\verb|extern int a|とすれば、ファイルAで定義した\verb|a|と同じ\verb|a|をファイルB内で使うことができるが、\verb|a|の定義がローカルだったならば、これは使えないという事である。

変数と関数の複数ファイルにおけるスコープをまとめると、表\ref{chap6_tab_scope}のようになる。
\begin{table}[htbp]
\centering
\caption{複数ファイルにおける変数/関数のスコープ}\label{chap6_tab_scope}
\begin{tabular}{|c|c|c|}\hline
 &変数&関数\\ \hline
内部リンケージ&普通に宣言&static指定子を付ける\\ \hline
外部リンケージ&呼ぶ側でextern指定子を付ける&プロトタイプ宣言して別で定義\\ \hline
\end{tabular}
\end{table}

なお、スコープが重複した場合の処理については、1ファイルの場合と同様、より狭い側が優先される。
\newpage

\begin{shadebox}
\section*{本講の要点}
本講では、自作関数を導入し、オブジェクトのスコープや寿命について学んだ後、プリプロセッサについても触れた。
\subsection*{自作関数}
\begin{itemize}
\item 自作関数は似たような処理をまとめるなどの用途で用いられる。
\item 自作関数を作成する際には、使用するより前にプロトタイプ宣言を行い、一般にはmainより後で定義する。
\item 自作関数に引数として渡される値はあくまで値のコピーであり、変数そのものではない。それ故、関数内での処理は呼び出し元の変数に影響を及ぼさない。
\end{itemize}

\subsection*{型の別名定義}
\begin{itemize}
\item typedef指定子を用いることによって型を定義することができる。
\end{itemize}

\subsection*{スコープと寿命}
\begin{itemize}
\item オブジェクトの有効範囲をスコープといい、通常ファイル内ないし宣言された節内である。
\item 外部リンケージを持つ関数は必ずグローバルに宣言されている必要がある。
\item 変数が生成されてからメモリ上から取り除かれるまでの期間を変数の寿命と呼ぶ。
\item 関数中でstaticをつけて宣言された変数を静的変数と呼び、プログラム終了までの寿命を持つ。静的変数の初期化は一度しか行われない。
\item registerをつけて宣言された変数はレジスタ変数と呼ばれ、レジスタ上に優先的に配置される代わりに、アドレスが取得できないなどの制限を受ける。
\item 外部で定義された変数を利用する場合はextern指定子を付す。
\end{itemize}

\subsection*{プリプロセッサとマクロ}
\begin{itemize}
\item マクロは、ソース中のあるキーワードを置き換える役目を担い、関数形式マクロとオブジェクト形式マクロに大別される。
\item 前処理命令を上手く使うことで、環境に応じてソースを変えるなどの処理を組み込むことができる。
\end{itemize}
\end{shadebox}


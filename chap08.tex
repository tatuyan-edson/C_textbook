今回から4講にわたり、変数のより応用的な利用法として「派生型」について学んでいく。厳密には、ここまでに学んだ関数も「関数型」と呼ばれる派生型であるため、本書の第6〜12講は派生型とその扱い方を学んでいると言える。とりわけ、タイトルに「派生型」と付した講は、「いかにも変数を応用しています」という感のある内容である。
\\ \\　
今回は、派生型のうち最も基本的と言える\textbf{配列}\index{はいれつ@配列}(array)と、その応用である\textbf{文字列}\index{もじれつ@文字列}(string)について学んでいく。
\section{基本型と派生型}
まず、派生型とは何かを見ていくことにしよう。なお、本節は抽象概念の説明であるので、理解し難いと思ったらひとまず飛ばして次節に進んで良い。
\\ \\　
\textbf{派生型}\index{はせいがた@派生型}(derived type)とは、これまで紹介してきた整数型・浮動小数点数型・複素数型・虚数型・文字型などの\textbf{基本型}\index{きほんがた@基本型}(primitive type)に対して、\textbf{派生}\index{はせい@派生}(derivation)と呼ばれる操作を有限回行うことによって定義される型のことである。派生の操作は、次の5種類で尽くされる。
\begin{itembox}[l]{派生の操作}
\begin{itemize}
\item 関数型とする。
\item ポインタ型とする。
\item 配列型とする。
\item 構造体型とする。
\item 共用体型とする。
\end{itemize}
\end{itembox}

ここに示した5種類の操作を基本型に施すことで、基本型を元にした、なにか特殊な型ができる。これらの特殊な型を総称して派生型と呼ぶのである。

\subsection{派生操作の組み合わせ}
派生操作は複数組み合わせて利用することができる。例えば、int型に対して、配列型にする操作を施したあとに構造体型にしても問題ない。派生操作の組み合わせとして問題になるのはいずれも関数型絡みのものばかりである。
\begin{itembox}[l]{組み合わせられない派生}
\begin{itemize}
\item 関数型にした型はポインタ型にしかできない。
\item 配列型にした型を関数型にはできない。
\end{itemize}
\end{itembox}

ここで注意して欲しいのはいずれも1段階はさめば大丈夫という事である。例えば、配列型にした型を、更に構造体型にして、そのあと関数型にすることは可能である。
\subsection{基本型でも派生型でもない型}
ここで紹介した基本型と派生型以外にも、特殊な型として次の2つが知られている。
\begin{itembox}[l]{基本型でも派生型でもない型}
\begin{itemize}
\item void型
\item 列挙型
\end{itemize}
\end{itembox}

これらについて注意すべき点として、これらは分類上、独立した型として扱われるが、一部の派生操作が可能であるという点を挙げておく。例えば、void型は関数に用いて関数型にすることができる。このため、あくまでも「分類の上では」特殊な型として認識しておいていただければ良い。

\subsection{型についてのまとめ}
ここまでに学んだ型についての知識は、基本型への操作として捉えることができる。すなわち、何らかの型の変数/関数を宣言するという事は、基本型ないし特殊な型に対して
\begin{itemize}
\item 派生する。
\item 修飾子を付す。
\item 記憶クラス指定子を付す。
\end{itemize}
の3つの操作を0回以上行い、その後にオブジェクトを記す、という事である。換言すれば、基本型ないし特殊な型に対して、上記の3操作を適切に施すことで、C言語で扱える任意の型を記述することができるという事である。

\section{静的配列}
抽象概念は終えて、具体的に派生型を見ていくこととしよう。
\\ \\　
\textbf{配列}\index{はいれつ@配列}は、変数を一括管理する時などに便利な派生型で、\textbf{メモリ上に連続的に配置された}変数に通し番号をつけたものである。実際のイメージとしては図\ref{chap08_fig01}のようになる。
\begin{figure}[htb]
\centering
\begin{tabular}{|c|c|c|ccc|c|c|}\hline
&　&　&　&　&　&　&\\
$\cdots$別利用&\verb|a[0]|&\verb|a[1]|&&$\cdots$&&\verb|a[k]|&別利用$\cdots$ \\
&　&　&　&　&　&　&\\ \hline
\end{tabular}
\caption{配列配置のイメージ}\label{chap08_fig01}
\end{figure}

配列は、宣言の際に個数がわかっており、スタック領域に確保される\textbf{静的配列}\index{せいてきはいれつ@静的配列}(static array)と、宣言の際に個数がわかっておらず、実行時に個数を計算してヒープ領域に確保される\textbf{動的配列}\index{どうてきはいれつ@動的配列}(dynamic array)\footnote{\textbf{可変長配列}\index{かへんちょうはいれつ@可変長配列}(variable length array)とも呼ばれる。可変長配列は長さが変わることを明示的に表し、動的配列はヒープ領域に確保することを明示的に表すものとする、という人もいる。この場合、「可変長の静的配列」といえば、コンパイル時ではなく実行時に個数の決まる、スタック領域に確保される配列、という意味になる。}とに分けられる。ここでは、派生で言うところの「配列型」である、静的配列について扱う。
\subsection{配列に関する用語}
配列の各部の呼び名等について、簡単に説明しておく。配列は
\begin{enumerate}
\item \textbf{配列名}
\item \textbf{要素数}(配列のサイズ)
\item \textbf{インデックス}\index{いんでっくす@インデックス}(添字)
\item \textbf{オフセット}\index{おふせっと@オフセット}(開始インデックス)
\end{enumerate}
といった要素からなる。配列名はその名の通り配列の名前であり、要素数はその配列が全部でいくつの変数からなるか(あるいはメモリ上でどれだけのサイズを確保しているか)を示す。インデックスは配列の通し番号のことである。オフセットは配列の先頭の番号で、\underline{Cでは一般に0始まり}である(これを0-offsetや0-indexedと表現する)。

\subsection{1次元配列}
通し番号が1つだけの配列を1次元配列と呼ぶ。以下では、1次元静的配列について見ていこう。
\begin{boxnote}
\minisec{ホフスタッター数列の計算}
次の漸化式によって定義される数列をホフスタッター数列と呼ぶ。
\[
\left\{
\begin{array}{l}
 Q_n = Q_{n-Q_{n-1}}+Q_{n-Q_{n-2}} \ (n \ge 2) \\
 Q_0=Q_1=1 \\
\end{array}
\right.
\]
1000000未満の自然数$n$が入力される時、ホフスタッター数列の第$n$項$Q_n$を計算して出力するプログラムを作成する。
\end{boxnote}
\begin{boxnote}
\minisec{解説}
再帰呼び出しをするとあっという間にスタックオーバーフローしそうな式である。そこで、配列を用いて各項の値を計算・保持しておいて出力することにする。なお、配列にメモしつつ再帰を用いる方法もあり、その場合は\textbf{メモ化再帰}\index{めもかさいき@メモ化再帰}と呼ばれる。逆に、このようにボトムアップに計算していく方法は\textbf{動的計画法}\index{どうてきけいかくほう@動的計画法}(Dynamic Programming,DP)と呼ばれる。
\begin{lstlisting}[caption=ホフスタッター数列の計算,label=program8_1]
#include<stdio.h>
#define NUM 1000000

int main(void){
  unsigned int array[NUM]={1,1},i,n;
  scanf("%u",&n);
  for(i=2;i<=n;i++){
    array[i]=array[i-array[i-1]]+array[i-array[i-2]];
  }
  printf("%u\n",array[n]);
  return 0;
}
\end{lstlisting}
\end{boxnote}

それでは、配列について見ていこう。
\minisec{配列の宣言}
リスト\ref{program8_1}では、配列として\verb|array|という変数(配列変数)が宣言されている。一般に、配列の宣言は次の形で行う。
\begin{itembox}[l]{一次元配列の宣言}
一次元配列を宣言する際には
\begin{code}
型 配列名[要素数]
\end{code}
の形式で行う。
\end{itembox}

静的配列の場合、宣言と同時にメモリ上に確保され、利用が可能になる。この際、確保される領域はスタック領域であるので、制限がある。そのため、静的配列の要素数は必要最小限の量に留めなければならない。また、\verb|[]|の中はあくまでも要素数であり、要素番号の最大値とは異なることに注意しよう。すなわち、\verb|array[5]|と宣言した場合、実際にメモリ上に置かれるのは\verb|array[0]|から\verb|array[4]|の5個という事になる。また、一般に\verb|[]|の中は自然数でなければならない。従って、全部で10万要素の配列を定義する場合、\verb|array[1E+5]|としてもうまくいかず、\verb|array[(int)1E+5]|とする必要がある。さらに、C99以外の規格の場合、\verb|[]|の中は定数である必要もある。

以上をまとめておこう。
\begin{itembox}[l]{静的配列の宣言時の注意}
\begin{itemize}
\item \textbf{配列のご利用は計画的に。借り過ぎ使いすぎに注意しましょう。}
\item 配列宣言の際に\verb|[]|の中に書くのは要素数であり、最大要素番号はこれより1小さくなる(0-offsetであるため)。
\item 要素数は整数型、自然数でなければならない。
\item C99以外の規格では、静的配列宣言時の要素数は定数である必要がある。
\end{itemize}
\end{itembox}

\minisec{配列の初期化}
配列を宣言した場合、配列は通常の変数と同様、何が入っているかわからない。そこで、配列も初期化する必要がある。

配列の初期化には何種類かの方法がある。例えば、for文を用いて
\begin{code}
for(i=0;i<NUM;i++) array[i]=0;
\end{code}
のように、すべての要素に代入してしまう方法もある。あるいは、すべての要素を0で初期化する場合、\verb|string.h|に入っているmemsetという関数を用いて
\begin{code}
memset(array,0,sizeof(array));
\end{code}
とすれば、全要素を0にすることができる。なお、ここで第3引数に出てくる\verb|sizeof(配列名)|は、配列の大きさ(バイト単位)になる。従って、これを配列の第0要素で割って
\begin{code}
sizeof(array)/sizeof(array[0])
\end{code}
としたり、型で割って
\begin{code}
sizeof(array)/sizeof(int)
\end{code}
とすることで、個数を取得することもできる(後述)。
\\ \\　
ここまでに述べた方法はあくまでも代入であるので、初期化というには少し語弊がある。宣言と同時に代入を行うものを一般に初期化という為である。Cでは、配列の初期化は直接要素を書くことで行う。
\begin{itembox}[l]{配列の初期化方法}
配列を行う際には、宣言時に
\begin{code}
型 配列名[要素数]={各要素の値(コンマ区切り)}
\end{code}
の形式で記す。この時、要素数は省略することができて、初期化の内容に応じて必要な数の要素を自動で計算してメモリ上に確保してくれる。
\end{itembox}

例えば、3項からなる配列を1,3,6と初期化したい場合は
\begin{code}
int array[]={1,3,6};
\end{code}
のように記す(\verb|[]|の中に3を書いても良い。)。なお、この方法で初期化する場合、必要な番号までの全要素を列挙する必要がある。この難点をなくすため、C99では
\begin{code}
int array[3]={[1]=3,[2]=6};
\end{code}
のように、特定の要素だけを指定した初期化ができるようになった。

逆に、要素数のほうが初期化子よりも多い場合、残りの数は0で初期化される。この為、全ての数を0で初期化したい場合は
\begin{code}
int array[NUM]={0};
\end{code}
のようにしておけば簡単である。リスト\ref{program8_1}の$l$.5も同じ方法である。
\\ \\　
やはり、これもまとめておくことにしよう。
\begin{itembox}[l]{配列の初期化方法のまとめ}
\begin{itemize}
\item 配列を初期化する場合は、様々な処理に先立って繰り返し文などを用いて代入処理を行えば良い。
\item 配列を宣言と同時に初期化したい場合は、配列の宣言の後に\verb|={}|を記し、\verb|{}|内に順に初期値をコンマ区切りで書いていく。
\item C99では、宣言と同時に初期化する際に、要素番号を指定した初期化ができるようになった。(\textbf{指示付き初期化子}\index{しじつきしょきかし@指示付き初期化子}(designated initializer))
\end{itemize}
\end{itembox}

\minisec{配列の参照}
配列は変数であるので、変数と同じように参照できる。
\begin{itembox}[l]{配列の参照}
配列要素を参照する際には、配列名の後に\verb|[要素番号(インデックス)]|と記す。
\end{itembox}

例えば、リスト\ref{program8_1}の$l$.10では、配列\verb|array|の第$n$要素を出力している。なお、配列の後の\verb|[]|の中は計算式でもよい(リスト\ref{program8_1}の$l$.8など)。
\\ \\　
配列を呼び出す場合、その添字が存在しない番号、例えば最大値を超えたり、負の数になってしまったりした場合、アクセスすべきでないメモリ領域にアクセスしたとして"Access violation"や"Segmentation fault"などといった実行時エラーを吐く場合がある。そのため、呼び出し時にはこれらのエラーが起きないよう、添字に注意しなければならない。

\minisec{範囲外アクセスを防ぐための工夫}
しかし、添字に注意すると言っても、人間の注意力には限界がある。そこで、普段から範囲外アクセスを防ぐような、安全なコードを書く方法を採るようにしよう。これにより。範囲外アクセスの危険性を減らすことができる。ここでは、このような「範囲外アクセスを防ぐ工夫」を紹介する。
\\ \\　
範囲外アクセスを防ぐためには、ある要素を単独で呼び出す場合、単純にその添字をif文でチェックするなどの方法がある。だが、実際「単独で」呼び出す場合に範囲外アクセスになる場合はあまり多くないのである。一括処理する際に、見落としなどがあって変な要素にアクセスしてしまう場合が多い。これらを防ぐための方法として、for文の書き方を一定するという方法がある。
\begin{itembox}[l]{配列に順次アクセスする際のfor文}
\begin{enumerate}
\item for文を用いて配列に順次アクセスする際には
\begin{code}
for(i=0;i<個数;i++)
\end{code}
の形式でアクセスすれば安全である。
\item 先で「個数」と書いた部分は配列の要素数であるが、これにはいくつかの取得方法がある。
\begin{itemize}
\item リスト\ref{program8_1}のように、マクロを用いて一貫して記す。
\item \verb|sizeof(配列名)/sizeof(配列名[0])|の形式で個数を計算する。
\item \verb|sizeof(配列名)/sizeof(型)|の形式で個数を計算する。(型がわかっている場合のみで、型を変える際の対応が面倒。)
\end{itemize}
\end{enumerate}
\end{itembox}

とりわけ、マクロを用いる方法は改変の際などに対応しやすく、一般によく用いられる。C言語には個数を自動で取得するような万能の機構は無いので\footnote{C++やJavaなどでは、配列の大きさを簡単に取得する方法が存在する。}、いくつかの方法を上手く使い分けて範囲外アクセスを避けなければならない。

\subsection{多次元配列}
行列の成分のように、2つ以上の通し番号が欲しい場合も少なくない。このような場合に対応するために、1次元配列の番号付の方法を変更して2つ以上の通し番号を付けられるようにした\textbf{多次元配列}\index{たじげんはいれつ@多次元配列}という機能がある。これは厳密に言えば「配列の配列」という方が正確で、メモリに面的に広がるのではなく、配列がいくつも連続して置かれており、その各配列に対しても通し番号をつけた、というものである。以下、2次元配列を例に、多次元配列の利用法について見ていくことにしよう。
\begin{boxnote}
\minisec{正方行列の積}
入力される2つの正方行列の積を出力するプログラムを作成する。次元については、コンパイル段階でマクロを用いて決めることとする。
\end{boxnote}
\begin{boxnote}
\minisec{解説}
\begin{itemize}
\item 1次元配列と同様に、配列の要素数はマクロで指定している。ここでのマクロは行列の次元を示している。
\item 行列を半角空白及び改行区切りで2個入力する。例えば、2次元の場合
\begin{verbatim}
1 2
3 4
3 2
4 1
\end{verbatim}
のように行い、上2行が1つ目の行列、下2行が2つ目の行列を表す。
\item $l$.19のprintf第3引数は、行列を1行出力する毎に改行になり、それ以外の場合は区切り文字として空白を出力する。
\end{itemize}
\begin{lstlisting}[caption=正方行列の積,label=program8_2]
#include<stdio.h>
#define DIM 3

int main(void){
  double mat1[DIM][DIM],mat2[DIM][DIM];
  double ans[DIM][DIM]={{0},{0}};
  int i,j,k;
  for(i=0;i<DIM;i++) for(j=0;j<DIM;j++) scanf("%lf",&mat1[i][j]);
  for(i=0;i<DIM;i++) for(j=0;j<DIM;j++) scanf("%lf",&mat2[i][j]);
  for(i=0;i<DIM;i++){
    for(j=0;j<DIM;j++){
      for(k=0;k<DIM;k++){
        ans[i][j]+=mat1[i][k]*mat2[k][j];
      }
    }
  }
  for(i=0;i<DIM;i++)
    for(j=0;j<DIM;j++)
      printf("%lf%c",ans[i][j],j==DIM-1?'\n':' ');
  
  return 0;
}
\end{lstlisting}
\end{boxnote}
\minisec{多次元配列の利用}
多次元配列の利用方法は、リスト\ref{program8_2}を見ればわかるとおり、一次元配列と同じである。$l$.4にあるように、添字を示す[]の組が増え、それぞれについて要素数を示すようにしなければならないという事、$l$.5にあるような形式で初期化できるという事、$l$.7のように、各要素に番号を指定することによってアクセスできることなど、いずれも1次元配列と同様であることがわかるだろう。なお、初期化には、「指定していない要素は0で初期化される」という規格を用いていることに注意されたい。
\\ \\　
多次元配列を用いる場合には、1次元配列以上に使用するメモリ量に注意しなければならない。例えば、リスト\ref{program8_2}でマクロ\verb|DIM|の値を100にすると、3つ存在する2次元配列は、各々100*100*8Byte=80000Byte=80kBとなり、100という数字に比べてずいぶん大きくなる。

\minisec{多次元配列のメモリ上での配置}
多次元配列は実際には「配列の配列」であると述べた。例えば
\begin{code}
int array[3][4]
\end{code}
という2次元配列を考えてみる。これは、\verb|array[0]|,\verb|array[1]|,\verb|array[2]|という3つの4要素の配列の集合である。これが多次元配列が配列の配列であると述べた所以である。
\\ \\　
そして、配列の配列というだけあって、多次元配列のメモリでの配置は一次元配列を配列として並べた形になっている。先の例で言えば、まず\verb|array[0]|が\verb|array[0][0]|より\verb|array[0][3]|まで順に並べられ、次いで\verb|array[1]|が\verb|array[1][0]|より\verb|array[1][3]|まで…という形式である。これを図示すると図\ref{chap08_fig02}のようになる。
\begin{figure}[htb]
\centering
\begin{tabular}{|c|c|c|c|c|c|c|c|}\hline
&　&　&　&　&　&　&\\
$\cdots$&a[0][0]&a[0][1]&$\cdots$&a[0][N]&a[1][0]&a[1][1]&$\cdots$ \\
&　&　&　&　&　&　&\\ \hline
$\cdots$&\multicolumn{4}{|c|}{a[0]}&\multicolumn{2}{|c}{a[1]}&$\cdots$\\ \hline
\end{tabular}
\caption{多次元配列配置のイメージ}\label{chap08_fig02}
\end{figure}

メモリはランダムアクセスであるが、配列の場合には図\ref{chap08_fig02}のように、シーケンシャルに配置される。この時、順に見ていくほうが一般的には速いため、多次元配列のすべての項に対する操作を書く際にはリスト\ref{program8_2}の$l$.8と同様に、後側の添字を先に変化させた方が効率よく処理を行うことができる。

\subsection{一次元静的配列を引数に取る関数}
ここまで、配列について学んできたが、配列を引数に取る関数を作ることもできる。但し、多次元配列を引数に取るのは少し難しいので、後に学ぶポインタを利用したほうがわかりやすい。ここでは、一次元静的配列を引数とする関数の作成方法について学ぼう。
\begin{boxnote}
\minisec{ベクトルの内積}
二つのベクトルが配列で与えられる時、その内積を計算する関数を作成する。引数はベクトルを表す配列と、その要素数(=ベクトルの次元)。
\minisec{解説}
ベクトルの内積は、各成分の積の総和であるので、成分毎の積をとって順に足していき、最後に総和を返す関数を作成すれば良い。
\begin{lstlisting}[caption=ベクトルの内積,label=program8_3]
#include<stdio.h>

#define DIM 5

double inner_prod(double v1[],double v2[],int size){
  int i;
  double ret=0;
  for(i=0;i<size;i++) ret+=v1[i]*v2[i];
  return ret;
}

int main(void){
  int i;
  double vec1[DIM],vec2[DIM];
  for(i=0;i<DIM;i++) scanf("%lf",&vec1[i]);
  for(i=0;i<DIM;i++) scanf("%lf",&vec2[i]);
  printf("inner_prod=%lf\n",inner_prod(vec1,vec2,DIM));
  return 0;
}
\end{lstlisting}
\end{boxnote}

\minisec{配列引数とその呼び出し}
関数を学んだ時に、引数は原則として変数の宣言と同じであるという事を学んだ。配列引数の場合もほとんどそれと同じ\footnote{ほとんどと書いたのは、後に記す参照などの点が異なるからである。仮引数で宣言した場合は通常の変数は同時に定義もなされているが、配列を仮引数に書いた場合、これは配列としては定義されず、等価なポインタが定義されるだけである。また、実引数の配列そのものが仮引数の配列にコピーされるわけではなく、実引数の配列のアドレスが、仮引数のポインタに代入されるだけである。このように、配列引数は内部的にポインタと絡んでいる部分が多いため、ポインタを理解してから再度詳細を理解して欲しい部分である。本書でも、ポインタを学んだ後その観点から配列や文字列を扱う。}である。すなわち、配列の引数を取る場合、配列の宣言の場合と同様の形式で記せばいいのである。
\begin{itembox}[l]{配列引数}
配列を引数に取る場合は、引数部分に
\begin{code}
型 配列名[]
\end{code}
と記す。ただし、要素数が既定である場合には
\begin{code}
型　配列名[要素数]
\end{code}
の形式で宣言しても良い。
\end{itembox}

要素数が既定である場合の方法についても記したが、一般には要素数は不明であるので、\textbf{別の引数として要素数を与える必要がある}(例：リスト\ref{program8_3}の\verb|inner_prod|関数の第3引数)。C99対応環境であれば、これを更に応用して
\begin{code}
int arrayfunc(int m,int array[m]);
\end{code}
のように書くこともできる。但し、これを書いたからと言って「個数が異なっていればコンパイルエラーになる」などの利点はない\footnote{これは、仮引数に現れる配列が、内部的に、それと等価なポインタとして解釈されるためである。}。この形式は多次元配列引数の場合などにも用いることができる。
\\ \\　
上記によって配列を引数に取る関数を定義することができたが、呼び出しを行う場合はどうだろうか。勿論、配列の各項を渡す場合は通常の変数と同様に
\begin{code}
func(array[3])
\end{code}
などと記したわけだが、ここまで習ってきた配列引数は「配列全体を引数に取る」場合であって、1要素を取る場合ではない。配列全体を渡す方法は、次に示すとおりである。
\begin{itembox}[l]{配列引数関数の呼び出し}
配列全体を引数に取る場合、その関数の呼び出しの際の当該引数部は
\begin{code}
関数(配列名)
\end{code}
のように、配列の名前だけ\footnote{配列の名前だけを書いた場合、これはその配列の先頭アドレスを意味する。したがって、これは本質的にポインタ渡しであり、後に示す引数配列への直接操作が可能になる所以でもある。詳細はアドレスやポインタを学んだ後に理解されたい。}を記す。
\end{itembox}

配列全体を引数にとった例はリスト\ref{program8_3}の$l$.17にある。このように、実引数に配列名だけを記した場合は配列全体の引数となり、配列の後にインデックスを指定した場合は、通常の変数を渡すのと同様に、配列の特定の要素を関数に渡すことになる。

\minisec{引数の配列への直接操作}
配列全体を引数に取る場合に、注意しなければならないことがある。それは、配列全体を引数に取る場合には、配列の値が仮引数の配列に代入されて別の配列として扱われるのではないため、関数内部での配列の操作が元の配列に影響を与えるという事である。
\begin{boxnote}
\minisec{配列のシャッフル}
元々並んでいる配列をシャッフルする。
\minisec{解説}
$l$.13のforの終端値に意味はなく「大きい値」というだけである。\verb|arrayswap|は単に要素を交換するだけの関数であるが、この添字を乱数で決定することでシャッフルを実現している\footnote{これによるソート方法をボゾソートと呼ぶ。}。

\begin{lstlisting}[caption=配列のシャッフル,label=program8_4]
#include<stdio.h>
#include<stdlib.h>
#include<time.h>
#define NUM 128

void arrayswap(int ar[],int size,int i,int j);

int main(void){
  int array[NUM];
  int i,r1,r2;
  for(i=0;i<NUM;i++) array[i]=i;
  srand(time(NULL));
  for(i=0;i<NUM*NUM;i++){
    r1=rand()%NUM;
    r2=rand()%NUM;
    arrayswap(array,NUM,r1,r2);
  }
  for(i=0;i<NUM;i++)
    printf("%d%c",array[i],i%16==15?'\n':' ');
  return 0;
}

void arrayswap(int ar[],int size,int i,int j){
  int tmp;
  if(i>=size || j>=size) return;
  if(i<0 || j<0) return;
  tmp=ar[i];
  ar[i]=ar[j];
  ar[j]=tmp;
}
\end{lstlisting}
\end{boxnote}

リスト\ref{program8_4}では、\verb|arrayswap|関数で直接配列に対して操作を加えており、それが呼び出し側の配列\verb|array|に対する直接の操作となっている。これは、配列引数でやり取りされる値がアドレス\footnote{メモリ上でそのオブジェクトがどこに位置するかという番号のこと。第0講で簡単に紹介した他、ポインタの解説の際に再度取り上げる。}であり、呼び出された側の関数がアドレスを用いて元の配列を参照して利用する\footnote{このように、オブジェクトの実体を参照して利用する方法を\textbf{参照渡し}\index{さんしょうわたし@参照渡し}などと呼ぶ。だが、C言語での参照渡しは、実際にはアドレスという「値」を渡して、それを参照しているので、参照渡しとは実質「アドレスの値渡し」である。このことを意識すると、C言語の引数は常に値渡しであると言える。}ためである。従って、配列を引数に取る関数を作る場合、\textbf{仮引数の配列に対する操作は元の(実引数の)配列に対する操作となる}。このことに注意されたい。

\section{文字列}
すでに学んだ文字型を配列にすれば、文を格納することができそうである。この「文を格納する働き」はあちらこちらに現れるため、一般化した取り扱いのための約束事が定められている。それが、文字型の配列=\textbf{文字列}\index{もじれつ@文字列}に関する文法である。以下、文字列の扱い方について見ていこう。なお、ここではchar型に収まる１バイトの文字について説明することとし、日本語等2バイト以上の文字からなる文字列については付録で簡単に紹介するに留める。

\subsection{文字列とその取り扱い}
文字列は「文字型配列」であるので、配列としてアクセスできるはずである。ここではまず、文字列が配列である例を示す。
\begin{boxnote}
\minisec{Hello World再び}
"hello, world"と2度出力するプログラムを作成する。
\begin{lstlisting}[caption=Hello World再び,label=program8_5]
#include<stdio.h>

int main(void){
  int i;
  char str[13]={'h','e','l','l','o',',',' ','w','o','r','l','d'};
  for(i=0;i<13;i++) putchar("hello, world"[i]);
  putchar('\n');
  for(i=0;str[i]!='\0';i++) putchar(str[i]);
  putchar('\n');
  puts(str);
  return 0;
}
\end{lstlisting}
\end{boxnote}

\minisec{文字列に関する規則}
文字列は配列であるので、リスト\ref{program8_5}の$l$.8のように、1文字ずつアクセスすることができて、この時は通常の文字型変数として扱うことができる。だが、それとひとつ違う点が、$l$.8の条件式に見られる。
\\ \\　
ここに書かれている\verb|'\0'|は\textbf{NULL文字}\index{NULLもじ@NULL文字}(NULL character,NUL)であり、文字コード0の文字である。これは、文字列の終端を示す。

文字列を使う場合、"○文字まで許容する"というプログラムを書く場合が多いため、文字列の要素数満杯に文字を代入することはまずない。そのため、文字列は何処で終わるかを示す記号を用意した。それが文字列の終端を示すNULL文字であり、文字列を操作する関数などでも、"NULL文字が出てくるまで操作を続ける"というように処理が記述されている場合が多い。配列の場合はその要素数によって配列の長さを取得したが、文字列の場合はNULL文字によって文字列の長さを取得しているのだと考えれば良い。
\\ \\　
文字列を配列のように扱う場合などに、終端のNULL文字は忘れがちである他、文字列の大きさはNULL文字が入る分も考慮して許容文字数+1文字にする必要があるなど、注意しなければならない存在である。しかし、終端のNULL文字は文字列を扱う際にはなくてはならないものなのである。例えばputs関数は、終端にあるNULL文字を改行文字に変更して出力する関数で、NULL文字がなければ正しく動作しない。普段putsの中に文字列リテラルを指定しているが、文字列リテラルの終端にはNULL文字が補われているため、改行されるのである。

\minisec{文字列リテラル}
\textbf{文字列リテラル}\index{もじれつりてらる@文字列リテラル}(string literal)はダブルクォーテーションで囲まれた文字列で、文字列の定数、定文字列といった意味である。以下、文字列リテラルの性質について述べる。
\begin{itembox}[l]{文字列リテラルの性質}
\begin{itemize}
\item 文字列リテラルの終端にはNULL文字が補われている。
\item 文字列リテラルは定数であるので、それに対して書きこむことはできない\footnote{実際の文字列リテラルの型はconst char *型になる。これはポインタを学んだ後に再度理解して欲しい。}。
\item 文字列リテラルを用いて、
\begin{code}
char str[13]="hello, world";
\end{code}
のように初期化することも可能である。リスト\ref{program8_5}の$l$.5は配列であることを明示するため冗長に初期化したが、この書き方をしたほうが読みやすい。
\item 文字列リテラルは配列名と同じような扱いであり、\verb|"文字列リテラル"[i]|のようにすることで、文字列リテラルの第\verb|i|文字目を参照することができる。但し、書き込み不能である点と、0-offsetである点に注意しなければならない。
\end{itemize}
\end{itembox}

以上のように、文字列リテラルはあくまでも「書き換え不能で定義時から中身が定まっている文字型配列」であり
\begin{code}
const char str[13]="hello, world";
\end{code}
などとしているのと同じ事なのである。

\minisec{文字列の入出力方法}
リスト\ref{program8_5}では、出力にputs関数を用いたり、一文字ずつ出力したりした。今度は、入力された文字列を出力するプログラムを見てみよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{文字列の入出力}
入力された文字列を「オウム返し」にするプログラム。1回の実行で2行の入力に対応するが、1行目の入力には空白文字(スペース・タブ)を含んではならない。また、各行に入力される文字は63文字までとする。(文字列の大きさを64としたため)
\begin{lstlisting}[caption=文字列の入出力,label=program8_6]
#include<stdio.h>

int main(void){
  char str[64];
  scanf("%63s%*c",str);
  printf("%s\n",str);
  fgets(str,sizeof(str),stdin);
  puts(str);
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

文字列を出力する際には、先に述べたputs関数の他、printf関数で\verb|%s|書式指定子を用いる方法がある。ここで注意しなければならないのは、\verb|%s|を書式指定子にした場合、printfの可変引数に配列引数が入るという事である。先に述べた一次元配列を引数に取る関数と同様、ここでも配列名のみを引数にする必要がある(リスト\ref{program8_6}の$l$.6など)。
\\ \\　
入力の方法にはscanfを用いる方法とfgets関数を用いる方法がある。

scanfを用いる場合は、printf同様に\verb|%s|書式指定子を用いるが、この時、文字列の要素数を超えた代入(\textbf{バッファオーバーラン}\index{ばっふぁおーばーらん@バッファオーバーラン}(buffer over-run))はメモリアクセス上危険であるため\footnote{C99までには文字列の入力関数として\verb|gets|関数という関数があったのだが、バッファオーバーランを防止する機能がなく、しばしばハッキングの種となったため、 C11において廃止された。}、防止機構をつけなければならない。この防止機構となるのが入力幅の指定である。リスト\ref{program8_6}の$l$.5のように、\verb|%|の後に文字数を書くことで代入される文字数を制限することができ、これによりバッファオーバーランを防ぐことができる。

稀に"scanfで文字列を読み込むとバッファオーバーランを防げない"といっている人を見るが、これは上記のような入力幅指定機能を使っていないためであり、上手く使うことでscanfでも問題なく防げることを付記しておく\footnote{scanfで本当に問題になるのは、入力形式に従わない入力や、代入するとオーバーフローを起こすような値の入力である。これらは、他の関数の助けを借りて解決しなければならない。}。
\\ \\　
また、scanfで文字列を入力する場合には\verb|%[]|書式指定子や\verb|%[^]|書式指定子を用いる方法もある。\verb|%[]|指定子は、\verb|[]|内に文字集合を書き、その文字集合に属さない文字が出てくるまで文字列を読み込む、と書式を示す。この時、アルファベットや数字はハイフン(-)を用いて連続指定が可能である。例えば\verb|%[.0-9A-Fa-f]|という指定であれば、ドット・数字・大小文字のAからFのみからなる文字列を読み込み、これ以外の文字が出てきた時に読み込みをやめる、という指定になる。一方で\verb|%[^]|指定子は、\verb|[^|と\verb|]|の間に文字集合を書き、その文字集合に属する文字が出てくるまで文字列を読み込む(つまり、\verb|%[]|修飾子の論理否定形)という指定になる。それ故、scanfで1行分の文字列を読み込みたい場合などは\verb|%[^\n]|とすればよい(改行文字が出てくるまで文字列を読み込むため、1行読み込んでくれる)。これらの修飾子を用いた際の可変引数の書き方などは、\verb|%s|と同様である。
\\ \\　
scanfでの文字列入力について、注意と共にまとめておこう。
\begin{itembox}[l]{scanfでの文字列入力のまとめ}
\begin{itemize}
\item scanfで文字列を入力してもらう際には入力幅指定の上で\verb|%s|書式指定子または\verb|%[]|,\verb|%[^]|書式指定子を用いる。
\item 前項の書式指定子に対応する文字列は、文字列の名前のみを記し、\textbf{\&はつけない}\footnote{これは、一般の変数に対しては\&を付すことによって、その変数のアドレスを示すことになるのに対し、文字列などの配列はその名称を記すことによってアドレスを示すためである。詳細はポインタの解説の際に理解されたい。}。
\item \verb|%s|書式指定子では、標準の区切りとされているスペースやタブ、改行を含んだ文字列を入力してもらうことはできない。
\item \verb|%[]|は中に文字集合を伴い、その文字集合のみからなる文字列を読み込む。一方\verb|%[^]|は、中に書いた文字集合に含まれない文字からなる文字列を読み込む。どちらの文字集合指定でも、アルファベットや数字は\verb|-|を用いて連続指定ができる。
\item scanfを用いて(文字列に限らず)入力を行った場合、最後に使われた区切りの文字は「まだ読み取られていない文字」として残されたままになり、次の文字列読み込みの際に、その文字列の冒頭に入力されてしまう。これを防ぐため、文字列の入力が後に控えている場合、scanfの書式文字列の末尾に一文字読み飛ばしを意味する\verb|%*c|を付すと良い。
\end{itemize}
\end{itembox}
\\ \\　
次に、fgets関数による読み込みを見てみよう。
\begin{itembox}[l]{fgetsによる標準入力からの文字列入力}
fgets関数により標準入力から文字列を読み込む場合には
\begin{code}
fgets(読み込み先文字列名,読み込み最大文字数,stdin);
\end{code}
を実行する。
\end{itembox}

fgetsからの読み込みはまるごと1行か、もしくは読み込み最大文字数に達するかの、どちらか早い方である。すなわち、まるごと1行がすっぽり文字列に入るのであればその1行を\textbf{改行文字も含めて}読み込み、入らなければ最大文字数の部分まで読み込むことになる。最大文字数まで読み込んだ場合、次の呼び出しで続きから読み込むことになるが、この詳細についてはストリームの章に解説を譲る。

fgetsにおいて入力区切り文字となるのは改行のみである。このため、ある英文を読み込む時、単語毎に読み込むのであればscanfの方が利便性が高いという事になる。
\\ \\　
なお、scanf関数もfgets関数も、文字列がいっぱいになるまで読み込んだ場合以外は終端に自動でNULL文字を付してくれるので、自力でNULL文字を付す必要はない。

\subsection{文字列操作関数}
文字列を扱う関数は\verb|string.h|、\verb|stdio.h|、\verb|stdlib.h|を始めとして多くのヘッダファイルに入っており、挙げていくと枚挙に暇がない。これらについての説明は付録に譲るとして、ここではいくつかの例を示すに留める。
\begin{boxnote}
\begin{multicols}{2}
\minisec{DL速度計算プログラム}
接頭辞つきByte単位(B,kB,MB,GB,TB)で入力されるファイルを、同じく接尾辞つきbps単位(bps,kbps,Mbps)で入力される回線速度によってダウンロードするのにかかる時間を秒単位で出力するプログラムを作成する。入力の例としては
\begin{verbatim}
650MB
7.2Mbps
\end{verbatim}
等となり、この場合は650MBのファイルを回線速度7.2Mbpsで落とすのに必要な時間を計算せよという事になる。
\begin{lstlisting}[caption=ダウンロード時間の計算,label=program8_7]
#include<stdio.h>
#include<string.h>

int main(void){
  char str[2][64],file[8],net[8];
  double files,nets,second;
  
  fgets(str[0],sizeof(str[0]),stdin);
  fgets(str[1],sizeof(str[1]),stdin);

  sscanf(str[0],"%lf%7s",&files,file);
  sscanf(str[1],"%lf%7s",&nets,net);

  switch(file[0]){
  case 'T':
    files*=1000;
  case 'G':
    files*=1000;
  case 'M':
    files*=1000;  
  case 'k':
    files*=1000;  
  }
  files*=8;

  if(!(strncmp(net,"Mbps",4)))
    nets*=1000*1000;
  else if(!(strncmp(net,"kbps",4)))
    nets*=1000;
  second=files/nets;
  printf("%lf second\n",second);
  return 0;
}

\end{lstlisting}
\end{multicols}
\end{boxnote}
\minisec{文字列からの読み込み}
リスト\ref{program8_7}の$l$.11に見られるsscanf関数は、第1引数に示す文字列を、第2引数の書式指定文字列に従って解釈し、scanfと同様に可変引数に代入する関数である。ここではfgetsと組み合わせることによって利用したが、本来は文字列の書式チェックを行った後にこれを用いて読み込むと利便性が高い関数である。なお、sscanf関数は第1引数に文字列を持ってくること以外はscanf関数と同様に使うことができる。

\minisec{文字列の比較}
リスト\ref{program8_7}の$l$.26に見られるstrncmp関数は文字列同士を比較する関数である。第1引数の文字列と第2引数の文字列を先頭から比較し、第3引数に示される文字数まで同じであれば0を、同じでなければ非0(厳密には、比較した部分について、第1引数のほうが辞書順で早い場合は負の値、遅い場合は正の値)を返す。なお、文字列同士が完全に同じかどうかを比較する関数としてstrcmp関数もあり、これはstrncmp関数から第3引数をなくしたものである。

なお、文字列同士の比較を
\begin{code}
str1==str2
\end{code}
のような形式で行なっても、正しい結果は得られない。これは、何度か述べたように、文字列の名前だけ書いた場合には文字列のあるアドレスを表すだけであり、上記の文が「文字列\verb|str1|と文字列\verb|str2|のアドレスが等しいかどうか」=「文字列\verb|str2|が文字列\verb|str1|そのものであるかどうか」という意味になってしまうためである。一方、strcmp系関数を用いた場合は「文字列\verb|str1|の中身が文字列\verb|str2|の中身に比べてどうか」という事になるので、文字列が同じかどうかの比較をすることができる。

\minisec{その他の文字列関数}
文字列を取り扱う関数には他にも多くある。
\begin{itembox}[l]{文字列を扱う関数の例}
\begin{itemize}
\item stdio.hには、sprintfやsnprintf等、printfと同じ形式で出力先を文字列にした関数がある。
\item stdlib.hには、strtodやstrtolなど、文字列から数値を読みだして整数型や浮動小数点数型の値を返す関数がある。
\item string.hは文字列に関する主要な関数が揃っており、長さを求めるstrlen関数や文字列への代入を行うstrcpy/strncpy関数、文字列同士の結合を行うstrcat関数など多ような関数がある。
\end{itemize}
\end{itembox}

文字列を扱う際には、先の「文字列が配列である」「終端文字がNULL文字である」という概念さえ理解しておけば大抵の処理を書くことができるが、必要となるであろう処理の多くは標準関数として提供されている。この為、付録Aなどを見て文字列を扱う関数にはどのようなものがあるか知っておくのも良い。
\newpage
\begin{shadebox}
\section*{本講の要点}
本講では最初に派生型について述べた後、静的配列と文字列について学習した。
\subsection*{基本型と派生型}
\begin{itemize}
\item C言語に用意されている整数型・浮動小数点数型等をまとめて基本型という。
\item 基本型に対して関数・配列・構造体・共用体・ポインタの操作を有限回行なってできる型を派生型という。
\item 派生操作は組み合わせることができる。
\item void型や列挙型等、基本型でも派生型でもない型が存在する。
\end{itemize}

\subsection*{静的配列}
\begin{itemize}
\item 配列とは、メモリ上に連続して配置された変数に通し番号をつけたものである。
\item \textbf{配列のご利用は計画的に。借り過ぎ使いすぎに注意しましょう。}
\item 配列の宣言時には[要素数]を配列名の後ろに付す。
\item 配列は0-offsetであり、要素数-1番がその配列の末項である。
\item 配列を呼び出す際には配列外アクセスをしないように注意しなければならない。
\item 配列の添字を2個以上にすることもできる(多次元配列)。
\item 配列にアクセスする際にはシーケンシャルになるようにアクセスしたほうが効率がよく、特に多次元配列の場合後側の添字から順に変化させると良い。
\item 配列引数関数を作る場合、配列の要素数も同時に教えるべきである。
\item 配列引数関数に配列全体を実引数として渡す場合には配列名のみを記す。
\item 配列引数関数での配列操作は実引数の配列にも影響を及ぼす。
\end{itemize}

\subsection*{文字列}
\begin{itemize}
\item \textbf{文字列とは文字型の配列のこと}で、終端がNULL文字によって示される。
\item 文字列入力の際にはバッファオーバーラン防止処理を施さなければならない。
\item 文字列リテラルは書き換えることができない。
\item 文字列を扱う関数はstring.hはじめ、stdio.hやstdlib.hなどにも入っている。
\end{itemize}
\end{shadebox}

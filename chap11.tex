前講で学んだポインタを活用することで、C言語では非常に多くの機能を実現することができる。ここではポインタをより活用する方法について学んでいく。
\section{各種派生型へのポインタ}
ポインタは基本型に用いてももちろん有用であるが、各種の派生型と組み合わせる、すなわち派生型へのポインタを作ることでより多くの機能を実現できる。ここでは、派生型に対する様々なポインタを紹介し、派生型全体への理解を深めることにしよう。
\subsection{配列とポインタの関係〜ポインタは配列エイリアスか〜}
配列とポインタは似たものとされ、しばしば混同されていることもあるが、実際には別の概念である。ここでは、ポインタを用いて一次元配列を利用する方法を学び、その違いについて考えていくことにしよう。
\begin{boxnote}
\minisec{配列の総和(積み残し誤差回避型)}
積み残し誤差を回避するため、\textbf{分割統治法}\index{ぶんかつとうちほう@分割統治法}(Divide and conquer algorithm,\textbf{D\&C}\index{D\&C|see{分割統治法}})を用いて総和を計算する関数を作成する。
\minisec{解説}
配列を2項ずつまとめ、次いでその「2項ずつまとめたもの」を2つずつまとめ…を繰り返していくと、最終的には総和になる。この計算においては、和を計算する2項の絶対値の差異が緩和されやすく、積み残し誤差が起こりにくくなると言える。これを逆に見れば、総和→半分ずつの総和の和→四半分ずつの総和の和の和というように、分割してその部分の和を計算する再帰ができることがわかる。このように大きな問題をその部分問題に分割して解く方法が分割統治法である。
\\ \\
なお、ここで作成する関数は、総和を取りたい区間の先頭アドレスと終端アドレスを引数に取るものとする。
\end{boxnote}

\begin{boxnote}
\begin{lstlisting}[caption=分割統治法による総和,label=program11_1]
#include<stdio.h>

double rec_sum(double *from,double *to){
  int tmp;
  if(from==to) return *from;
  tmp=(to-from)/2;
  return rec_sum(from,from+tmp)+rec_sum(from+tmp+1,to);
}

int main(void){
  double array[]={1E3,2.2E2,3.8,-4.66,5.2,0.0001};
  printf("%f\n",rec_sum(array,array+5));
  return 0;
}
\end{lstlisting}
\end{boxnote}
\minisec{配列エイリアスとしてのポインタ}
先のリスト\ref{program11_1}のプログラムにおいて用いられているポインタは配列を用いることを前提としたポインタ、いわば「配列の別名」=エイリアスとしてのポインタである。配列はメモリ上に連続的に並んでいるという特性から、ポインタを用いて容易に配列の各要素にアクセスできる。配列引数の関数は、呼び出し側からは、それと等価なポインタ引数の関数とみなされる\footnote{完全に等価、というわけではない点に注意。定義している関数内ではやはりポインタと配列は別物として扱われていて、左辺値にできないなどの差異がある。後で学ぶ多次元配列の場合には、もっと大きな違いが見られる。}し、\verb|[]|を用いた構文は、コンパイル時に\verb|*( + )|を用いた構文に置き換えられたりする。ここまでは前講に説明した。
\\ \\　
翻ってリスト\ref{program11_1}を見てみれば、これは配列を扱うためのポインタを用意して、これを用いて総和処理を行なっている。始点と終点を与えることによって比較的簡単に部分和を計算することもできる。このように、ポインタを配列の読替えとして用いる場合は少なくない。だが、このリスト\ref{program11_1}の\verb|rec_sum|関数は、「違う配列であっても」「連続したメモリ領域であれば」総和をとってしまう。構造体を考えてみれば、
\begin{code}
struct tag{
  double a[20];
  double b[20];
}st;
\end{code}
などとしておけば、穴のない限り\verb|a|と\verb|b|にまたがった総和を計算できてしまうのである。これを防ぐためにも、前講で口を酸っぱくしていったとおり、\textbf{ポインタは何を指し示しているか明確に}して使わなければならないのである。
\minisec{restrict修飾子}
先のリスト\ref{program11_1}は同じ配列を2つのポインタで扱った。これとは逆に、引数の2つのポインタが各々違う配列を示す場合がある。引数の2つの配列が違うとわかっていれば、書ける処理が増えるし、最適化もしやすくなる。これを実現するのがC99において導入された\textbf{restrict修飾子}\index{restrictしゅうしょくし@restrict修飾子}である。restrict修飾子は関数の引数としてポインタを用いる場合に限り利用される修飾子で、2つ以上のポインタが指し示す領域(2つのポインタを用いてその関数内でアクセスされる領域)に重複がない、という事をコンパイラに知らせる役目を担っている。これにより、コンパイルの際の最適化が十分に行われ、プログラムの実行が速くなることがある。なお、restrict修飾子をつけたからと言って、重複領域へのアクセスがコンパイルエラーとなるわけではないので、その点には注意されたい。
\\ \\　
restrict修飾子を用いる場合は、関数の引数において
\begin{code}
type func(restrict type *p1,restrict type *p2)
\end{code}
のように、型名の前にrestrict修飾子を付せば良い。

\minisec{配列オフセットの変更}
Cの配列は0-offsetである。これは、ポインタと配列の対応を考えれば自然に理解できることであるが、これを逆用して、配列を1-offsetにすることも可能である。また、数学などで正負両方を取りたい場合などに、配列の添字を正負両方に伸ばすようなことも可能である。これは、実に単純で
\begin{code}
int a[5],*b;
b=a-1;
\end{code}
などとすれば良いのである\footnote{ただし、1-offsetにしたい場合は、配列のサイズを少し広げて、0を使わないという前提でコーディングしたほうが手っ取り早い。どちらかといえば、負の項の配列などを作りたい場合に便利な手法であろう。}。この場合、\verb|b[0]|を参照しようとすると配列外参照になるので注意されたい。この応用例を見てみよう。
\begin{boxnote}
\minisec{Pascalの三角形}
Pascalの三角形を出力するプログラムを作成する。
\minisec{解説}
パスカルの三角形の何段目まで出力するかは定数マクロ\verb|N|によって規定するものとする。例えば\verb|N|が3であれば、これは$(x+1)^2$の係数を並べたところまで出力する、という事になる。つまり、$(x+1)^{N-1}$の係数を並べた段までを出力するという事である。なお、配列の添字はいずれも0-offsetであり、指数に対応したものであることを付記しておく。
\end{boxnote}
\begin{boxnote}
\begin{lstlisting}[caption=Pascalの三角形,label=program11_2]
#include<stdio.h>

#define N 17

int main(void){
  unsigned int array[N*(N+1)/2];
  unsigned int *p[N];
  int i,j,k;

  for(i=0,k=0;i<N;i++){
    p[i]=array+k;
    k+=(i+1);
  }

  for(i=0;i<N;i++)
    for(j=0;j<=i;j++)
      p[i][j]=(j==0 || j==i)?1:(p[i-1][j]+p[i-1][j-1]);

  for(i=0;i<N;i++)
    for(j=0;j<=i;j++)
      printf("%5u%c",p[i][j],(j==i)?'\n':' ');
  return 0;
}
\end{lstlisting}
\end{boxnote}

リスト\ref{program11_2}では、ポインタの配列\verb|p|を用意し、それに対して、\verb|array|の適切な位置を割り当てて、不揃いな2次元配列を実現している。いわば、一本の配列を切って分けた、という形である。その、分けたものを順に\verb|p[0],p[1],...|とすることによってあたかも2次元配列であるかのように利用しているのである。これも配列(の一部分)に名前をつけているという意味で、ポインタを配列エイリアスとして利用している例と言えるだろう。なお、蛇足ながら、後半に出てくる\verb|p[i][j]|は、\verb|*(p[i]+j)|と書いたほうが、\verb|p|がポインタであることが明確になってわかりやすいかもしれない。

\minisec{配列とポインタの違い}
ここまでの説明で、ポインタは配列のエイリアスとして使えるという事を記してきたが、ポインタは決して配列エイリアスのためだけにあるのではないし、\textbf{ポインタと配列は違うもの}である。
\\ \\　
配列とポインタの最たる違いは、配列はそれが定義された段階でその大きさ分のメモリが確保されるが、ポインタは他で実体を用意しなければならない、という点である。先までの例でも、配列を前もって用意しておいて、それに対するポインタを用いることでアクセスをしているのである。決して、ポインタを宣言することによって自動的に実体ができるのではない。

また、ポインタはあくまでもアドレスを格納するための変数である、という事を忘れてはならない。配列エイリアスとしてポインタを用いた時、先の実体確保を忘れるのと同じぐらいよく間違えるのが\verb|sizeof|演算子関連である。配列の場合は\verb|sizeof|で全体のサイズを取ることができ、それによって個数を知ることができた。だが、ポインタでは、\verb|sizeof|を用いても配列全体の大きさを取ることはできず、環境によって定まっているポインタの大きさが返ってくるだけである。

このように、ポインタは配列エイリアスとして用いることもできるのだが、決して配列と同じものではない、という点を理解しておきたい。

\minisec{浅いコピーと深いコピー}
配列をベクトルとしてみなして計算する場合など、配列そのものを交換したりコピーしたりする必要が出てくる。この時(特に交換するとき)には、ポインタをエイリアスとして用いた\textbf{浅いコピー}\index{あさいこぴー@浅いコピー}(shallow copy)を用いると高速に交換できる。だが、\verb|memcpy|関数などを用いて行う\textbf{深いコピー}\index{ふかいこぴー@深いコピー}(deep copy)を用いる場合とは違った問題も生ずる。
\\ \\　
浅いコピーはポインタの間でその参照先アドレスをコピーすることによって、あたかもコピーしたかのように見せる方法である。例えば、
\begin{code}
int array[2][5];
int *p[2],*tmp;
p[0]=array[0],p[1]=array[1];
tmp=p[0],p[0]=p[1],p[1]=tmp;
\end{code}
などとすれば、最初は\verb|array[0]|を参照しているポインタ\verb|p[0]|が、今度は\verb|array[1]|を指すようになる。このように、配列エイリアスとしてのポインタを用意し、その参照先を変えることで役目を変えれば、繰り返し処理などが書きやすくなるという利点がある。だが、浅いコピーはあくまでもアドレスのコピーであるので、その実体はひとつしかないという点に注意しなければならない。つまり、
\begin{code}
int array[5],*p[2];
p[0]=p[1]=array;
\end{code}
とした場合に、\verb|p[0]|はたしかに\verb|p[1]|のコピーであるが、\verb|*(p[1]+3)=3|のような\verb|p[1]|側の書き換えが\verb|p[0]|にも影響を及ぼす。その一方で、浅いコピーはアドレスだけのコピーであるので、配列の大きさに依存せず高速にコピーすることができる(定数時間)。
\\ \\　
一方で、深いコピーは実体のコピーを行う方法である。先に浅いコピーにより2つの配列を交換する方法を見せたが、これを深いコピーで実装すると次のようになる。
\begin{code}
int array[2][5],i,tmp;
for(i=0;i<5;i++){
  tmp=array[0][i];
  array[0][i]=array[1][i];
  array[1][i]=tmp;
}
\end{code}
のようになる。ここではメモリの節約のために、別の変数をひとつだけ用意したが、交換用に別の配列を用意して、それに一旦コピーした後に…という方法もある(コピーの際にはmemcpy関数を用いると簡潔に書くことができる)。このように、配列の実体そのものをコピーするのが深いコピーであり、実体を複数作ることができる。そのかわり、コピーには時間がかかる(配列のサイズ$n$に対して$O(n)$程度)ため、何度も交換処理を行うような場合には使いづらい。
\\ \\　
このように、配列のコピーには、実体をコピーする深いコピーと、参照のみをコピーする浅いコピーがあり、状況に応じて使い分けなければならない\footnote{Javaなどでは、普通にコピーした場合、基本型は深いコピーであるが参照型は浅いコピーになってしまうため、インスタンス(構造体型変数を拡張したようなもの)のコピーの際に注意しなければならないなど、これらのコピーをより強く意識する必要がある。}。

\subsection{文字列リテラルについて}
ポインタは場所を示すため、配列のエイリアスとして用いたり、配列で条件に合致する位置を示したり、という使い方ができた。実際、前講で扱った文字列に関する関数群はポインタと共に利用されていた。これらの利用は、先に扱った配列へのポインタと同じように見なせる。というのも、文字列はあくまでも文字型変数からなる配列だからである。だが、少しだけ違った扱いをするものがある。それが、文字列リテラルである。非常に混同しやすいので、注意してみていくことにしよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{もっとHello World}
Hello Worldと出力するプログラムを、ポインタを用いて書いてみる。
\minisec{解説}
配列strには"hello, "が格納されており、ポインタpは(メモリの別の部分に配置されている)"world"を示している。
\begin{lstlisting}[caption=Hello World(3回目),label=program11_3]
#include<stdio.h>

int main(void){
  char str[]="hello, ";
  const char *p="world";
  printf(str);
  puts(p);
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
なお、リスト\ref{program11_3}では、printfの第1引数が書式文字列でも文字列リテラルでもないため、コンパイル時に警告が出るかもしれないが、無視して実行して問題ない。
\minisec{文字列リテラルによる初期化}
リスト\ref{program11_3}では、$l$.4と$l$.5でそれぞれ文字列リテラルを用いて初期化を行なっている。$l$.4は不完全配列のように見えるため、ポインタと等価であると思ってしまうかもしれないが、それは誤りである。これら2つの文は、全く違う処理を行なっている。

$l$.4の処理は、strという文字型の配列を定義し、それについて、前から順にh,e,$\cdots$と要素を代入して初期化する処理である。一方、$l$.5の処理は、文字列リテラルへのポインタの初期化である。文字列リテラルといえど、データであるからにはメモリ上に配置されている。そのアドレスを\verb|p|というポインタに代入しているのである。したがって、\verb|str[]|は自分で定義された実体を持つが、\verb|p|はあくまでポインタであり、メモリ上に置かれたリテラルへの参照にすぎないのである。すなわち、$l$.4の初期化は深いコピーによる初期化、$l$.5の初期化は浅いコピーによる初期化である。似たように見える処理であるが、書き換えの可否などで違いを感じることになる。
\minisec{ポインタとconst}
もうひとつ、$l$.5のconstが気にならなかっただろうか。const修飾子は、宣言を読む際に厄介な存在となりがちである。だが、決まりはただひとつ「直後の記号を修飾する」ことを覚えておけばいい。

$l$.5に着目すると、constはcharの前に付いている。したがって、\verb|p|はconst char型への、書き換え任意なポインタである。そして、文字列リテラルはいずれも書き換え不能(const char型)であるので、これに対するポインタとしては適切なものになっているわけである。このように、文字列リテラルを用いる際にはconst charであることを忘れないようにしなければならない。
\\ \\　
一方で、ポインタをread onlyにしたい場合はどうすればよいだろうか。この場合は、やはりconstが直後を修飾するという決まりを用いて、変数名の直前(ないし、\verb|*|の直前)にconstを配すれば良いのである。たとえば、
\begin{code}
const char * const p="str";
const char const * s="chr";
\end{code}
などとすれば、\verb|p,s|はともにRead Onlyのポインタとなる。ここで記した例では、最初のconstはcharにかかっており、後側のconstはpないし\verb|*|にかかっているのである\footnote{このテクニックを使っても判別が難しい例として、\verb|const char * const p1,*p2|のような宣言がある。この場合の\verb|p2|は\verb|const char|型への読み書き可能なポインタであるが、わかりづらいので、分けて書いたほうが良いだろう。}。
\\ \\　
以上のように、ポインタとconstが絡むと、わかりづらい場合が出てくる。だが、constはすぐ後ろを修飾するという事さえ押さえておけば、構文で困ることはないだろう。最後に、constの位置による違いをまとめておく。
\begin{itembox}[l]{constとポインタ}
\begin{itemize}
\item \verb|const type * ...|の記述は、参照先実体がRead Onlyであるようなアドレスを格納するためのポインタである。
\item \verb|type * const ...|ないし\verb|type const * ...|の記述は、ポインタの保持するアドレスがRead Onlyであるようなポインタである。
\end{itemize}
\end{itembox}

\subsection{関数へのポインタ}
関数型をそのまま引数にとったり配列にしたりすることはできない。だが、例えば「入力される値に応じて用いる関数を変える」とか「関数に対して処理を行う関数を作りたい」という場合、引数や配列として使えると便利である。これを実現するのが関数へのポインタである。今述べた事例は、関数を扱うと言ってもその返却値に興味があるのではなく、関数そのものに興味があるのだから、ポインタを使うのは自然なことだろう。

\minisec{関数ポインタの宣言と利用}
いきなりだが、関数ポインタの宣言方法を示そう。
\begin{itembox}[l]{関数ポインタの宣言方法}
関数へのポインタを宣言する際には、
\begin{code}
関数の型 (*ポインタ名)(引数リスト);
\end{code}
とする。これにより、関数の型と引数リストの型及び順序が一致する関数のアドレスを保持できる。 
\end{itembox}

関数ポインタを使うメリットは最初に述べたとおりである。具体例として、関数の配列を作成し、各々の数値積分を行うプログラムを見てみよう。
\begin{boxnote}
\minisec{関数の台形積分}
幾つかの関数の積分を、台形積分を用いて計算してみる。
\minisec{解説}
\begin{itemize}
\item 関数integralは、第1引数のポインタで示される関数を、第2引数fromから第3引数toの区間で、刻み幅を第4引数hとして、台形積分公式により定積分し、その値を返す関数である。
\item \textbf{台形積分}\index{だいけいせきぶん@台形積分}(trapezoidal integral)公式は、区間を台形に近似して積分する公式である。小区間$[a,a+h]$の積分を台形の面積として近似すれば、
\[\int^{a+h}_{a} f(x)dx\approx \frac{h}{2}\left(f(a)+f(a+h)\right)\]
と近似することができる。当然、$h$が大きいほど近似精度は悪くなるので、区間$[a,b]$での積分は$[a,a+h],[a+h,a+2h],\cdots,[a+kh,b]$のように区切り直し、各々の近似値を求めて総和を出す形で求める。
\end{itemize}
\end{boxnote}
\begin{boxnote}
\begin{itemize}
\item 今回は関数のポインタの配列を作成し、cos,cosh,floor,exp,fabsの各関数の積分を計算・出力した。
\end{itemize}
\begin{lstlisting}[caption=関数の台形積分,label=program11_4]
#include<stdio.h>
#include<math.h>

double integral(double (*func)(double),double from,double to,double h);

int main(void){
  double (*funcs[5])(double)={cos,cosh,floor,exp,fabs};
  double var;
  int i;

  for(i=0;i<5;i++) printf("%lf\n",integral(funcs[i],-1,1,1.0/1024));
  return 0;
}

double integral(double (*func)(double),double from,double to,double h){
  unsigned int i,j,k,n;
  double ret=0,sect=to-from;
  for(i=0;i*h<sect;i++)
    ret+=h*(func(i*h)+func((i+1)*h))/2;
  return ret;
}
\end{lstlisting}
\end{boxnote}

リスト\ref{program11_4}では、先に挙げた「関数の配列化」と「関数引数の関数」を実現している。これを見てみれば、次のようなことがわかるだろう。
\begin{itembox}[l]{関数ポインタの利用}
\begin{itemize}
\item 関数のアドレスは、その関数の名前だけを書くことで取得できる。
\item ポインタで示されている関数も、ポインタ名の後に引数リストを付けることで呼び出すことができる。
\end{itemize}
\end{itembox}

これらの特徴のうち、後者については、
\begin{code}
(*func)(...)
\end{code}
のように、間接演算子を用いても参照可能である。だが、いちいち括弧と間接演算子を付すのは煩わしく、引数リストによって実体かアドレスかが区別できるため、通常関数ポインタの直後に引数リストを記して呼び出す。
\\ \\　
なお、ここでは標準関数のポインタを取得したが、自作関数のポインタなども同様に取得できる。また、注意すべき点として、引数リストが一致しない関数のアドレスは、ポインタに代入することができない(キャストすれば可能であるが、適切に扱われるかどうかは保証されない)。すなわち、関数ポインタは、返却値・引数リストが完全に一致する関数のアドレスのみを保持できる。

\minisec{関数ポインタを利用する標準関数}
ここで紹介した関数ポインタを引数にとる標準関数も存在する。atexit関数やqsort関数、bsearch関数などがそうである。紙数の都合上ここでは名前のみの紹介にとどめるが、興味があれば調べられたい(一部は後の講で扱う)。

\subsection{ポインタへのポインタ}
ポインタは変数である。変数であるからには、もちろんアドレスが存在する。それを保持するためのポインタが\textbf{ポインタのポインタ}\index{ぽいんたのぽいんた@ポインタのポインタ}(pointer to pointer)である。以下、「ポインタのポインタ」や「ポインタのポインタの...ポインタ」と記すのは煩わしいので、これらをまとめて多重ポインタと呼ぶことにする。
\minisec{多重ポインタの概念と利用}
多重ポインタは、要するに「ポインタ変数のアドレスを格納するためのポインタ変数」である。つまり、指示先にもまたポインタがある、という事である。これは、宣言や間接演算子の際の\verb|*|を多重にして扱う。ポインタppがポインタpのアドレスを格納しており、ポインタpが変数varのアドレスを格納しているならば、
\begin{code}
*(*pp)
\end{code}
のようにすれば、varの値を参照することができる。同様に、多重ポインタの宣言は
\begin{code}
int **pp;
\end{code}
と、*を重ねてやればよい。これを用いることで、配列エイリアスを多次元配列のように用いることができるなどの利点がある。ここでは、行列を作り、その行交換を行う関数を見てみることにしよう。
\begin{boxnote}
\minisec{行列の表現例と行交換}
ポインタによるエイリアスを用いて行列を表現し、行交換を行う。
\minisec{解説}
\begin{itemize}
\item 行列の実体は一次元配列numで用意しておき、その行を表すポインタとしてmatを、全体を表すポインタとしてmatrixを用意した。
\item 交換は浅いコピーによっておこなっている。
\end{itemize}
\end{boxnote}
\begin{boxnote}
\begin{lstlisting}[caption=行列の表現例と行交換,label=program11_5]
#include<stdio.h>

#define NUM 9

void lineswap(double **a,double **b);

int main(void){
  double nums[NUM*NUM];
  double *mat[NUM],**matrix;
  int i,j,k;
  for(i=0;i<NUM;i++) mat[i]=nums+i*NUM;
  matrix=mat;

  for(i=0;i<NUM*NUM;i++) nums[i]=i;
  
  lineswap(&mat[0],&mat[NUM-1]);
  for(i=0;i<NUM;i++)
    for(j=0;j<NUM;j++)
      printf("%2.0lf%c",*(*(matrix+i)+j),(j==NUM-1)?'\n':' ');
  return 0;
}

void lineswap(double **a,double **b){
  double *tmp;
  tmp=*a;
  *a=*b;
  *b=tmp;
}

\end{lstlisting}
\end{boxnote}

ポインタが置かれているアドレスの取得には、\verb|&|演算子を用いるか、ポインタが配列になっているならばその配列名を記せばよい。これは通常の変数と同じであるので問題ないだろう。また、ここではエイリアスのように書かなかったが、$l$.19のprintfの第2引数は\verb|matrix[i][j]|と書いても同じである。

このように、多重ポインタは多次元配列と相性がよく、しばしば多次元配列のように扱われる。だが、両者は全く別物である。今度は、それを説明していくことにする。

\minisec{多次元配列へのポインタと多重ポインタの差異}%http://www.nurs.or.jp/~sug/soft/tora/tora10.htm
配列エイリアスとしてのポインタは先に紹介したが、多次元配列とポインタの関係は先にも増して難しい。ここでは、これらの差異を見ていくことにしよう。
\\ \\　
以下、ポインタと配列について、次のように仮定して説明を行う。
\begin{code}
int array[3][5];
int num[15];
int *p[5]={num,num+3,num+6,num+9,num+12},**pp=p;
\end{code}
また、サイズ\verb|n|の配列型を\verb|int[n]|型等と記す。
\\ \\　
上記の例では、どちらも
\begin{code}
array[2][3];
pp[2][3];
\end{code}
のようにして各要素へのアクセスを行うことができる。このことから、二つの動作は一見同じように見えるのだが、
\begin{code}
pp=array
\end{code}
として、アクセスを試みても、コンパイルエラーになってしまう。同じような記法、同じような動作なのだが、内部では違ったものとして扱われているのである。
\\ \\　
まず、多次元配列の場合を考えよう。派生の定義に戻って考えれば、2次元配列(=配列の配列)とは配列派生を2回行った型であると言える。すなわち、\verb|int|型を5個連ねて\verb|int[5]|型とし、これを3個連ねて\verb|int[3][5]|型のarrayを定義したのである。この派生をたどればわかるとおり、\verb|array[2][3]|という形のアクセスのうち、\verb|array[2]|の部分は、\verb|int[5]|型へのアドレスである。つまり、\verb|array[2]|は、\verb|array|の先頭アドレスから\verb|int[5]|型2個分進めた箇所、という意味である。そして、そこから今度は、\verb|int|型3個分進めた箇所(の要素)を指し、これによって要素へのアクセスを行なっている。アクセスの状況とその時の型を、図\ref{fig11_1}のように対比してみるとわかりやすい。
\begin{figure}[h]
\centering
\begin{tabular}{ll}
指す型&解釈部分\\
\verb|int[3][5]|&\verb|array| \\
\verb|int[5]|&\verb|array[2]| \\
\verb|int|&\verb|array[2][3]|
\end{tabular}
\caption{多次元配列へのアクセスとそれが指す型の対比}\label{fig11_1}
\end{figure}

このアクセス方式や派生過程からわかるとおり多次元配列は必ずその全要素が連続的に配置されている。すなわち、\verb|array[2]|と\verb|array[1]|は、必ず\verb|sizeof(int)*5|バイトの違いを持たねばならない。この\verb|array[1]|と\verb|array[2]|が連続的であるという点は多次元配列にしかない特徴である。
\\ \\　
一方、ポインタのポインタを用いたアクセスでは、連続性は各段階においてしか仮定されない。
\begin{code}
pp[2][3];
\end{code}
のコードは、あくまでもポインタとして次のように解釈される：ポインタ\verb|pp|が指している部分から\verb|int *|型2個分進んだ場所にある\verb|int *|型のポインタの指示先を\verb|pp[2]|とする。この時、\verb|pp[2]|の指示先から\verb|int|型3個分進んだ時に、そこにある要素の値を\verb|pp[2][3]|としてアクセスする。このことから、\verb|pp[1]|と\verb|pp[2]|の指示先に連続性は仮定されない。更に、アクセスの途中で用いられている型が違うこともわかるだろう。
\\ \\　
ここまでの内容を鑑みれば、\verb|int **|型のポインタに二次元配列の先頭アドレスを代入できないことは明らかであろう。途中で挟まれるポインタがなく、型がわからない=飛ぶ量がわからない為、\verb|pp=array|などとしてしまうと\verb|pp[2]|が計算不能になってしまう。つまり、\verb|pp[2]|と書いた時、これは\verb|pp|から、派生元の型が何であるポインタ2個分なのか、コンパイラは判断できないのである。そのため、仮に先の\verb|array|に対して、そのエイリアスとなるポインタ\verb|parray|を作るならば、その宣言は次のようにしなければならない。
\begin{code}
int (*parray)[3];
\end{code}
この宣言では、\verb|int[3]|型へのポインタとして\verb|parray|を宣言するため、\verb|*parray|を括弧でくくっている。このように多次元配列に対するポインタを作る場合は、型を丁寧に解釈し、派生元の型との齟齬が無いように宣言を書かなければならない。

\section{メモリの動的確保}
ここまで、静的配列を用いて実体を確保してきた。だが、スタック領域は決して大きくない上、静的配列は前もって定められた要素数以上使うことはできない。これらの欠点をなくし、ヒープ領域を動的に確保して実現されるのが\textbf{動的配列}\index{どうてきはいれつ@動的配列}(dynamic array)である。
\subsection{動的配列の概念と利用法}
動的配列は先に述べたとおり、ヒープ領域に確保され、実行時に長さを決めることができる配列である。静的配列に比べて自由度が高いが、有効利用にはポインタへの理解が必要になるし、通常、人間の手で確保/解放\footnote{C言語にはないが、不要になったメモリ領域を自動解放してくれる機能として\textbf{ガーベッジコレクション}\index{がーべっじこれくしょん@ガーベッジコレクション}(garbage collection,GC)を採用している言語もある。}を行わなければならない(自由には責任が伴う！)という難点もある。静的配列に比べて自由度が高いという事は、管理をきちんと行わなければならないという事でもあるため、気をつけて扱わなければならない。
\minisec{動的配列の利用手順}
動的配列の利用手順は、次のようになる。
\begin{itembox}[l]{動的配列利用の手順}
\begin{enumerate}
\item 動的配列の確保先アドレスを格納するためのポインタを宣言する。
\item メモリ領域を確保し、その先頭アドレスをポインタに割り当てる。
\item 動的配列を用いた処理を行う。必要に応じて拡大/縮小を行う。
\item 動的配列の利用が終了したらメモリ領域を解放する。
\end{enumerate}
\end{itembox}

この手順を見てもらえばわかるとおり、動的配列は静的配列に比べて利用が面倒である。また、静的配列とは違い、配列を取り過ぎてもコンパイルエラーにならないし(当然、配列の個数は実行時に決まるため)、解放せずに終了してしまうとそのメモリが無駄に確保され続けたままになってしまう\textbf{メモリリーク}\index{めもりりーく@メモリリーク}(memory leak)という現象を起こしてしまう。そのため、動的配列を用いる場合は、次の点に注意しなければならない。
\begin{itembox}[l]{動的配列利用上の注意}
\begin{itemize}
\item 動的配列確保の際に、確保できなかったという返却値だったら、適切な例外処理を施すこと。
\item 動的配列を利用している際は、終了時に必ずその解放を行うこと。\footnote{exit関数などを用いて終了するようなプログラムの場合、atexit関数を用いて、終了時の解放処理を登録しておくと便利である。}
\end{itemize}
\end{itembox}
\\ \\　
なお、動的配列へのアクセス方法は、ポインタを用いたアクセスと同じである。すなわち、ポインタ\verb|p|がある動的配列を指している時、その第\verb|i|要素は
\begin{code}
p[i]
\end{code}
あるいは
\begin{code}
*(p+i)
\end{code}
のようにして表現することができる。このように、動的配列を取り扱う場合は、ポインタ/配列と同様にして取り扱うことができるのである(特に、配列エイリアスとしてのポインタの扱いはちょうど対応する)。従って、動的配列を学習する上で押さえなければならないのは、確保と解放である。

\minisec{動的配列の確保と解放}
では、動的配列を用いた例を見てみよう。
\begin{boxnote}
\minisec{Pascalの三角形再び}
Pascalの三角形を出力するプログラムを動的配列を用いて作成する。
\minisec{解説}
今度は、何段目まで出力するか入力してもらい、必要な分だけメモリ確保することにした。ポインタのポインタを用いて多次元配列のような配列を実現しているが、\verb|pp[0],pp[1],...|の各指示領域に連続性がない点には注意されたい。もしも多次元静的配列同様に連続性のある多次元動的配列を作りたいのであれば、まず一次元配列を確保し、それにエイリアスを付していく形になる。
\end{boxnote}
\begin{boxnote}
\begin{lstlisting}[caption=Pascalの三角形(動的配列版),label=program11_6]
#include<stdio.h>
#include<stdlib.h>
typedef unsigned int u_int;

int main(void){
  u_int **pascal,*pp;
  int i,j,k,n;
  scanf("%d",&n);
  
  if((pascal=(u_int **)malloc(n*sizeof(u_int *)))==NULL) return -1;
  for(i=0;i<n;i++){
    if((*(pascal+i)=(u_int *)calloc(i+1,sizeof(u_int)))==NULL){
      for(j=0;j<i;j++) free(*(pascal+j));
      free(pascal);
      return -1;
    }
  }
  
  for(i=0;i<n;i++) for(j=0;j<=i;j++)
      pascal[i][j]=(j==0 || j==i)?1:(pascal[i-1][j]+pascal[i-1][j-1]);
  for(i=0;i<n;i++) for(j=0;j<=i;j++)
      printf("%6u%c",*(*(pascal+i)+j),(j==i)?'\n':' ');

  for(i=0;i<n;i++) free(*(pascal+i));
  free(pascal);
  return 0;
}
\end{lstlisting}
\end{boxnote}

ここでまず着目して欲しいのは、$l$.10および$l$.12の確保部分である。
\begin{itembox}[l]{malloc/callocによるメモリの確保}
メモリを動的に確保し、それをポインタ\verb|p|に割りつける場合、
\begin{code}
p=(型 *)malloc(確保したいサイズ)
\end{code}
ないし、
\begin{code}
p=(型 *)calloc(確保したい個数,1個あたりのサイズ)
\end{code}
の形式で記す。なお、これらの関数はstdlib.hに収録されている。
\end{itembox}
malloc関数とcalloc関数は、引数の違いと、calloc関数に限り確保した領域を0で初期化するという点が違う。リスト\ref{program11_6}では、malloc/callocを用いて確保を行い、その返却値がNULLである=確保に失敗した場合、例外処理を行うようにしている。
\\ \\　
一方、$l$.13,14や$l$.24,25に見られるfree関数は解放を行う関数である。
\begin{itembox}[l]{メモリの解放}
メモリを解放する場合は、解放したいポインタ\verb|p|に対して
\begin{code}
free(p)
\end{code}
を実行する。free関数はstdlib.hに収録されている。
\end{itembox}
解放の際に注意しなければならないのは、同じ領域を2度以上解放したり、解放が必要ない領域を解放したりといった問題である。解放すべきでない領域を解放しようとすると、大抵の場合アクセス違反が起こる(Segmentation faultではない場合も多い)。従って、丁寧にソースを読み、解放する領域を確認しておくほうが良い。他、例えば動的配列のオフセットを変更する場合、面倒であっても確保用のポインタとアクセス用の(エイリアス用の)ポインタは別に分けたほうが安全である。

また、今回のようにポインタのポインタを用いて多次元配列のような機能を実現している場合は、その解放順序にも注意しなければならない。リスト\ref{program11_6}において、先に\verb|pascal|全体を解放してしまうと、\verb|pascal[0],pascal[1],...|にアクセスする術が失われてしまい、結果メモリリークやアクセスバイオレーションの原因となってしまう。

\minisec{動的配列の拡大/縮小}
動的配列の現在の状態はそのまま、動的配列を拡大/縮小したい場合がある。このような場合にはrealloc関数(これもstdlib.hにある)を用いる。
\begin{itembox}[l]{動的配列の拡大/縮小}
既に確保されている動的配列\verb|p|を拡大/縮小したい場合には、同じ型の別のポインタ\verb|tmpp|を用意し
\begin{code}
if((tmpp=(型)realloc(p,新サイズ))!=NULL) p=tmpp;
else 例外処理;
\end{code}
のように行う(ここでは例外処理も最初から考慮した)。
\end{itembox}


\subsection{フレキシブル配列メンバ}
動的確保を利用する別の機能として、C99から導入された\textbf{フレキシブル配列メンバ}\index{ふれきしぶるはいれつめんば@フレキシブル配列メンバ}(flexible array member)の機能がある。これについて簡単に説明する。
\\ \\　
メンバ2つ以上の構造体を宣言する際、その最終メンバを不完全配列型とし、例えば
\begin{code}
struct st{
  int a;
  int b[];
};
\end{code}
として良い。この時、この構造体型(ここでは\verb|struct st|型)へのポインタ\verb|p|を準備し、
\begin{code}
p=(struct st*)malloc(sizeof(int)*(1+n));
\end{code}
とすることで、メンバ\verb|b|に\verb|n|個のint型領域が割り当てられる。このときの\verb|b|がフレキシブル配列メンバである。
\\ \\　
フレキシブル配列メンバには、次のような制約がある。
\begin{itembox}[l]{フレキシブル配列メンバの制約}
\begin{itemize}
\item 不完全配列型は必ず構造体の最後の要素でなければならない。
\item フレキシブル配列メンバを含む構造体の配列は使えない。
\item フレキシブル配列メンバを含む構造体は、ほかの構造体の途中にあるメンバとしては使用できない。
\item フレキシブル配列にはsizeof演算子が適用できない。
\end{itemize}
\end{itembox}

\section{関数間で配列をやり取りするには}%http://murakan.cocolog-nifty.com/blog/2011/08/cc-b731.html
一次元静的配列を引数に取る関数については配列を学んだ際に学習した。だが、多次元配列を同様の方法で渡そうとしても関数に渡すことはできない。ここでは多次元配列を関数に渡す方法を説明する。
\\ \\　
なお、何れの方法を用いたとしても配列の要素数を自動で取得することはできない\footnote{C++やJavaでは要素数を自動取得することができる。これは、配列という概念は同じでも、その型に関する実装などが違うためである。Cの配列は、最小限度の機能のみを実装した、「もっとも素朴な(simpleな)配列」といえよう。}。そのため、可変引数関数の作成と同じく、\textbf{配列の要素数を示す情報を渡さなければならない}。可変引数の場合は個数を示す情報にかなりの多様性が見られたが、配列の場合は要素数を直接記す方法が殆どであると言って良い。
\subsection{一次元配列に帰着させる方法}
静的多次元配列は一次元配列の順番を書き換えたものに過ぎない。従って、そもそも多次元配列を用いず、その型へのポインタとして渡してしまい、一次元配列として扱えば良い。警告が出る可能性はあるが、コンパイルは通るし、動作も正しいだろう。だが、この方法は多次元配列を使う利点を消し去ってしまう方法であり、推奨できる方法ではない。勿論、先に書いたポインタによるエイリアスなどを用いて多次元配列のように扱うこともできるのだが、それなら呼び出し元で最初からポインタによるエイリアスを行ったほうが早い(後述)。

\subsection{要素数を固定して渡す方法}
先に学んだ、多次元配列へのポインタを思い出そう。多次元配列を直接多重ポインタに代入できないのは、その型の問題であった。それを考慮すれば、
\begin{code}
type func(type (*array)[2][3]);
type func(type array[][2][3]);
\end{code}
最初の次元数が省略できるのは、不完全配列がポインタと等価に扱われることを考えれば明らかであろう。もちろん、次元数を省略せずに
\begin{code}
type func(type array[5][2][3]);
\end{code}
のように扱うことも可能である。だが、この方法では、第2次元以降の全要素の個数を固定しなければならない。

\subsection{配列エイリアスのポインタを用いる}
そこで、(動的配列と同様に)配列エイリアスのポインタを作成し、そのポインタを渡してアクセスしてやれば良い。この方法であれば、静的配列でも動的配列でも用いることができて便利である。例えば、
\begin{code}
int array[3][5];
int *p[3]={array[0],array[1],array[2]},**pp=p;
\end{code}
などとして、\verb|int **|型引数をとり、それに\verb|pp|を渡してやれば一見落着である。
\\ \\　
なお、ここまで学んだことをぶち壊すような意見であるが、いくつかの関数で使いたい配列はグローバルにしてやれば、それで話がすむ場合が多い。きちんと管理できるのであれば、グローバル配列を用いてやれば簡潔に記述することができるだろう。特に多次元配列の場合、複雑で混同しやすい引数渡しよりも、グローバル配列にする方が主流である。また、グローバル配列にすることによって、寿命やスコープの取り扱いを気にせずにすむようになるため、「関数内で静的な静的配列を宣言してそれへのポインタを返すことで配列を返す」とする\footnote{static記憶クラス指定子を付さない場合、ポインタの返却後にその領域が解放されてしまうため、既解放領域へのアクセスバイオレーションが起きる。}より、分かりやすいやり取りを行うことができるようになる。
\\ \\　
この他、構造体をオブラートとして用いる方法もあるが、値渡しか参照渡しかで混乱したり、配列のコピーを作るためにスタック領域を大幅に消費したりといった欠点もあるため、特段なければグローバル配列を用いることを推奨しておきたい。

\newpage

\begin{shadebox}
\section*{本講の要点}
本講では、ポインタをより実践的に使うために、派生型へのポインタを中心に学んだ。この章でも、次のスローガンをなお念頭に置いて欲しい。
\begin{center}
\textbf{ポインタは指し示しているものを明確に！}
\end{center}

\subsection*{派生型へのポインタ}
\begin{itemize}
\item ポインタを用いて配列エイリアスを実現できるが、配列とポインタは別物である。
\item restrict修飾子は引数にとった2つ以上のポインタの指示領域が互いに独立である事を示し、それによる最適化ヒントをコンパイラに渡す。
\item 参照元のみのコピーを浅いコピ―、参照先実体そのもののコピーを深いコピーといい、挙動が異なる。
\item 配列を文字列リテラルで初期化すると各要素に文字が代入されるが、ポインタの場合はconst char型へのポインタとしてアドレスが代入されるにすぎない。
\item const修飾子は直後の語にかかる。
\item 関数に対してもポインタを作成でき、これにより引数や配列に関数を用いられる。
\item ポインタに対してもポインタが存在する。
\item 多次元配列と多重ポインタは、そのアクセス過程で経由する型や連続性の保証の点などで異なっている。
\item 多次元配列と多重ポインタの違いから、多次元配列を引数に取るのは面倒なので、グローバル化したり構造体に包む方が良い。
\end{itemize}

\subsection*{メモリの動的確保}
\begin{itemize}
\item malloc関数やcalloc関数を用いて、ヒープ領域を動的に確保できる。
\item メモリ確保の際には例外処理を行うべきである。
\item 動的に確保したメモリは、使い終わった後必ず解放せねばならない。
\item 動的確保領域の伸縮を行いたい場合には、realloc関数を用いる。
\item 構造体の最終メンバを不完全配列化し、それを動的に確保できる機能をフレキシブル配列メンバと呼ぶ。
\end{itemize}
\end{shadebox}

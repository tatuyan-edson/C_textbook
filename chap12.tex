ここまでの入出力は標準入出力のみであった。だが、実際にはファイルに書きこみたい場合も多い。ここでは、ファイルの扱いを学び、プログラミングの幅を広げよう。

\section{ファイルとストリーム}
ファイルの扱いの前に、まず、ファイルについての基礎知識を身につけておこう。
\subsection{ファイルとは}
\textbf{ファイル}\index{ファイル}(file)とは何かということに関しては、いまさら問うまでもないかもしれない。例えば、C言語のプログラムを書き、それをファイルに保存し、さらにコンパイルによって実行ファイルを得る。デジタルカメラを使って写真を撮影する。これらの処理は、いずれもファイルを伴っている。OSの上でもファイルがデータを扱う単位となり、データの扱いを容易にしてくれている。実際、定義も「ハードディスクやフロッピーディスク、CD-ROMなどの記憶装置に記録されたデータのまとまり」と、既に経験的に理解しているものと何ら変わりないだろう。
\\ \\　
ところで、一口にファイルといっても様々である。
いろいろな分類方法があるが、ここでは「テキストエディタを使って人間が読めるもの」と「テキストエディタでは人間が読めないもの」の2つに分けることにしよう。前者を\textbf{テキストファイル}\index{てきすとふぁいる@テキストファイル}(text file)、後者を\textbf{バイナリファイル}\index{ばいなりふぁいる@バイナリファイル}(binary file)と呼ぶ\footnote{バイナリ(binary)とは「2進数」という意味である。}。C言語のソースプログラムはテキストファイルであるが、コンパイルして得られた実行ファイルや写真の画像ファイルはバイナリファイルといえる。以下、もう少し厳密にまとめておこう。
\begin{itembox}[l]{テキストファイルとバイナリファイル}
\begin{description}
\item[テキストファイル] データを「文字」の単位で解釈するファイル。
\item[バイナリファイル] データを「バイト」の単位で解釈するファイル。
\end{description}
\end{itembox}

このまとめからいえば、テキストファイルかバイナリファイルかの別は、それぞれのファイルが持っているものではなく、むしろそのファイルがどう解釈されるかによるという事がわかるだろう。実際、テキストファイルをバイナリファイルとして扱うことも可能である。(逆に、バイナリファイルをテキストファイルとして扱えることは殆どない。)
\\ \\　
C言語でファイルを扱う上ではテキストファイルとバイナリファイルとで、その処理を変えなければならない。この章では、ひとまずテキストファイルについての扱いを述べた後、バイナリファイルを扱う。

\subsection{ストリームとは}
\textbf{ストリーム}\index{ストリーム}(stream) とは、一言でいえばデータを入出力する対象である。
前述したファイルも、入出力対象としてストリームの一種と考えられるが、わざわざストリームを導入したのには理由がある。
我々が既に知っている標準入出力に対する処理を、ファイルに対する処理に拡張しようという狙いがあるのである。
それだけでなく、プログラミング言語によっては、ストリームが入出力されるデータを蓄えておいたり、インターネットを通してサーバーとの通信機能を担ったりすることもある\footnote{C++やJavaなどのオブジェクト指向言語を扱うときに役に立つ。}。
これらはすべてデータを入出力するという共通の機能を持ち、それらを同一のインターフェースでまとめたのがストリームなのである。
例えば「標準出力にHello Worldを出力する」という処理は、ほぼ同様にして「ファイルにHello Worldを出力する」という処理に書き換えることが可能となる。
\\ \\　
まとめると、ストリームという概念を用いて、それにファイルとか標準入出力を割り当てることにより、プログラマが面倒をみるべき処理を統一化している、と考えることができる。
この後、ファイル入出力のために用いる関数を紹介するが、これらはむしろストリームを操作する関数と考えたほうがよい。

\minisec{C言語における代表的なストリーム}
ファイルを扱う場合、ファイルを開いてストリームとするのであるが、実際には標準入出力などがストリームである場合がある。これらの、C言語において代表的である(ファイルを開かずに使うことができる)ストリームを紹介しておこう。
\begin{itembox}[l]{C言語の代表的ストリーム}
\begin{description}
\item[stdin] \textbf{標準入力}\index{ひょうじゅんにゅうりょく@標準入力}(standard input)を表しており、入力専用のストリームである。
\item[stdout] \textbf{標準出力}\index{ひょうじゅんしゅつりょく@標準出力}(standard output)を表し、出力専用のストリームである。
\item[stderr] \textbf{標準エラー出力}\index{ひょうじゅんエラーしゅつりょく@標準エラー出力}(standard error output)を表し、出力専用のストリームである。
\end{description}
\end{itembox}

標準エラー出力はコンソール上での出力結果が標準出力と見た目に区別できないため、混同されることもあるが、本来は区別されるべきものである。一般に、これら3つを総称して\textbf{標準入出力}\index{ひょうじゅんにゅうしゅつりょく@標準入出力}(standard input and output)という。

\subsection{リダイレクトの意味}
リダイレクトについては、既にその方法のみを示した。だが、これがどういう動作かについては詳述しなかった。ストリームを理解したなら、リダイレクトの動作はすぐに理解できるので、ここで説明しておこう。
\\ \\　
標準入出力ストリームに対する操作は通常、コンソール(画面)に対する処理と見なされる。
よってstdoutに文字列を出力した場合、画面にその文字列が出力されることになるし、stdinからの入力はコンソールを通してキーボードから入力することに対応する。
しかし、標準入出力を別の対象と対応付けることもできたほうが便利だろう。この、標準入出力を他の対象に置き換える動作のことを\textbf{リダイレクト}\index{リダイレクト}(redirect)と呼んでいるのである。

復習も兼ねて、リダイレクトの方法とその置き換え対象を示しておく。
\begin{itembox}[l]{リダイレクトとその置換対象}
実行ファイル名(またはコマンド)の後ろに...
\begin{itemize}
\item \verb|< (ファイル名)|と付す：指定したファイルがstdinに割り当てられる。
\item \verb|> (ファイル名)|と付す：指定したファイルがstdoutに割り当てられる。
\item \verb|2> (ファイル名)|と付す：指定したファイルがstderrに割り当てられる。
\end{itemize}
\end{itembox}

\section{ストリームの取り扱い}
ファイル/ストリームについての基礎知識を学んだ所で、いよいよ実際にファイルを取り扱っていくことにしよう。
\subsection{ファイルの開閉と入出力}
ファイル関連の取り扱いは「文法」と言うより「語法」ないし「イディオム」と言う方が正確な部分が多い。それ故、理論を説明せずとも、ソースを追っていくほうが理解しやすいと思われる。ここでもまずはソースを見て、それから説明を加えていこう。
\begin{boxnote}
\minisec{ファイルの行数}
入力される名前のテキストファイルを開き、そのファイルの行数を数えて出力するプログラムを作成する。
\minisec{解説}
ファイルの行数は、動的配列の準備や、統計的処理などで重要になる。このソースを例に、方法を理解しておきたい。

また、このソースはファイル名として入力される1行の文字数が1024文字以上になる場合、正しく動作しない。
\end{boxnote}
\begin{boxnote}
\begin{lstlisting}[caption=ファイル行数カウント,label=program12_1]
#include<stdio.h>

int main(void){
  char temp[1024],filename[256];
  FILE *fp;
  int line;

  fscanf(stdin,"%255s%*c",filename);
  if((fp=fopen(filename,"r"))==NULL){
    fputs("File open error!\n",stderr);
    return -1;
  }
  for(line=0;fgets(temp,sizeof(temp),fp)!=NULL;line++);
  fclose(fp);
  fprintf(stdout,"file %s has %d lines.\n",filename,line);
  return 0;
}
\end{lstlisting}

\end{boxnote}

\minisec{ファイルを開く方法}
ファイルを読み書きする場合、まずは「ファイルを開く」という作業を行う必要があり、そのためには開いたファイル(厳密にはファイルのアドレス)を保持する変数が必要になる。リスト\ref{program12_1}では、$l$.5でファイルを開くためのポインタ(\textbf{ファイルポインタ}\index{ふぁいるぽいんた@ファイルポインタ}(file pointer))を準備している。ここで用いている型\verb|FILE|はstdio.h内で定義されている構造体で\footnote{現実のプログラミングにおいては、FILE構造体の中身を知る必要は全くないし、むしろこれが構造体かどうかさえわからなくてよい。FILE * という1つのデータ型と考え、ブラックボックスとして利用すればよいだろう。}、これへのポインタを用いてファイルを扱うのが一般的である。
\\ \\　
保持するためのポインタを宣言したら、今度はファイルを開き、そのアドレスをポインタに代入してやれば良い。ファイルを開くためにはfopen関数を用いる。
\begin{itembox}[l]{ファイルを開く方法}
ファイルを開く際には
\begin{code}
fp=fopen(ファイル名を表す文字列,権限を表す文字列)
\end{code}
のように行う。ファイル名を表す文字列はPathとして指定したり、文字列リテラルとしてソースに埋め込んでも問題ない。
\end{itembox}

翻ってリスト\ref{program12_1}を見てみると、$l$.9でファイルを開いている。だが、返却値がNULLポインタである場合には、例外処理を行なっている。これは、fopen関数がファイルを開くのに失敗した場合に、NULLポインタを返却するためである。このように、ファイルを開く場合には、その失敗時の例外処理を必ず記しておくべきである。

ファイルを開く際に、第1引数が文字列として与えられる点を利用すれば、一連の(似たような名前の)ファイルに対し、一括処理を行うことも可能である。これには、sprintf関数などを利用すると良いだろう。このように、fopen関数の第1引数が文字列であることは、様々な工夫によってプログラムを便利に記述できるという事でもある。

問題となるのは第2引数の「権限を表す文字列」であろう。ここには、ファイルの開き方(読み込み用か書き込み用か、テキストファイルとして扱うかバイナリファイルとして扱うか)を表す文字列を指定する。ここに指定できる文字列を表\ref{fopen_mode}に示す。
\begin{table}[h]
\centering
\caption{fopen関数に指定できるファイルモード}\label{fopen_mode}
 \begin{tabular}{|c|l|l|} \hline
  文字列 & \multicolumn{1}{|c|}{意味} & \multicolumn{1}{|c|}{備考} \\ \hline
& & \\[-15.5pt] \hline
  \verb|r| & テキストの読み込み & ファイルが存在しなければ失敗する \\ \hline
  \verb|w| & テキストの書き込み & ファイルが存在すれば既存の内容が削除される \\ \hline
  \verb|a| & テキストの書き込み & ファイルが存在すればファイル末尾から書き込む \\ \hline
  \verb|r+| & テキストの読み書き & ファイルが存在しなければ失敗する \\ \hline
  \verb|w+| & テキストの読み書き & ファイルが存在すれば既存の内容が削除される \\ \hline
  \verb|a+| & テキストの読み書き & ファイルが存在すればファイル末尾から書き込む \\ \hline
  \verb|rb| & バイナリの読み込み & ファイルが存在しなければ失敗する \\ \hline
  \verb|wb| & バイナリの書き込み & ファイルが存在すれば既存の内容が削除される \\ \hline
  \verb|ab| & バイナリの書き込み & ファイルが存在すればファイル末尾から書き込む \\ \hline
  \verb|rb+| & バイナリの読み書き & ファイルが存在しなければ失敗する \\ \hline
  \verb|wb+| & バイナリの読み書き & ファイルが存在すれば既存の内容が削除される \\ \hline
  \verb|ab+| & バイナリの読み書き & ファイルが存在すればファイル末尾から書き込む \\ \hline
 \end{tabular}
\end{table}

なお、表\ref{fopen_mode}は、よく使うので暗記しておくと良い。この表を暗記するのは一見大変なように思えるが、次のようにまとめるとわかりやすいだろう。
\begin{itembox}[l]{fopenのモード}
\begin{itemize}
 \item \verb|r|, \verb|w|, \verb|a|\footnote{それぞれ read(読み込む), write(書き込む), append(追加する) の頭文字である。} という文字がファイルの読み書きの別を決める。
 \item \verb|+| が付けば、読み書き両方が可能となるが、ファイルが存在するか否かによる処理は、もとになった \verb|r|, \verb|w|, \verb|a| の指定によるものを受け継ぐ。
 \item \verb|b| が付けば、バイナリファイルの操作となる\footnote{UNIX系OSではテキストとバイナリの違いが曖昧であるため、これを付さなくともバイナリファイルを開くことができる。}。\verb|b| を付けなければ、テキストファイルの操作となる。
\end{itemize}
\end{itembox}

なお、ファイルのモードは、どのようなファイルを扱うかによって適宜決めればよい。だが、便利だからといって無闇矢鱈に\verb|+|をつけて読み書き可能にするべきではない。というのは、読み込みだけであれば他のプログラムからそのファイルへのアクセスが行われていても処理可能なことがあるためである。これは別のプログラムがそのファイルに書き込みを行っていたとしても、読み込みだけであれば二重に書きこむなどのエラーが生じないためである。
\\ \\　
ファイルを開いた後、ファイルポインタはファイルの先頭を指している。これに対し、多くの関数では、読み書きした分だけファイルポインタが後ろにずらされ、順次読み書きできるようにしている。もちろん、このファイルポインタを任意に前後させるような関数も存在する(後述)。

\minisec{ファイルを閉じる}
開いたファイルは、必ず閉じなければならない\footnote{動的配列の際にも同様であったが「使ったものはきちんとしまう」事である。なお、ファイルについては、プログラムが正常終了すれば通常OSが自動で閉じてくれるため、動的メモリ確保に比べれば問題になりづらい(動的確保領域は正常終了しても解放されない)。だが、その分ファイルを閉じるのを忘れやすいとも言えるので注意しよう。}。何故閉じないといけないのか、という点になるが、これはファイルを同時に二重に開くと問題が発生するためである。この問題を防ぐため、ファイルに書き込んでいる間には、\textbf{排他制御}\index{はいたせいぎょ@排他制御}という、他からの書き込みを禁止する制御が行われる。この為、ファイルを閉じないと、排他制御がいつまでも終わらない(つまり、他のプログラムがいつまでたってもそのファイルにアクセスできない)ことになる。そのために、ファイルを閉じるという作業が重要なのである。ファイルを閉じるためには、fclose関数を用いる。
\begin{itembox}[l]{ファイルを閉じる方法}
ファイルを閉じる際には
\begin{code}
fclose(閉じたいファイルポインタ); 
\end{code}
のように記す。
\end{itembox}

実際、リスト\ref{program12_1}では、$l$.14でファイルを閉じている。ここで、終了直前ではなく使い終わった段階で閉じているのは、他ファイルからのアクセスを少しでも早い段階から可能にしたり、ファイルの閉じ忘れを防いだりするためである。
\\ \\　
以上に説明したファイル処理の流れは、次のようにまとめられる。
\begin{itembox}[l]{ファイルの処理を行う方法}
\begin{enumerate}
\item \verb|FILE *|型の変数を用意する。
\item fopen関数によってファイルを開く。この時、ファイルが開けなかった場合の処理を例外処理として記述しておく。
\item ファイル処理を行う。
\item fclose関数によってファイルを閉じる。
\end{enumerate}
\end{itembox}

ファイルに対する処理の前後には、ファイルの開閉(=ストリーム割り当て)が必ず必要になる。標準入出力以外の入出力先を扱う場合、ファイルに限らず、ストリーム割り当てが必要になる。実際、ネットワークを介して動くプログラムなどでは、ネットワークの接続先への出力をストリームに割り当てて利用する場合もある。

\minisec{ファイルへの入出力}
ファイルへの入出力を行う際には、通常の入出力関数に入出力ストリームをつけた関数を用いる。これらの関数は全てstdio.hに収められており、ファイルの扱い/入出力関連はstdio.hで賄えるようになっている。入出力については、リスト\ref{program12_1}でも何種類か見せているが、具体的には次のような関数がある。
\begin{itembox}[l]{ストリームへの入力関数}
\begin{itemize}
\item fgets関数:第1引数に入力先文字列へのポインタを、第2引数に入力最大文字数を、第3引数に入力ストリームをとり、データを読み込む。区切り文字は改行で、改行も読み込まれる。
\item fscanf関数:scanf関数の引数に先行する引数として入力ストリームをとり、scanfと同様の形式で入力を行う。
\item getc関数/fgetc関数:唯一の引数である入力ストリームから一文字読み込み、それをint型として返却する。
\end{itemize}
\end{itembox}

\begin{itembox}[l]{ストリームへの出力関数}
\begin{itemize}
\item fputs関数:puts関数の引数リストの後に出力ストリームをつけた形で記し、文字列を出力する。putsと違い、最後のNULL文字を自動で改行に置換しない。
\item fprintf関数:printf関数の引数に先行する引数として出力ストリームをとり、printfと同様の形式で出力を行う。
\item putc関数/fputc関数:第1引数の文字を第2引数の出力ストリームに出力する。
\end{itemize}
\end{itembox}

この時、注意しなければならないのは入力関数の返却値である。fgetsの返却値は\verb|char *|型であり、ファイル終端に来るとNULLポインタを返す(リスト\ref{program12_1}の$l$.13)。一方でscanf系関数の返却値はint型で、EOFというマクロ(stdio.hで定義されている)の値(一般には-1であることが多い)を返す。
\\ \\　
以上までに出てきた入出力関数を、以下、系統別にまとめておこう。まずは入力である。
\begin{itembox}[l]{scanf系関数}
\begin{itemize}
\item 何れも返却値はint型で、ストリーム終端に達した場合はEOFを返す。
\item 基本となるscanfに対し、何種類かの接頭辞がついて意味を表す。fはファイル、sは文字列、wはワイド文字列、vは可変引数リスト等。
\item 通常、入力元は第1引数として与える。
\end{itemize}
\end{itembox}

\begin{itembox}[l]{gets系関数}
\begin{itemize}
\item 何れも返却値はchar *型で、ストリーム終端に達した場合はNULLポインタを返す。
\item gets関数はC11においてなくなっており、バッファオーバーランを防げないので使用すべきではない。
\item 基本的には文字列の入力に用いる。
\end{itemize}
\end{itembox}

\begin{itembox}[l]{getchar系関数}
\begin{itemize}
\item 何れも一文字読み込んで、それを返却値としている。従って、ストリーム終端かどうかは後述のfeof関数などを用いて別途確認が必要。
\item 引数は入力ストリームのみで、基本となるgetchar関数は引数を取らない。
\end{itemize}
\end{itembox}
\\ \\　
続いて出力をまとめる。出力は、入力にそれぞれ対応させて理解すると良いだろう。
\begin{itembox}[l]{printf系関数}
\begin{itemize}
\item 基本となるprintfに対し、何種類かの接頭辞がついて意味を表す。fはファイル、sは文字列、wはワイド文字列、vは可変引数リスト、nは文字列の長さ指定等。
\item 通常、出力先は第1引数として与える。snprintf系列については、出力先・出力バイト数・書式文字列の順になる。
\end{itemize}
\end{itembox}

\begin{itembox}[l]{puts系関数}
\begin{itemize}
\item puts関数に限り、終端のNULL文字を改行文字に置換して出力する。
\item 基本的には文字列の出力に用いる。
\end{itemize}
\end{itembox}

\begin{itembox}[l]{putchar系関数}
\begin{itemize}
\item 何れも一文字出力するための関数。
\item 引数は出力ストリームのみで、基本となるputchar関数は引数を取らない。
\end{itemize}
\end{itembox}

以上の入出力関数とストリームを自在に用いられれば、Cプログラミングにおけるテキストの基本的な入出力はマスターしたと言えるだろう。

\subsection{ファイル・ストリームを取り扱う関数}
ファイルやストリームを取り扱う関数は多くあり、標準ライブラリ以外にも多数見られる。以下、標準ライブラリにおいて定義されている関数を紹介する。なお、何れもstdio.hに収録されている。
\begin{itembox}[l]{ファイル・ストリームを取り扱う関数}
\begin{itemize}
\item int feof(FILE *stream):ファイルポインタが終端に達していれば非0を、そうでなければ0を返す。
\item long ftell(FILE *stream):現在のファイルポインタが先頭から何バイトの部分であるかを返却する。
\item int fseek(FILE *stream, long offset, int whence):第1引数のファイルポインタを第3引数の基準の場所から第2引数で示すoffsetバイト進んだ場所に動かす。基準としては、ファイルの先頭を示す\verb|SEEK_SET|、現在の位置を示す\verb|SEEK_CUR|、終端を示す\verb|SEEK_END|などがある。
\item void rewind(FILE *stream):引数のストリームを先頭にセットする。fseek関数を用いても同等の機能が実現できる他、ファイルを一度閉じて開きなおしても同じ結果になる。
\item FILE *tmpfile(void):一時ファイルを作成してそのファイルストリームを返す。
\item int remove(const char *fn):fn の示すファイルを削除する。
\item int rename(const char *old,const char *new):oldで示すファイル名をnewで示すファイル名に変更する。
\item int fflush(FILE *stream):引数のストリームにおいて、何らかの理由で出力されずに残っている文字類を強制的に出力させる。
\item FILE *freopen(const char *fn,const char *mode,stream):modeに従ってfnの示すファイルを再オープンしてstreamにストリームを返す。
\end{itemize}
\end{itembox}

\section{バイナリファイルの入出力}
ここまではテキストファイルを扱ってきたが、コンピュータで扱うファイルはテキストファイルだけではない。ここでは、バイナリファイルについて理解を深めよう。
\begin{boxnote}
\minisec{ビット反転プログラム}
入力される名前のバイナリファイルを読み込み\footnote{とはいえ、最初に記したとおり、テキストファイルとバイナリファイルは解釈の違いであるので、テキストファイルをバイナリファイルとして読み込ませても何ら問題ない。テキストファイルといえど、その実態はビット列であることに相違ないのだから。}、その全ビットを反転させることによって暗号化するプログラムを作成する。二度反転すると元に戻るため、これは復号化プログラムも兼ねている。
\end{boxnote}

\begin{boxnote}
\minisec{解説}
\begin{itemize}
\item 大きなファイルにも対応できるように作成しているが、ソース中の$2^n$の倍数に大きな意味はない。
\item 適当なファイルについて(テキストファイルでも良い)、一度これをかけると読めなくなるはずである。二度かけると元に戻る。
\item ghexなどのバイナリエディタを用いてビットの状態を観察すると、反転していることがわかるだろう。
\end{itemize}
\begin{multicols}{2}
\begin{lstlisting}[caption=ビット反転プログラム,label=program12_2]
#include<stdio.h>
#include<stdlib.h>

#define MIN(x,y) (((x)>(y))?(y):(x))
typedef unsigned int u_int;

int main(void){
  char filename[256];
  FILE *fp,*tmpfp;
  u_int tmp,count,i,*all;

  scanf("%255s%*c",filename);
  if((fp=fopen(filename,"rb"))==NULL){
    puts("file open error!");
    return -1;
  }
  tmpfp=tmpfile();

  for(count=0;!feof(fp);count++){
    fread(&tmp,sizeof(u_int),1,fp);
    fwrite(&tmp,sizeof(u_int),1,tmpfp);
  }

  rewind(tmpfp);
  if(freopen(filename,"w",fp)==NULL){
    fclose(fp);
    fclose(tmpfp);
    return -1;
  }

  do{
    tmp=MIN(count,65536);
    all=(u_int *)calloc(tmp,sizeof(u_int));
    fread(all,sizeof(u_int),tmp,tmpfp);
    for(i=0;i<tmp;i++) all[i]=~all[i];
    fwrite(all,sizeof(u_int),tmp,fp);
    count-=tmp;
    free(all);
  }while(count!=0);

  fclose(fp);
  fclose(tmpfp);
  return 0;
}
\end{lstlisting} 
\end{multicols}
\end{boxnote}

以下ではバイナリの入出力について記すが、リスト\ref{program12_2}では、随所に「ファイル・ストリームを扱う関数」を用いているので、先の説明と対比して確認されたい。

\minisec{バイナリ入出力関数}
バイナリファイルといえど、ファイルである以上、その扱い方は基本的にテキストファイルと同じである。唯一違うのは入出力で、バイナリファイルはデータ類を一気に入力/出力できるという点がテキストファイルと異なる。この、バイナリファイルからの入出力に用いるのがfread/fwrite関数である。
\begin{itembox}[l]{バイナリファイルの入出力}
バイナリファイルから入力を行う場合は、fread関数を用い
\begin{code}
fread(入力先ポインタ,1つあたりのサイズ,個数,入力ストリーム)
\end{code}
を実行する。出力の際もfreadがfwriteに代わる以外は同様である。
\end{itembox}

上記のバイナリ入出力関数によって数値列(文字列)を配列に読み込んだら、後はこれまでに学んだ方法で処理をすれば良いのである。リスト\ref{program12_2}では、その入出力が2回ある。これは、第1回の入出力である$l$.20-21で1個ずつデータを読み込むことによって個数を数え、第2回の入出力である$l$.32-38では65536個ずつ一括処理したものである。

なお、ここでは大きなファイルでも何とかなるように、数を数えつつ一時ファイルに保存した後に処理を施したが、
\begin{code}
fseek(fp,0,SEEK_END);
filesize=ftell(fp);
\end{code}
などとして、ファイルサイズを先に取得してから処理を施す方法もある\footnote{但し、ftellの返却値はlong型であるので、2GB以上のファイルは扱えない。そのような場合には、fgetpos関数などの他の関数を使うか、処理系によって定義されている固有の関数類を使わなければならない。これはftellに限らず、いくつかの標準関数に共通した問題である。}。興味があれば、これを用いて書き換えてみても良いだろう。

\section{コマンドライン引数}
実際のプログラムやコマンドでは、その実行の後ろに引数を取ることができる。これを\textbf{コマンドライン引数}\index{こまんどらいんひきすう@コマンドライン引数}(command-line argument)と呼ぶ。C言語においては、コマンドライン引数はmain関数の引数として実装され、ほぼその定形が決まっている。
\subsection{main関数の引数}
やはり、最初に例示から入ろう。
\begin{boxnote}
\minisec{catコマンドの実装}
catコマンドは、その引数として与えられるテキストファイルを順次出力するコマンドである(引数は可変引数で、その個数は幾つでも良い)。このコマンドをCを用いて実装してみる(但し、オプションは一切ないものとする)。
\end{boxnote}
\begin{boxnote}
\minisec{解説}
与えられたファイルを読み込み、それを順に出力しているだけである。なお、可読性向上のため、ファイルの出力は関数化した。
\begin{lstlisting}[caption=簡易版catコマンド,label=program12_3]
#include<stdio.h>

void outfile(FILE *fp);

int main(int argc,char *argv[]){
  int i;
  FILE *fp;
  for(i=1;i<argc;i++){
    if((fp=fopen(argv[i],"r"))==NULL){
      fputs("File open error!\n",stderr);
      return -1;
    }
    outfile(fp);
    fclose(fp);
    putchar('\n');
  }
  return 0;
}

void outfile(FILE *fp){
  char str[65536];
  while(fgets(str,sizeof(str),fp)!=NULL)
    fputs(str,stdout);
}
\end{lstlisting}
\end{boxnote}

リスト\ref{program12_3}のような、ファイルに対して操作を行うプログラムは、コマンドライン引数にして作る場合が多い。これを実装しているのが$l$.5のmain関数の引数である。
\begin{itembox}[l]{main関数の引数}
一般的に、main関数が引数を取る場合(コマンドライン引数を取る場合)
\begin{code}
int main(int argc,char *argv[]){
\end{code}
と書きだす。但し、第2引数については等価な\verb|char **argv|などと書き換えても良い。名称についても、慣例的にargc,argvと決まっている。
\end{itembox}

この形式によって書かれたソースにおいて、argcにはコマンドライン引数として与えられた引数の個数が格納される。引数そのものは、スペースを区切りとしており、argv[0],argv[1],...に文字列として格納されている。注意しなければならないのは、実行ファイル名そのものもargcやargvに含まれる、という事である。例えば
\begin{code}
./a.out test.txt test2.txt
\end{code}
などとしてプログラムを実行した場合、argcは3になり、argv[0]は./a.outに、argv[1]はtest.txtに、argv[2]はtest2.txtになる。
\\ \\　
コマンドライン引数を用いた場合でも、リダイレクトは通常通り行うことができるので、安心して使って良い。

\subsection{第3のコマンドライン引数}
UNIX系OSやWindowsでは、main関数に第3の引数が存在するものがある。これを利用する場合は通常
\begin{code}
int main(int argc, char *argv[], char *envp[]){
\end{code}
のようにmain関数を書きだす。この、第3引数について、少し説明を加えておこう。
\\ \\　
この第3引数はセットされている環境変数を取得し、それが各要素に格納される。そして、最後の要素にはNULLポインタが入れられている。従って、NULLポインタをターミネータとして、環境変数の個数を計算することができるのである。

\newpage

\begin{shadebox}
\section*{本講の要点}
本講では、ファイル及びストリームの扱いについて学んだ。また、関連する事項として、main関数の引数についても説明した。
\subsection*{ファイルの扱い}
\begin{itemize}
\item ファイルにはテキストファイルとバイナリファイルがあり、その解釈の仕方に応じた処理を行う必要がある。
\item リダイレクトは標準入力・標準出力・標準エラー出力を置き換える動作である。
\item ファイルを扱うための型としてFILE型があり、通常FILE *型にストリームポインタを開いて用いる。
\item ファイルを扱う際には、まずfopen関数を用いてファイルを開き、その後処理を施して、fclose関数によって閉じる。
\item ファイルに対して入出力を行う場合、ストリームを指定して入出力を行う関数を用いる。
\item ファイルを扱う関数のほとんどはstdio.hに収録されている。
\item ファイルを取り扱う操作の大半はイディオムであり、関数などを調べて用いる。
\end{itemize}

\subsection*{main関数の引数}
\begin{itemize}
\item コマンドライン引数をとりたい場合、main関数を
\begin{code}
int main(int argc,char *argv[]){
\end{code}
の形で書きだす。
\item 上記の形で記したソース中において、argcにはコマンドライン引数の個数が、argv[]には各コマンドライン引数が格納される。
\item argc,argvは、各々第0引数としての「実行ファイル名」を含んでいる。
\item main関数には第3引数として\verb|char *envp[]|を付すこともでき、これは環境変数のリストを表す。
\item 環境変数の個数は引数としては現れてこないが、ターミネータとしてNULLポインタがあるので、これを用いて取得できる。
\item main関数の引数に用いる名前は、慣例的にここで書いた名前(argc,argv,envp)を用いることになっている。
\end{itemize}
\end{shadebox}


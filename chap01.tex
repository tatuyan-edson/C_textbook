それでは、プログラミングについて学んでいこう。ここではまず、プログラミングとは何かという概論を話す。次いで、どのようにして作るのかという基本的な手順を学んだ後、標準出力への出力という、最も単純なプログラムを組んでみる。
\section{プログラミングとは何か}
「\textbf{プログラミング}\index{ぷろぐらみんぐ@プログラミング}(programming)とは何か」というタイトルはこれからプログラミングを学ぼうという人にとって大変親切で、かつ適切なタイトルであるが、同時に様々な意味をもち、ある程度プログラムに慣れた人にとってもある種の意味をなす質問だろう。プログラミングとは何か、その質問に対して、もちろん、一般的に辞書的に意味を説明するのが本講の目的だが、その質問は辞書的以外の意味をも十分持ちうるのである。例えば「私にとってプログラミングとは何か」という、人の思いに対する質問とも捉えられるし、「社会的にプログラミングとはどういった価値をもつのか」という、位置づけを問うこともできる。ある種のジョークのように聞こえるかもしれないが、哲学的に「プログラミングとは一体何なのか？」と考察することもできよう\footnote{ここではジョークのように聞こえると書いたが、決してプログラミングと哲学が無関係なわけではない。例えばPrologという言語はAI(人工知能)の研究によく用いられるプログラミング言語であるが、AIの根幹の部分ではルートヴィヒ・ウィトゲンシュタインの「論理哲学論考」などが大きな役割を果たしている。哲学に不案内であっても、「AIというものがあるとき、それをそもそも作ったプログラミング言語というのは一体何か？」という問いかけは、「人間の知能のプログラミング言語にあたるものは存在するのか？」という哲学的に思える問いに直結することがわかるだろう。}。ともかく、「プログラミングとは何か？」という問いはその文脈によって大きく変わりうるものである。そして、読者諸賢には、本書の内容を身につけていただくにしたがって「私にとってプログラミングとは一体何か？」ということも考えていただきたい。
\\ \\　
さて、プログラミングとは一体何なのか、辞書的にみていくこととしよう。手持ちの「新明解国語辞典(三省堂)」を引くと、次のように書かれている。
\begin{itemize}
\item プログラミング：コンピュータにさせる仕事の手順を詳しく分析し、プログラムを作ること。
\item プログラム：コンピュータに実行させる計算処理の手順を、コンピュータに受け入れ可能な一連の命令文の形で並べて書いたもの(あるいは書くこと)。
\end{itemize}

一方、Wikipediaには次のように書かれている。
\begin{itemize}
\item プログラミング：プログラムを作成することにより人間の意図した処理を行うようにコンピュータに指示を与える行為である。
\item プログラム：コンピュータに対する命令処理を記述したもの。
\end{itemize}
見比べればわかる通り、どちらも大差ない説明である。そして、どちらも間違っていないが、どうも無味乾燥であり、いかにも難しいといったもののように思えてしまう。
\\ \\　
プログラミングを好んでいる人がいて、それを趣味としている筆者のような人もいるほどなのだから、こんなにも冷たい説明では実感がわきにくい。辞書の説明だから冷たいのは当然であるが、もう少し具体的に、躍動感のある意味を追求してみよう。我々が日常的に目にするドラマ・映画などはお芝居であり、脚本がある。芝居のときに人間がどのように動けばいいかを記したのが脚本であるのと同様に、何かをなすとき、例えばゲームを動かすときに、コンピュータがどのように動けばいいかを記したものがソースコードというプログラムの"もと"である。マニュアルの作成と言ってもいいが、手順書を作成し、コンピュータを動かすことで何かをなす、それがプログラミングである。その何かはゲームでもいいし、音楽でもかまわない。あるいは文書処理や翻訳かもしれない。ともかく、そういった行為を行う際に動く手順を定め記すのがプログラミングである。それは脚本を書くように創作的な行為であり、でき上がりのドラマを見る楽しみをコンピュータ上で味わえるものである。プログラマーは脚本家と監督を兼任し、コンピュータが俳優の役割をする。そうしてでき上がったドラマをプログラムと呼んでいる。このように記せば、プログラミングが生きたものとして伝わってくるのではないだろうか。

\section{プログラミング言語とC言語}
先に記したとおり、プログラミングとはコンピュータがどのように動けばいいかを記す行為である。何かを記すには、言葉が必要である。プログラミングを行うための言語を\textbf{プログラミング言語}\index{ぷろぐらみんぐげんご@プログラミング言語}(programming language)という。プログラミング言語は多種多様であり、各言語はそれぞれに特徴を持っている。そのため、一般には利用目的に適したプログラミング言語を選ぶ。

プログラミング言語にはいくつもの分類があるが、ここでは、Cのソースコードを書いてそれが実行されるまでの流れを理解するのに重要な「高級言語」「低級言語」を紹介する。
\subsection{高級言語・低級言語と処理の流れ}
通常、プログラムは1と0からなる機械語およびそれをもう少しまとめたバイトコードとしてメモリにロードされ、それが実行される。これは、コンピュータが唯一理解、実行できる形態である。プログラミングとは、この1と0を適当な順番に配置し、希望する機能を実現することである。だが、直接1と0を配置するのは問題がある。というのは、CPUに応じて命令セットが違うためである。また、この形式では当然、人間にはわかりにくい。そこで、これらの汎用性を高め、人間にわかりやすいようにした。このようにして生まれた、人間にわかりやすく、CPUの命令セットによらずにプログラミングできる言語のことを\textbf{高級言語・高水準言語}\index{こうきゅうげんご@高級言語}\index{こうすいじゅんげんご@高水準言語|see{高級言語}}と呼ぶ。

高級言語で書かれたソースは、各々のCPUにおいて、その機械語と1対1に対応する命令によって書かれたバイトコードに変換される。このように、機械語及びそれと1対1対応する、機械毎に固有の言語(命令セット)を\textbf{低級言語・低水準言語}\index{ていきゅうげんご@低級言語}\index{ていすいじゅんげんご@低水準言語|see{低級言語}}と呼ぶ。また、この変換(翻訳)行為を\textbf{コンパイル}\index{こんぱいる@コンパイル}(compile)と呼ぶ。我々は高級言語、ここではそのひとつであるC言語を用いてプログラムを記述し、そのソースをコンパイル、低級言語で書かれたバイトコード(実行ファイル)を生成して、プログラムを実行するのである。

\subsection{C言語の特徴}
C言語は高級言語であるが、その特徴から俗に「高級言語の顔をした低水準言語」や「中級言語」などと呼ばれることもある。その特徴には、次のようなものがある。
\begin{itembox}[l]{C言語の特徴}
\begin{itemize}
\item C言語は、構造化手続き言語\footnote{構造化手続き言語とは、E.W.Dijkstra(1930-2002)の提唱した「\textbf{構造化プログラミング}\index{こうぞうかぷろぐらみんぐ@構造化プログラミング}:あらゆるアルゴリズムは連接(順次)・分岐・反復の3構造により実現でき(\textbf{構造化定理}\index{こうぞうかていり@構造化定理})、その3構造を関数などによって適度に分離、ルーチン毎に細部を記述していくというプログラミングパラダイム」に従い、手続きを順に記すことでプログラムを作成する言語である。}である。
\item メモリのレベルまで含めた、かなり機械に近い処理ができる。
\item システム記述に向いている言語である。
\item プログラミング人口が多い。Tiobe programming community\footnote{\url{http://www.tiobe.com/index.php/content/paperinfo/tpci/index.html}}によれば、2002年以後世界で1〜2位のシェアを誇る。
\item 非常に自由度が高く、大抵の機能を実装することができる。これは、悪く言えば、コンピュータにとって危険な処理も作れてしまうということである。
\item 基本的にプログラマに信頼を寄せた言語となっており、自動的に行われる処理は少ない\footnote{逆に、Javaは危険な処理を自動的に検知し、些か口煩いと思う人もいるぐらいに忠告をする言語である。}。これは、自由度が高いがゆえにプログラマに重責があるということでもある。
\item 様々な言語の基になっている。
\end{itemize}
\end{itembox}

とりわけ、自由度が高く、低水準命令が可能でシステム記述に向いていることから、UNIXを始めとしたOSカーネルや組み込みプログラミング\footnote{家電等「いわゆるコンピュータ」ではない様々な機器のシステム等のプログラミング。}に利用されている。

\subsection{C言語の歴史}
C言語は現在一般に使われているプログラミング言語ではかなり古い部類に入る言語である。C++やJavaなどの言語がCの構文を元にしていることからもわかるとおり、非常に多くの分野で使われている言語であるが、この言語にも元の言語が存在する。それがBCPLとBである。前者はオペレーティングシステムやコンパイラを書くために開発された言語で、これをモデルにしてUNIXオペレーティングシステムの初期バージョン開発に向けて作られたのがBであった。1960年後半〜70年代にかけてのことである。
\\ \\　
アメリカ・ベル研究所のD.M.Ritchie(1941-2011)はBを元にしてC言語を作った。これがC言語のはじめである。この時代においてのC言語は、小型で効率的であり、しかも強力なプログラミング言語であったため(現代でも強力と言い切れるかどうかは、特にC++と比べてそう言えるかどうかは、疑問の余地が残るが)、多く使われるようになっていった。だが、この広まり方はC言語の“方言”とでも言うべき、様々な「規格」を生み出す要因となってしまった。この是正のため、1982年、ANSI(American National Standards Institute)内で委員会が組織され、その時点で最も広まっていたCの方言である「K\&R C」\footnote{B.W.Kernighan(1942-)と(先に名の出てきた)RitchieのCという意味である。この二人は「プログラミング言語C(The programming language C)」というCの原点とも言うべき書籍を著した。惜しいことに、Ritchieは2011年10月に亡くなってしまったが、Kernighanは存命である。「プログラミング言語C」はANSI規格(C89)に対応した第2版が出版されており、通称「K\&R本」として広く知られている。なお、日本語版は石田晴久氏の訳が共立出版より出版されている。}を基に標準規格を定める運びとなった。委員会発足から7年を経た1989年、規格化されたC言語、現在に至るまでANSI C(C89)と呼ばれるC言語が誕生したのである。現在のコンパイラは少なくともこの規格に則っているものとして問題ないし、また、この規格より以前のC文法に従ってコードを書く意味はないと言って良い。この規格がそのまま国際標準となり、現在のCの基盤をなしているからである。
\\ \\　
だが、1989年の規格に一切の改良が行われなかったわけではない。とりわけ、1999年のC++を意識した規格の変更は大きなものであった。本書を書いている2012年現在、1995年と1999年、2011年に、C言語は三度の改訂を経ている。1995年の改訂は89年制定のCに対して、各国の文字を扱えるようにする改訂であった。これは、それまでのCに対して軽い追加が行われた程度のものであり、大きな変動ではなかった。

一方、1999年制定のCはC99とも呼ばれるかなり大幅な拡張であった。89年のCに対して、C++を意識した拡張を行ったのがこの改訂である。1989年以降のCで書かれたコードであれば、大抵は現在のこのC99規格でも動くと考えて差し支えない。だが、この規格は意外と知られておらず、書店に並んでいる本を見ても、この事まで書いている本は多くなく、むしろごく一部にC99の概念が取り入れられている程度に過ぎない本が多い。特によく目にするのが、\verb|//|によるコメントを説明していながら(このコメントはC99規格で取り入れられたもので、C89の規格では通用しない。コメントについてはあとのページを参照されたい。)、これがあたかも昔からのCに存在するかのように書いている本である。明確にされていないが、背景でC99を使っているのである。
\\ \\　
2011年にC++11というC++の新規格と共に出されたCの新規格はC11と呼ばれている。ここでの改訂は、C言語をより現代的な視点に対応させるための改訂と言える。しかしながら、この規格は、出てから時間が経過していないという事もあり、対応しているコンパイラが少ない。また、本書の段階でC11で新たにできた文法が必要になることは少ない。このことを踏まえ、本書ではC99の規格を基に、旧来のC規格にも通用する内容を記述することにする。C11については脚注などで触れるに留める。

\section{プログラム作成の一連の流れ}
プログラムの作成は概ね、次の順で行われる。
\begin{enumerate}
\item 作成したいものを決める。(プログラムの計画)
\item 作成したいものをどのようにしてプログラムにするかを決める(\textbf{アルゴリズム}(algorithm)\index{あるごりずむ@アルゴリズム}を立てる)。
\item 立てたアルゴリズムにしたがってソースコードを打つ(\textbf{コーディング}(coding)\index{こーでぃんぐ@コーディング})。
\item 作成したソースコードをコンパイルして実行する。
\item コンパイル中ないしプログラムの実行中にエラーが出た場合は、そのエラーを取り除く(\textbf{デバッグ}(debug)\index{でばっぐ@デバッグ})。
\item ソースコードの無駄な部分を取り除く(プログラムの改良)。
\end{enumerate}
これを実際に体験してみよう。

\subsection{コーディングまでの体験}
はじめなので、あまり難しいプログラムを書くことはできない。今回は最も単純に、標準出力に
\begin{code}
hello, world
\end{code}
と出力するプログラムを作成してみよう。なお、第0講で記したとおり、以降のプログラムは(特段の記述がなければ)Linuxにgccをインストールしていることを前提に行う。
\\ \\　
まず、端末を開き、適当なフォルダを作成し、そこに移動する。例えば、
\begin{code}
mkdir Clang
cd Clang
mkdir class2
cd class2
\end{code}
とすれば、ホーム以下にClangというフォルダができ、その中にclass2というディレクトリを入れて、そこで作業することになる。
\\ \\　
フォルダを移動したら、テキストエディタを開こう\footnote{第0講にも記したが、emacsはテキストエディタに応じてtea,editra,gedit等に読み替えること。}。
\begin{code}
emacs Hello.c
\end{code}
　このように書けば、\verb|Hello.c|という名前の\textbf{ソース}(Source code)\index{そーす@ソース}を作ることになる。ここで、ソースというのはプログラムの内容を記述したファイルである。

それでは、次の問題を読んで、書いてある解答例(リスト\ref{program1_1})を打ち込んでみよう。この時、ソースには、適度に空行やタブ(\textbf{インデント}\index{いんでんと@インデント})が入っているが、これはソースを読みやすくするための工夫であるので、その部分も真似してみて欲しい。但し、誤って全角空白を入れないこと(エラーになる)。なお、以降のソースでは、紙面節約のためスペースや空行を省くが、単語等を分割しない範囲で、読みやすいように空白等を入れたほうが良い。
\begin{boxnote}
\minisec{hello worldプログラム}
"hello, world"と出力するプログラムを作成する。
\begin{multicols}{2}
\minisec{解説}
hello, worldと出力するプログラムは、一般に「ハローワールド」と呼ばれており、多くの言語の入門書の最初に挙げられている「世界一有名なプログラム」である。初出は先に記した「プログラミング言語C」であるとされる。\\
　その名の通り、ただhello, worldと出力されるだけのシンプルなプログラムであるが、言語の書式を学ぶ上で、とても重要なプログラムでもある。

\begin{lstlisting}[caption=ハローワールド,label=program1_1]
/* hello, world
   puts Version */

#include<stdio.h>

// main function
int main(void){

  //output for stdout.
  puts("hello, world");

  return 0; //val=0
}
\end{lstlisting}
\end{multicols}
\end{boxnote}

以上を打ち込み終わったら、保存して(emacsの場合、ctrl+xを押した後、ctrl+sを押せば保存できる)、テキストエディタを閉じよう。

\subsection{コンパイル・実行}
さて、それではコンパイルして実行ファイルを生成しよう。コンパイルのコマンドは次の通りである。
\begin{itembox}[l]{プログラムのコンパイル}
あるソースをgccでコンパイルして、実行ファイルを得るためのコマンドは
\begin{code}
gcc (ソースファイル名) -o (出力実行ファイル名)
\end{code}
である。この時、\verb|-o|以下を省略すると、a.outという実行ファイルができる\footnote{Windowsの場合は、a.exeという実行ファイルができる。}。
\end{itembox}

したがって、
\begin{code}
gcc Hello.c -o Hello.out
\end{code}
とすれば、実行ファイルHello.outが生成されるはずである。もし何らかのエラーが出たら、どこかに打ち間違いがあると考えられるので、再度テキストエディタを開いて間違っている場所を調べてみよう。このように、誤り(\textbf{バグ}\index{ばぐ@バグ}(bug)\footnote{原義は「虫」であり、トーマス・エジソンも使っていたことが知られているが、「世界最初のバグ」は昔の大型コンピュータに実際に虫が入ったものであるとされている。})を取り除くことを\textbf{デバッグ}\index{でばっぐ@デバッグ}(debug)と呼ぶ。

続いて、できたファイルを実行する。これは、
\begin{code}
./Hello.out
\end{code}
などとすれば良い。正しくできていれば、コンソール上に
\begin{code}
hello, world
\end{code}
と出力されるはずである。
\\ \\　
以上のようにして、プログラムを作成することができる。今後、この手続きは何度もやっていくことになるので、今取り立てて覚えずとも、そのうち自然と身につくだろう。

\subsection{「はじめてのプログラム」の解説}
さて、それではリスト\ref{program1_1}のプログラムがどのような動作をしているのか、コードを追いつつ順に説明していこう。

\minisec{コメント}
このプログラムの1,2,6,9行目はコメント行であり、12行目にもコメントがある。\textbf{コメント}\index{こめんと@コメント}(comment)とは、ソースコードのうち、我々人間のために覚え書きとして挿入される注釈のことである。この部分は、コンパイルの際に何も書いていないものと同様に扱われるので、好きなことを書くことができる。この例のようにタイトルを書いたり、文法解説やアルゴリズム解説の際に横に入れたり、デバッグの際に一時的にコードを無効化したりと、色々な用途に使う。なお、本書では紙面節約のため、掲載ソースリストのコメントは省く。だが、一般には別人\footnote{たとえ自分自身しか使わないソースコードでも、コメントを書くに越したことはない。というのは「1か月後の自分は別人と思え」と言われるほど、ソースコードの細部は覚えにくいものだからである。}が読んでもわかるようにコメントを書くべきである。
\\ \\　
C言語では、コメントは2種類ある。
\begin{itemize}
\item \verb|//|から行末まで。
\item \verb|/*|から始まり、最初に出てくる\verb|*/|まで。
\end{itemize}
前者は1行のコメントまたは命令のすぐ横に使う場合が多い\footnote{実は工夫次第で2行以上のコメントも書けるのだが、わかりにくいので使わないほうが良い。}。このように、行末までをコメントとみなすコメントの形式を\textbf{インラインコメント}\index{いんらいんこめんと@インラインコメント}(in-line comment)と呼ぶ。一方で、後者は、タイトルで使っているように、何かまとまったコメントを書きたい場合に使うことが多い。このように、ある記号から始まりある記号で終わる(この場合、\verb|/*|から始まり\verb|*/|で終わる)コメントの形式を\textbf{ブロックコメント}\index{ぶろっくこめんと@ブロックコメント}(block comment)と呼ぶ。
\\ \\　
コメントは冗長すぎても良くないし、少なすぎるのも後々困ることになる。コメントの基準は人によるが、概ね処理の要約を基本に、難解な処理に解説をつけていく形でコメントを付すと、読みやすいソースになる。

\minisec{include文}
コメントを抜いて、実質的に意味があるのは4行目である。この行は\textbf{include文}\index{includeぶん@include文}と呼ばれる文で、\verb|< >|で囲まれた\textbf{ヘッダファイル}\index{へっだふぁいる@ヘッダファイル}(header file)を読み込む\footnote{実際にはダブルクォーテーション(")で囲む場合もある。これについては、後の講で説明する。}という意味である。ヘッダファイルというのは、Cの様々な命令(関数)の入っている辞典のような物だと思えば良い。(実際には、辞典そのものは\textbf{ライブラリ}\index{らいぶらり@ライブラリ}(library)と呼び、ヘッダファイルはこれを引くための道具である。)これらの辞典を読み込むことにより、コンパイラは命令を解釈することができる。このことからわかるとおり、この一文はコンパイラへの命令である。このようなコンパイラへの命令のことを\textbf{前処理命令}\index{まえしょりめいれい@前処理命令}または\textbf{プリプロセッサ命令}\index{ぷりぷろせっさめいれい@プリプロセッサ命令}(preprocessor command)と呼び、\#から始める\footnote{この記号(\#)は「シャープ」ではなく「ハッシュ」である。二つの記号は線の角度が違う。}。includeはヘッダファイル等の読み込みを行う前処理命令である。
\\ \\　
今回読み込んだstdio.hはstandard input and output(標準入出力)のライブラリで、その名前通り、入出力に関する命令が収められているライブラリである。このように、C言語が仕様として標準で用意しているライブラリのことを\textbf{標準ライブラリ}\index{ひょうじゅんらいぶらり@標準ライブラリ}と呼ぶ。
\\ \\　
以上を踏まえると、リスト\ref{program1_1}の第4行は、「以降で標準入出力の命令を使えるようにするため、stdio.hのライブラリを読み込め」という意味になる。

\minisec{main関数}
プログラムのソースコードは原則上から下に向けて解釈される。だが、実際にはプログラムの主幹を司る部分を各プログラムに一つ作り、その部分を実行することによってプログラムが動く。つまり、プログラムというのは、主部より前に準備のための文があり(先のincludeなどはまさにそれである)、主部があり、その後ろに(必要に応じて)主部を詳述する部分がある、という構成になる。このうち、準備のための文や主部を詳述する部分は必要ない場合もあるが、主部はプログラム毎に必ず1つ必要である。この主部を示すのが\textbf{main関数}\index{mainかんすう@main関数}である(リスト\ref{program1_1}の、第7行から第13行の部分)。当面の間、main関数は次のように記せばよい。
\begin{itembox}[l]{main関数の書き方}
main関数は、次のような形式で記す。(但し、後に学ぶコマンドライン引数を用いる場合はこの限りではない。)
\begin{code}
int main(void){
  処理を記す
}
\end{code}
\end{itembox}
main関数の定義にあるint,voidについては後の自作関数の講で詳しく解説するので、ここでは「このように書くものである」と思っておいて良い。

\minisec{puts関数}
リスト\ref{program1_1}の第10行目は今後Cプログラムを書いていく上で必要なことを多く含む、示唆に富む1行である。動作は"hello, world"と標準出力(コンソール)に出力するだけのものだが、それ以外の、ルールなどの面でこの一文から学べるものは多い。
\\ \\　
putsはstdio.hに入っている\textbf{関数}\index{かんすう@関数}で、put stringの意味である。この関数は\textbf{引数}\index{ひきすう@引数}(ひきすう,argument)の文字列を標準出力に出力し、\underline{最後に改行する}関数である。ここまでさらりと説明したが、新たな用語が連続しているので、その用語を見ていくこととする。

関数というのは後ろに( )を伴い、何らかの値を与えると、それに対して処理を行い、何かの値を返すものを言う。ここであげたputs関数は、文字列を引数にとり、その引数の文字列を標準出力に出力し(処理)、無事に出力できたかどうかを(内部的に)返す。この時に返す値のことを\textbf{返却値}\index{へんきゃくち@返却値}\footnote{返し値、戻り値などとも言う。「返却値」はJIS規格での呼び方である。}(return value)と呼ぶ。

少しわかりづらいかもしれないので、出前を例に考えてみよう。まず、出前して欲しい店に、電話などで注文を行う。これを受けて、店では注文されたメニューを料理する。その後、店から自分のところに注文した料理が届く。この、注文が引数であり、店での調理が処理、自分のところに届いた料理が返却値である。つまり、出前という関数は「注文」を引数にとって、それに対応した「料理」を返却すると言える。
\\ \\　
ここまででputsの意味はわかったと思うが、後2点、ダブルクォーテーション(")の意味と、セミコロン(;)の意味について見ていこう。

ダブルクォーテーションは二つセットで、その間が文字列であることを示す\footnote{厳密には文字列リテラルというものであり、これについては後に詳述する。}。

セミコロンは、Cの各文の最後に付ける記号で、日本語の句点(。)や英語のピリオド(.)に相当するものである。

\minisec{return文}
先に書いたとおり、関数は返却値を持つ\footnote{持たない関数もあるが、これは「持たない」ようにしているから持たないのであって、例えば標準ライブラリでは持つ関数のほうが多い。}。そして、main関数は名前が示唆する通り、関数である。したがって、main関数も返却値を持つ(ようにしている)。この返却値を指定するのがreturn文である。

また、関数は返却値が定まった時点で終了するので、関数の終了を示すためにreturn文を用いる場合もある(後述)。

return文で返却値を定める場合は、次のように記す。
\begin{itembox}[l]{return文}
関数の返却値にはreturn文を用い
\begin{code}
return (返却値);
\end{code}
と記すことによって返却値を指定できる。(返却値を持たない関数の終了のみを示す場合、返却値を指定しないこともある(後述)。)
\end{itembox}

main関数は、正常終了した場合0を返すように作る(つまり、return 0を処理の終端に書く)のが慣例である。

\section{標準出力への出力}
簡単なプログラムを一つ作ったところで、もうひとつ、出力するだけのプログラムを作ってみよう。
\begin{boxnote}
\begin{multicols}{2}
\minisec{簡単な表の出力}
簡単な表を出力してみる。
\minisec{解説}
水平タブ文字を用いて場所を揃えることにより、簡単な表を作ることができる。今回は、数学の記号とその正式名称を出力するプログラムを書いてみよう。なお、8行目が2行に渡っているが、実際のプログラムでは1行に続けて書くこと。

\begin{lstlisting}[caption=数学の記号表出力,label=program1_2]
#include<stdio.h>

int main(void){
  printf("Math words.\n");
  putchar('\n');

  puts(" sin \t lim \t sup");
  puts(" sine \t limit \t supremum");
  return 0;
}
\end{lstlisting}
\end{multicols}
\end{boxnote}
\minisec{エスケープシークエンス}
リスト\ref{program1_2}には\verb|\n|や\verb|\t|といった文字が登場する。これらは各々、改行や水平タブを表している。このように、コード上で意味を持っているなどの理由で書き表すことができない文字に対しては、代替となる書き方が用意されている。このような文字のことを\textbf{エスケープシークエンス}\index{えすけーぷしーくえんす@エスケープシークエンス}(escape sequence)とよび、\verb|\|記号\footnote{バックスラッシュ。日本の円マークも同じ役割であり、バックスラッシュが出ない代わりに円マークが用いられる場合もある。}に文字を付けることで実現される。エスケープシークエンスは2文字(以上)に見えるが、実際には\verb|\n|や\verb|\t|で1文字である。よく使うエスケープシークエンスを表\ref{escape_seq}に示す。
\begin{table}[htbp]
 \centering
 \caption{よく使うエスケープシークエンス}\label{escape_seq}
  \begin{tabular}{|c|c||c|c|} \hline
            文字&意味&文字&意味        \\ \hline
              &&&          \\[-15.5pt] \hline
   \verb|\0| & NULL文字 &\verb|\'| & シングルクォーテーション\\ \hline
   \verb|\t| & 水平タブ文字 &\verb|\"| & ダブルクォーテーション\\ \hline
   \verb|\r| & 復帰文字 &\verb|\\| & バックスラッシュ\\ \hline
   \verb|\n| & 改行文字 &\verb|\?| & クエスチョン\\ \hline
  \end{tabular}
\end{table}

表\ref{escape_seq}に載っている\verb|\r|はCR(キャリッジリターン、carriage return)で、Macでの改行コードである。一方\verb|\n|はLF(ラインフィールド、line field)で、Linuxなどでの改行コードである。Windowsの改行コードはCR+LF(\verb|\r\n|)であり、メールの通信などでもCR+LFが使われている。
\\ \\　
エスケープシークエンスは、リスト\ref{program1_2}のように、文字列の間や、あるいはそれ単独で用いて、表\ref{escape_seq}に示したような意味になる。

\minisec{printf関数とputchar関数}
リスト\ref{program1_2}において新しく出てきた関数にprintf関数とputchar関数がある。これらについて説明する。
\\ \\　
printf関数は、後からより詳しく説明するが、書式指定文字列という文字列を出力する関数である。現状での動作は、puts同様、引数の文字列を標準出力に出力するだけだが、printf関数は出力した後\underline{最後に改行しない}関数である。そのため、リスト\ref{program1_2}の4行目では、最後に\verb|\n|を書いて意図的に改行させている。
\\ \\　
putchar関数は文字を一文字だけ、標準出力に出力する関数である。C言語ではシングルクォーテーション記号で囲むことで、それを文字として扱う(囲まなければ、命令や後に記す変数などとして認識してしまう)。ここでは、\verb|\n|という一文字がシングルクォーテーションで囲まれているので、5行目は改行文字の出力、すなわち「改行せよ」という意味になる。
\\ \\　
printf関数やputchar関数を使うと、プログラムの終了直前の出力の最後に改行されないようなプログラムができてしまう。だが、これではコンソールが見難くなる。そのため、出力の終端では必ず改行を入れるようにしておくのがマナーである。
\newpage

\begin{shadebox}
\section*{本講の要点}
本講では、まずプログラミングとはどのようなものか考え、C言語の特徴について学んだ後、実際に簡単なプログラムを書いてプログラミングを体験的に学んだ。
\subsection*{C言語とプログラミングの概観}
\begin{itemize}
\item プログラミングは、コンピュータの動作手順を記し、そこから実行ファイルを生成する行為である。
\item C言語はシステム向けのプログラミング言語で、高い汎用性を持つ。
\item プログラミングを行う際には、作るものを設計し、アルゴリズムを定め、コーディングした後コンパイルし、最後にデバッグを行って完成という流れが一般的である。
\end{itemize}

\subsection*{C言語の基礎的な文法と標準出力}
\begin{itemize}
\item ソースを書く際には、必要に応じてインデントを入れたり、理解を助けるための注釈であるコメントを入れたりすることで、読みやすく書くのが大切である。
\item コンパイラに対する命令を前処理命令と呼び、ハッシュ(\#)の後に記す。
\item include文は必要なライブラリを読み込む前処理命令である。
\item プログラムには主部であるmain関数が必要である。
\item 各文の終わりにはセミコロン(;)を付す。
\item main関数では、慣例としてreturn 0;により、返却値として0を返す(正常終了の場合)。
\item 文字で表すことのできない改行やタブといった記号を表すために、エスケープシークエンスがある。
\item \verb|" "|で囲まれた部分は文字列である。
\item \verb|' '|で囲まれた部分は、プログラム上で文字として扱われる。
\item puts関数やprintf関数、putchar関数を用いて出力を行うことができる。
\end{itemize}
\end{shadebox}
